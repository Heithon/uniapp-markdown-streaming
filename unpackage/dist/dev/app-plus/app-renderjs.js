var __renderjsModules={};

__renderjsModules["5dde2a00"] = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/purify.min.js
  var require_purify_min = __commonJS({
    "../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/purify.min.js"(exports, module) {
      !function(e3, t3) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t3() : "function" == typeof define && define.amd ? define(t3) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).DOMPurify = t3();
      }(exports, function() {
        "use strict";
        const {
          entries: e3,
          setPrototypeOf: t3,
          isFrozen: n3,
          getPrototypeOf: o4,
          getOwnPropertyDescriptor: r3
        } = Object;
        let { freeze: i4, seal: a4, create: l4 } = Object, { apply: c3, construct: s3 } = "undefined" != typeof Reflect && Reflect;
        i4 || (i4 = function(e4) {
          return e4;
        }), a4 || (a4 = function(e4) {
          return e4;
        }), c3 || (c3 = function(e4, t4) {
          for (var n4 = arguments.length, o5 = new Array(n4 > 2 ? n4 - 2 : 0), r4 = 2; r4 < n4; r4++)
            o5[r4 - 2] = arguments[r4];
          return e4.apply(t4, o5);
        }), s3 || (s3 = function(e4) {
          for (var t4 = arguments.length, n4 = new Array(t4 > 1 ? t4 - 1 : 0), o5 = 1; o5 < t4; o5++)
            n4[o5 - 1] = arguments[o5];
          return new e4(...n4);
        });
        const u4 = w3(Array.prototype.forEach), m3 = w3(Array.prototype.lastIndexOf), p3 = w3(Array.prototype.pop), f4 = w3(Array.prototype.push), d3 = w3(Array.prototype.splice), h3 = w3(String.prototype.toLowerCase), g4 = w3(String.prototype.toString), T5 = w3(String.prototype.match), y3 = w3(String.prototype.replace), E4 = w3(String.prototype.indexOf), A4 = w3(String.prototype.trim), _4 = w3(Object.prototype.hasOwnProperty), S4 = w3(RegExp.prototype.test), b3 = (N4 = TypeError, function() {
          for (var e4 = arguments.length, t4 = new Array(e4), n4 = 0; n4 < e4; n4++)
            t4[n4] = arguments[n4];
          return s3(N4, t4);
        });
        var N4;
        function w3(e4) {
          return function(t4) {
            t4 instanceof RegExp && (t4.lastIndex = 0);
            for (var n4 = arguments.length, o5 = new Array(n4 > 1 ? n4 - 1 : 0), r4 = 1; r4 < n4; r4++)
              o5[r4 - 1] = arguments[r4];
            return c3(e4, t4, o5);
          };
        }
        function R3(e4, o5) {
          let r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h3;
          t3 && t3(e4, null);
          let i5 = o5.length;
          for (; i5--; ) {
            let t4 = o5[i5];
            if ("string" == typeof t4) {
              const e5 = r4(t4);
              e5 !== t4 && (n3(o5) || (o5[i5] = e5), t4 = e5);
            }
            e4[t4] = true;
          }
          return e4;
        }
        function O4(e4) {
          for (let t4 = 0; t4 < e4.length; t4++) {
            _4(e4, t4) || (e4[t4] = null);
          }
          return e4;
        }
        function v3(t4) {
          const n4 = l4(null);
          for (const [o5, r4] of e3(t4)) {
            _4(t4, o5) && (Array.isArray(r4) ? n4[o5] = O4(r4) : r4 && "object" == typeof r4 && r4.constructor === Object ? n4[o5] = v3(r4) : n4[o5] = r4);
          }
          return n4;
        }
        function D4(e4, t4) {
          for (; null !== e4; ) {
            const n4 = r3(e4, t4);
            if (n4) {
              if (n4.get)
                return w3(n4.get);
              if ("function" == typeof n4.value)
                return w3(n4.value);
            }
            e4 = o4(e4);
          }
          return function() {
            return null;
          };
        }
        const x3 = i4([
          "a",
          "abbr",
          "acronym",
          "address",
          "area",
          "article",
          "aside",
          "audio",
          "b",
          "bdi",
          "bdo",
          "big",
          "blink",
          "blockquote",
          "body",
          "br",
          "button",
          "canvas",
          "caption",
          "center",
          "cite",
          "code",
          "col",
          "colgroup",
          "content",
          "data",
          "datalist",
          "dd",
          "decorator",
          "del",
          "details",
          "dfn",
          "dialog",
          "dir",
          "div",
          "dl",
          "dt",
          "element",
          "em",
          "fieldset",
          "figcaption",
          "figure",
          "font",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "head",
          "header",
          "hgroup",
          "hr",
          "html",
          "i",
          "img",
          "input",
          "ins",
          "kbd",
          "label",
          "legend",
          "li",
          "main",
          "map",
          "mark",
          "marquee",
          "menu",
          "menuitem",
          "meter",
          "nav",
          "nobr",
          "ol",
          "optgroup",
          "option",
          "output",
          "p",
          "picture",
          "pre",
          "progress",
          "q",
          "rp",
          "rt",
          "ruby",
          "s",
          "samp",
          "search",
          "section",
          "select",
          "shadow",
          "slot",
          "small",
          "source",
          "spacer",
          "span",
          "strike",
          "strong",
          "style",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "template",
          "textarea",
          "tfoot",
          "th",
          "thead",
          "time",
          "tr",
          "track",
          "tt",
          "u",
          "ul",
          "var",
          "video",
          "wbr"
        ]), L4 = i4([
          "svg",
          "a",
          "altglyph",
          "altglyphdef",
          "altglyphitem",
          "animatecolor",
          "animatemotion",
          "animatetransform",
          "circle",
          "clippath",
          "defs",
          "desc",
          "ellipse",
          "enterkeyhint",
          "exportparts",
          "filter",
          "font",
          "g",
          "glyph",
          "glyphref",
          "hkern",
          "image",
          "inputmode",
          "line",
          "lineargradient",
          "marker",
          "mask",
          "metadata",
          "mpath",
          "part",
          "path",
          "pattern",
          "polygon",
          "polyline",
          "radialgradient",
          "rect",
          "slot",
          "stop",
          "style",
          "switch",
          "symbol",
          "text",
          "textpath",
          "title",
          "tref",
          "tspan",
          "view",
          "vkern"
        ]), C3 = i4([
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDistantLight",
          "feDropShadow",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
          "feTile",
          "feTurbulence"
        ]), k4 = i4([
          "animate",
          "color-profile",
          "cursor",
          "discard",
          "font-face",
          "font-face-format",
          "font-face-name",
          "font-face-src",
          "font-face-uri",
          "foreignobject",
          "hatch",
          "hatchpath",
          "mesh",
          "meshgradient",
          "meshpatch",
          "meshrow",
          "missing-glyph",
          "script",
          "set",
          "solidcolor",
          "unknown",
          "use"
        ]), I4 = i4([
          "math",
          "menclose",
          "merror",
          "mfenced",
          "mfrac",
          "mglyph",
          "mi",
          "mlabeledtr",
          "mmultiscripts",
          "mn",
          "mo",
          "mover",
          "mpadded",
          "mphantom",
          "mroot",
          "mrow",
          "ms",
          "mspace",
          "msqrt",
          "mstyle",
          "msub",
          "msup",
          "msubsup",
          "mtable",
          "mtd",
          "mtext",
          "mtr",
          "munder",
          "munderover",
          "mprescripts"
        ]), M3 = i4([
          "maction",
          "maligngroup",
          "malignmark",
          "mlongdiv",
          "mscarries",
          "mscarry",
          "msgroup",
          "mstack",
          "msline",
          "msrow",
          "semantics",
          "annotation",
          "annotation-xml",
          "mprescripts",
          "none"
        ]), U3 = i4(["#text"]), z3 = i4([
          "accept",
          "action",
          "align",
          "alt",
          "autocapitalize",
          "autocomplete",
          "autopictureinpicture",
          "autoplay",
          "background",
          "bgcolor",
          "border",
          "capture",
          "cellpadding",
          "cellspacing",
          "checked",
          "cite",
          "class",
          "clear",
          "color",
          "cols",
          "colspan",
          "controls",
          "controlslist",
          "coords",
          "crossorigin",
          "datetime",
          "decoding",
          "default",
          "dir",
          "disabled",
          "disablepictureinpicture",
          "disableremoteplayback",
          "download",
          "draggable",
          "enctype",
          "enterkeyhint",
          "exportparts",
          "face",
          "for",
          "headers",
          "height",
          "hidden",
          "high",
          "href",
          "hreflang",
          "id",
          "inert",
          "inputmode",
          "integrity",
          "ismap",
          "kind",
          "label",
          "lang",
          "list",
          "loading",
          "loop",
          "low",
          "max",
          "maxlength",
          "media",
          "method",
          "min",
          "minlength",
          "multiple",
          "muted",
          "name",
          "nonce",
          "noshade",
          "novalidate",
          "nowrap",
          "open",
          "optimum",
          "part",
          "pattern",
          "placeholder",
          "playsinline",
          "popover",
          "popovertarget",
          "popovertargetaction",
          "poster",
          "preload",
          "pubdate",
          "radiogroup",
          "readonly",
          "rel",
          "required",
          "rev",
          "reversed",
          "role",
          "rows",
          "rowspan",
          "spellcheck",
          "scope",
          "selected",
          "shape",
          "size",
          "sizes",
          "slot",
          "span",
          "srclang",
          "start",
          "src",
          "srcset",
          "step",
          "style",
          "summary",
          "tabindex",
          "title",
          "translate",
          "type",
          "usemap",
          "valign",
          "value",
          "width",
          "wrap",
          "xmlns",
          "slot"
        ]), P3 = i4([
          "accent-height",
          "accumulate",
          "additive",
          "alignment-baseline",
          "amplitude",
          "ascent",
          "attributename",
          "attributetype",
          "azimuth",
          "basefrequency",
          "baseline-shift",
          "begin",
          "bias",
          "by",
          "class",
          "clip",
          "clippathunits",
          "clip-path",
          "clip-rule",
          "color",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "cx",
          "cy",
          "d",
          "dx",
          "dy",
          "diffuseconstant",
          "direction",
          "display",
          "divisor",
          "dur",
          "edgemode",
          "elevation",
          "end",
          "exponent",
          "fill",
          "fill-opacity",
          "fill-rule",
          "filter",
          "filterunits",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "fx",
          "fy",
          "g1",
          "g2",
          "glyph-name",
          "glyphref",
          "gradientunits",
          "gradienttransform",
          "height",
          "href",
          "id",
          "image-rendering",
          "in",
          "in2",
          "intercept",
          "k",
          "k1",
          "k2",
          "k3",
          "k4",
          "kerning",
          "keypoints",
          "keysplines",
          "keytimes",
          "lang",
          "lengthadjust",
          "letter-spacing",
          "kernelmatrix",
          "kernelunitlength",
          "lighting-color",
          "local",
          "marker-end",
          "marker-mid",
          "marker-start",
          "markerheight",
          "markerunits",
          "markerwidth",
          "maskcontentunits",
          "maskunits",
          "max",
          "mask",
          "media",
          "method",
          "mode",
          "min",
          "name",
          "numoctaves",
          "offset",
          "operator",
          "opacity",
          "order",
          "orient",
          "orientation",
          "origin",
          "overflow",
          "paint-order",
          "path",
          "pathlength",
          "patterncontentunits",
          "patterntransform",
          "patternunits",
          "points",
          "preservealpha",
          "preserveaspectratio",
          "primitiveunits",
          "r",
          "rx",
          "ry",
          "radius",
          "refx",
          "refy",
          "repeatcount",
          "repeatdur",
          "restart",
          "result",
          "rotate",
          "scale",
          "seed",
          "shape-rendering",
          "slope",
          "specularconstant",
          "specularexponent",
          "spreadmethod",
          "startoffset",
          "stddeviation",
          "stitchtiles",
          "stop-color",
          "stop-opacity",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke",
          "stroke-width",
          "style",
          "surfacescale",
          "systemlanguage",
          "tabindex",
          "tablevalues",
          "targetx",
          "targety",
          "transform",
          "transform-origin",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "textlength",
          "type",
          "u1",
          "u2",
          "unicode",
          "values",
          "viewbox",
          "visibility",
          "version",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "width",
          "word-spacing",
          "wrap",
          "writing-mode",
          "xchannelselector",
          "ychannelselector",
          "x",
          "x1",
          "x2",
          "xmlns",
          "y",
          "y1",
          "y2",
          "z",
          "zoomandpan"
        ]), H3 = i4([
          "accent",
          "accentunder",
          "align",
          "bevelled",
          "close",
          "columnsalign",
          "columnlines",
          "columnspan",
          "denomalign",
          "depth",
          "dir",
          "display",
          "displaystyle",
          "encoding",
          "fence",
          "frame",
          "height",
          "href",
          "id",
          "largeop",
          "length",
          "linethickness",
          "lspace",
          "lquote",
          "mathbackground",
          "mathcolor",
          "mathsize",
          "mathvariant",
          "maxsize",
          "minsize",
          "movablelimits",
          "notation",
          "numalign",
          "open",
          "rowalign",
          "rowlines",
          "rowspacing",
          "rowspan",
          "rspace",
          "rquote",
          "scriptlevel",
          "scriptminsize",
          "scriptsizemultiplier",
          "selection",
          "separator",
          "separators",
          "stretchy",
          "subscriptshift",
          "supscriptshift",
          "symmetric",
          "voffset",
          "width",
          "xmlns"
        ]), F3 = i4(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), B3 = a4(/\{\{[\w\W]*|[\w\W]*\}\}/gm), W3 = a4(/<%[\w\W]*|[\w\W]*%>/gm), G3 = a4(/\$\{[\w\W]*/gm), Y3 = a4(/^data-[\-\w.\u00B7-\uFFFF]+$/), j3 = a4(/^aria-[\-\w]+$/), X3 = a4(
          /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        ), q3 = a4(/^(?:\w+script|data):/i), $3 = a4(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), K3 = a4(/^html$/i), V3 = a4(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var Z3 = Object.freeze({
          __proto__: null,
          ARIA_ATTR: j3,
          ATTR_WHITESPACE: $3,
          CUSTOM_ELEMENT: V3,
          DATA_ATTR: Y3,
          DOCTYPE_NAME: K3,
          ERB_EXPR: W3,
          IS_ALLOWED_URI: X3,
          IS_SCRIPT_OR_DATA: q3,
          MUSTACHE_EXPR: B3,
          TMPLIT_EXPR: G3
        });
        const J3 = 1, Q3 = 3, ee4 = 7, te4 = 8, ne4 = 9, oe4 = function() {
          return "undefined" == typeof window ? null : window;
        };
        var re4 = function t4() {
          let n4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe4();
          const o5 = (e4) => t4(e4);
          if (o5.version = "3.2.6", o5.removed = [], !n4 || !n4.document || n4.document.nodeType !== ne4 || !n4.Element)
            return o5.isSupported = false, o5;
          let { document: r4 } = n4;
          const a5 = r4, c4 = a5.currentScript, {
            DocumentFragment: s4,
            HTMLTemplateElement: N5,
            Node: w4,
            Element: O5,
            NodeFilter: B4,
            NamedNodeMap: W4 = n4.NamedNodeMap || n4.MozNamedAttrMap,
            HTMLFormElement: G4,
            DOMParser: Y4,
            trustedTypes: j4
          } = n4, q4 = O5.prototype, $4 = D4(q4, "cloneNode"), V4 = D4(q4, "remove"), re5 = D4(q4, "nextSibling"), ie4 = D4(q4, "childNodes"), ae4 = D4(q4, "parentNode");
          if ("function" == typeof N5) {
            const e4 = r4.createElement("template");
            e4.content && e4.content.ownerDocument && (r4 = e4.content.ownerDocument);
          }
          let le4, ce3 = "";
          const {
            implementation: se4,
            createNodeIterator: ue3,
            createDocumentFragment: me3,
            getElementsByTagName: pe3
          } = r4, { importNode: fe3 } = a5;
          let de4 = {
            afterSanitizeAttributes: [],
            afterSanitizeElements: [],
            afterSanitizeShadowDOM: [],
            beforeSanitizeAttributes: [],
            beforeSanitizeElements: [],
            beforeSanitizeShadowDOM: [],
            uponSanitizeAttribute: [],
            uponSanitizeElement: [],
            uponSanitizeShadowNode: []
          };
          o5.isSupported = "function" == typeof e3 && "function" == typeof ae4 && se4 && void 0 !== se4.createHTMLDocument;
          const {
            MUSTACHE_EXPR: he3,
            ERB_EXPR: ge3,
            TMPLIT_EXPR: Te3,
            DATA_ATTR: ye3,
            ARIA_ATTR: Ee4,
            IS_SCRIPT_OR_DATA: Ae3,
            ATTR_WHITESPACE: _e4,
            CUSTOM_ELEMENT: Se3
          } = Z3;
          let { IS_ALLOWED_URI: be3 } = Z3, Ne3 = null;
          const we3 = R3({}, [...x3, ...L4, ...C3, ...I4, ...U3]);
          let Re3 = null;
          const Oe3 = R3({}, [...z3, ...P3, ...H3, ...F3]);
          let ve3 = Object.seal(
            l4(null, {
              tagNameCheck: {
                writable: true,
                configurable: false,
                enumerable: true,
                value: null
              },
              attributeNameCheck: {
                writable: true,
                configurable: false,
                enumerable: true,
                value: null
              },
              allowCustomizedBuiltInElements: {
                writable: true,
                configurable: false,
                enumerable: true,
                value: false
              }
            })
          ), De3 = null, xe3 = null, Le3 = true, Ce3 = true, ke3 = false, Ie3 = true, Me3 = false, Ue = true, ze2 = false, Pe = false, He2 = false, Fe2 = false, Be3 = false, We2 = false, Ge2 = true, Ye2 = false, je = true, Xe2 = false, qe2 = {}, $e3 = null;
          const Ke2 = R3({}, [
            "annotation-xml",
            "audio",
            "colgroup",
            "desc",
            "foreignobject",
            "head",
            "iframe",
            "math",
            "mi",
            "mn",
            "mo",
            "ms",
            "mtext",
            "noembed",
            "noframes",
            "noscript",
            "plaintext",
            "script",
            "style",
            "svg",
            "template",
            "thead",
            "title",
            "video",
            "xmp"
          ]);
          let Ve = null;
          const Ze = R3({}, ["audio", "video", "img", "source", "image", "track"]);
          let Je2 = null;
          const Qe2 = R3({}, [
            "alt",
            "class",
            "for",
            "id",
            "label",
            "name",
            "pattern",
            "placeholder",
            "role",
            "summary",
            "title",
            "value",
            "style",
            "xmlns"
          ]), et2 = "http://www.w3.org/1998/Math/MathML", tt2 = "http://www.w3.org/2000/svg", nt2 = "http://www.w3.org/1999/xhtml";
          let ot2 = nt2, rt2 = false, it2 = null;
          const at2 = R3({}, [et2, tt2, nt2], g4);
          let lt2 = R3({}, ["mi", "mo", "mn", "ms", "mtext"]), ct2 = R3({}, ["annotation-xml"]);
          const st2 = R3({}, ["title", "style", "font", "a", "script"]);
          let ut2 = null;
          const mt2 = ["application/xhtml+xml", "text/html"];
          let pt2 = null, ft2 = null;
          const dt2 = r4.createElement("form"), ht2 = function(e4) {
            return e4 instanceof RegExp || e4 instanceof Function;
          }, gt = function() {
            let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (!ft2 || ft2 !== e4) {
              if (e4 && "object" == typeof e4 || (e4 = {}), e4 = v3(e4), ut2 = -1 === mt2.indexOf(e4.PARSER_MEDIA_TYPE) ? "text/html" : e4.PARSER_MEDIA_TYPE, pt2 = "application/xhtml+xml" === ut2 ? g4 : h3, Ne3 = _4(e4, "ALLOWED_TAGS") ? R3({}, e4.ALLOWED_TAGS, pt2) : we3, Re3 = _4(e4, "ALLOWED_ATTR") ? R3({}, e4.ALLOWED_ATTR, pt2) : Oe3, it2 = _4(e4, "ALLOWED_NAMESPACES") ? R3({}, e4.ALLOWED_NAMESPACES, g4) : at2, Je2 = _4(e4, "ADD_URI_SAFE_ATTR") ? R3(v3(Qe2), e4.ADD_URI_SAFE_ATTR, pt2) : Qe2, Ve = _4(e4, "ADD_DATA_URI_TAGS") ? R3(v3(Ze), e4.ADD_DATA_URI_TAGS, pt2) : Ze, $e3 = _4(e4, "FORBID_CONTENTS") ? R3({}, e4.FORBID_CONTENTS, pt2) : Ke2, De3 = _4(e4, "FORBID_TAGS") ? R3({}, e4.FORBID_TAGS, pt2) : v3({}), xe3 = _4(e4, "FORBID_ATTR") ? R3({}, e4.FORBID_ATTR, pt2) : v3({}), qe2 = !!_4(e4, "USE_PROFILES") && e4.USE_PROFILES, Le3 = false !== e4.ALLOW_ARIA_ATTR, Ce3 = false !== e4.ALLOW_DATA_ATTR, ke3 = e4.ALLOW_UNKNOWN_PROTOCOLS || false, Ie3 = false !== e4.ALLOW_SELF_CLOSE_IN_ATTR, Me3 = e4.SAFE_FOR_TEMPLATES || false, Ue = false !== e4.SAFE_FOR_XML, ze2 = e4.WHOLE_DOCUMENT || false, Fe2 = e4.RETURN_DOM || false, Be3 = e4.RETURN_DOM_FRAGMENT || false, We2 = e4.RETURN_TRUSTED_TYPE || false, He2 = e4.FORCE_BODY || false, Ge2 = false !== e4.SANITIZE_DOM, Ye2 = e4.SANITIZE_NAMED_PROPS || false, je = false !== e4.KEEP_CONTENT, Xe2 = e4.IN_PLACE || false, be3 = e4.ALLOWED_URI_REGEXP || X3, ot2 = e4.NAMESPACE || nt2, lt2 = e4.MATHML_TEXT_INTEGRATION_POINTS || lt2, ct2 = e4.HTML_INTEGRATION_POINTS || ct2, ve3 = e4.CUSTOM_ELEMENT_HANDLING || {}, e4.CUSTOM_ELEMENT_HANDLING && ht2(e4.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ve3.tagNameCheck = e4.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e4.CUSTOM_ELEMENT_HANDLING && ht2(e4.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ve3.attributeNameCheck = e4.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e4.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e4.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (ve3.allowCustomizedBuiltInElements = e4.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Me3 && (Ce3 = false), Be3 && (Fe2 = true), qe2 && (Ne3 = R3({}, U3), Re3 = [], true === qe2.html && (R3(Ne3, x3), R3(Re3, z3)), true === qe2.svg && (R3(Ne3, L4), R3(Re3, P3), R3(Re3, F3)), true === qe2.svgFilters && (R3(Ne3, C3), R3(Re3, P3), R3(Re3, F3)), true === qe2.mathMl && (R3(Ne3, I4), R3(Re3, H3), R3(Re3, F3))), e4.ADD_TAGS && (Ne3 === we3 && (Ne3 = v3(Ne3)), R3(Ne3, e4.ADD_TAGS, pt2)), e4.ADD_ATTR && (Re3 === Oe3 && (Re3 = v3(Re3)), R3(Re3, e4.ADD_ATTR, pt2)), e4.ADD_URI_SAFE_ATTR && R3(Je2, e4.ADD_URI_SAFE_ATTR, pt2), e4.FORBID_CONTENTS && ($e3 === Ke2 && ($e3 = v3($e3)), R3($e3, e4.FORBID_CONTENTS, pt2)), je && (Ne3["#text"] = true), ze2 && R3(Ne3, ["html", "head", "body"]), Ne3.table && (R3(Ne3, ["tbody"]), delete De3.tbody), e4.TRUSTED_TYPES_POLICY) {
                if ("function" != typeof e4.TRUSTED_TYPES_POLICY.createHTML)
                  throw b3(
                    'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.'
                  );
                if ("function" != typeof e4.TRUSTED_TYPES_POLICY.createScriptURL)
                  throw b3(
                    'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.'
                  );
                le4 = e4.TRUSTED_TYPES_POLICY, ce3 = le4.createHTML("");
              } else
                void 0 === le4 && (le4 = function(e5, t5) {
                  if ("object" != typeof e5 || "function" != typeof e5.createPolicy)
                    return null;
                  let n5 = null;
                  const o6 = "data-tt-policy-suffix";
                  t5 && t5.hasAttribute(o6) && (n5 = t5.getAttribute(o6));
                  const r5 = "dompurify" + (n5 ? "#" + n5 : "");
                  try {
                    return e5.createPolicy(r5, {
                      createHTML: (e6) => e6,
                      createScriptURL: (e6) => e6
                    });
                  } catch (e6) {
                    return console.warn(
                      "TrustedTypes policy " + r5 + " could not be created."
                    ), null;
                  }
                }(j4, c4)), null !== le4 && "string" == typeof ce3 && (ce3 = le4.createHTML(""));
              i4 && i4(e4), ft2 = e4;
            }
          }, Tt = R3({}, [...L4, ...C3, ...k4]), yt = R3({}, [...I4, ...M3]), Et = function(e4) {
            f4(o5.removed, { element: e4 });
            try {
              ae4(e4).removeChild(e4);
            } catch (t5) {
              V4(e4);
            }
          }, At = function(e4, t5) {
            try {
              f4(o5.removed, { attribute: t5.getAttributeNode(e4), from: t5 });
            } catch (e5) {
              f4(o5.removed, { attribute: null, from: t5 });
            }
            if (t5.removeAttribute(e4), "is" === e4)
              if (Fe2 || Be3)
                try {
                  Et(t5);
                } catch (e5) {
                }
              else
                try {
                  t5.setAttribute(e4, "");
                } catch (e5) {
                }
          }, _t = function(e4) {
            let t5 = null, n5 = null;
            if (He2)
              e4 = "<remove></remove>" + e4;
            else {
              const t6 = T5(e4, /^[\r\n\t ]+/);
              n5 = t6 && t6[0];
            }
            "application/xhtml+xml" === ut2 && ot2 === nt2 && (e4 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e4 + "</body></html>");
            const o6 = le4 ? le4.createHTML(e4) : e4;
            if (ot2 === nt2)
              try {
                t5 = new Y4().parseFromString(o6, ut2);
              } catch (e5) {
              }
            if (!t5 || !t5.documentElement) {
              t5 = se4.createDocument(ot2, "template", null);
              try {
                t5.documentElement.innerHTML = rt2 ? ce3 : o6;
              } catch (e5) {
              }
            }
            const i5 = t5.body || t5.documentElement;
            return e4 && n5 && i5.insertBefore(r4.createTextNode(n5), i5.childNodes[0] || null), ot2 === nt2 ? pe3.call(t5, ze2 ? "html" : "body")[0] : ze2 ? t5.documentElement : i5;
          }, St = function(e4) {
            return ue3.call(
              e4.ownerDocument || e4,
              e4,
              B4.SHOW_ELEMENT | B4.SHOW_COMMENT | B4.SHOW_TEXT | B4.SHOW_PROCESSING_INSTRUCTION | B4.SHOW_CDATA_SECTION,
              null
            );
          }, bt = function(e4) {
            return e4 instanceof G4 && ("string" != typeof e4.nodeName || "string" != typeof e4.textContent || "function" != typeof e4.removeChild || !(e4.attributes instanceof W4) || "function" != typeof e4.removeAttribute || "function" != typeof e4.setAttribute || "string" != typeof e4.namespaceURI || "function" != typeof e4.insertBefore || "function" != typeof e4.hasChildNodes);
          }, Nt = function(e4) {
            return "function" == typeof w4 && e4 instanceof w4;
          };
          function wt(e4, t5, n5) {
            u4(e4, (e5) => {
              e5.call(o5, t5, n5, ft2);
            });
          }
          const Rt = function(e4) {
            let t5 = null;
            if (wt(de4.beforeSanitizeElements, e4, null), bt(e4))
              return Et(e4), true;
            const n5 = pt2(e4.nodeName);
            if (wt(de4.uponSanitizeElement, e4, { tagName: n5, allowedTags: Ne3 }), Ue && e4.hasChildNodes() && !Nt(e4.firstElementChild) && S4(/<[/\w!]/g, e4.innerHTML) && S4(/<[/\w!]/g, e4.textContent))
              return Et(e4), true;
            if (e4.nodeType === ee4)
              return Et(e4), true;
            if (Ue && e4.nodeType === te4 && S4(/<[/\w]/g, e4.data))
              return Et(e4), true;
            if (!Ne3[n5] || De3[n5]) {
              if (!De3[n5] && vt(n5)) {
                if (ve3.tagNameCheck instanceof RegExp && S4(ve3.tagNameCheck, n5))
                  return false;
                if (ve3.tagNameCheck instanceof Function && ve3.tagNameCheck(n5))
                  return false;
              }
              if (je && !$e3[n5]) {
                const t6 = ae4(e4) || e4.parentNode, n6 = ie4(e4) || e4.childNodes;
                if (n6 && t6) {
                  for (let o6 = n6.length - 1; o6 >= 0; --o6) {
                    const r5 = $4(n6[o6], true);
                    r5.__removalCount = (e4.__removalCount || 0) + 1, t6.insertBefore(r5, re5(e4));
                  }
                }
              }
              return Et(e4), true;
            }
            return e4 instanceof O5 && !function(e5) {
              let t6 = ae4(e5);
              t6 && t6.tagName || (t6 = { namespaceURI: ot2, tagName: "template" });
              const n6 = h3(e5.tagName), o6 = h3(t6.tagName);
              return !!it2[e5.namespaceURI] && (e5.namespaceURI === tt2 ? t6.namespaceURI === nt2 ? "svg" === n6 : t6.namespaceURI === et2 ? "svg" === n6 && ("annotation-xml" === o6 || lt2[o6]) : Boolean(Tt[n6]) : e5.namespaceURI === et2 ? t6.namespaceURI === nt2 ? "math" === n6 : t6.namespaceURI === tt2 ? "math" === n6 && ct2[o6] : Boolean(yt[n6]) : e5.namespaceURI === nt2 ? !(t6.namespaceURI === tt2 && !ct2[o6]) && !(t6.namespaceURI === et2 && !lt2[o6]) && !yt[n6] && (st2[n6] || !Tt[n6]) : !("application/xhtml+xml" !== ut2 || !it2[e5.namespaceURI]));
            }(e4) ? (Et(e4), true) : "noscript" !== n5 && "noembed" !== n5 && "noframes" !== n5 || !S4(/<\/no(script|embed|frames)/i, e4.innerHTML) ? (Me3 && e4.nodeType === Q3 && (t5 = e4.textContent, u4([he3, ge3, Te3], (e5) => {
              t5 = y3(t5, e5, " ");
            }), e4.textContent !== t5 && (f4(o5.removed, { element: e4.cloneNode() }), e4.textContent = t5)), wt(de4.afterSanitizeElements, e4, null), false) : (Et(e4), true);
          }, Ot = function(e4, t5, n5) {
            if (Ge2 && ("id" === t5 || "name" === t5) && (n5 in r4 || n5 in dt2))
              return false;
            if (Ce3 && !xe3[t5] && S4(ye3, t5))
              ;
            else if (Le3 && S4(Ee4, t5))
              ;
            else if (!Re3[t5] || xe3[t5]) {
              if (!(vt(e4) && (ve3.tagNameCheck instanceof RegExp && S4(ve3.tagNameCheck, e4) || ve3.tagNameCheck instanceof Function && ve3.tagNameCheck(e4)) && (ve3.attributeNameCheck instanceof RegExp && S4(ve3.attributeNameCheck, t5) || ve3.attributeNameCheck instanceof Function && ve3.attributeNameCheck(t5, e4)) || "is" === t5 && ve3.allowCustomizedBuiltInElements && (ve3.tagNameCheck instanceof RegExp && S4(ve3.tagNameCheck, n5) || ve3.tagNameCheck instanceof Function && ve3.tagNameCheck(n5))))
                return false;
            } else if (Je2[t5])
              ;
            else if (S4(be3, y3(n5, _e4, "")))
              ;
            else if ("src" !== t5 && "xlink:href" !== t5 && "href" !== t5 || "script" === e4 || 0 !== E4(n5, "data:") || !Ve[e4]) {
              if (ke3 && !S4(Ae3, y3(n5, _e4, "")))
                ;
              else if (n5)
                return false;
            } else
              ;
            return true;
          }, vt = function(e4) {
            return "annotation-xml" !== e4 && T5(e4, Se3);
          }, Dt = function(e4) {
            wt(de4.beforeSanitizeAttributes, e4, null);
            const { attributes: t5 } = e4;
            if (!t5 || bt(e4))
              return;
            const n5 = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: Re3,
              forceKeepAttr: void 0
            };
            let r5 = t5.length;
            for (; r5--; ) {
              const i5 = t5[r5], { name: a6, namespaceURI: l5, value: c5 } = i5, s5 = pt2(a6), m4 = c5;
              let f5 = "value" === a6 ? m4 : A4(m4);
              if (n5.attrName = s5, n5.attrValue = f5, n5.keepAttr = true, n5.forceKeepAttr = void 0, wt(de4.uponSanitizeAttribute, e4, n5), f5 = n5.attrValue, !Ye2 || "id" !== s5 && "name" !== s5 || (At(a6, e4), f5 = "user-content-" + f5), Ue && S4(/((--!?|])>)|<\/(style|title|textarea)/i, f5)) {
                At(a6, e4);
                continue;
              }
              if ("attributename" === s5 && T5(f5, "href")) {
                At(a6, e4);
                continue;
              }
              if (n5.forceKeepAttr)
                continue;
              if (!n5.keepAttr) {
                At(a6, e4);
                continue;
              }
              if (!Ie3 && S4(/\/>/i, f5)) {
                At(a6, e4);
                continue;
              }
              Me3 && u4([he3, ge3, Te3], (e5) => {
                f5 = y3(f5, e5, " ");
              });
              const d4 = pt2(e4.nodeName);
              if (Ot(d4, s5, f5)) {
                if (le4 && "object" == typeof j4 && "function" == typeof j4.getAttributeType)
                  if (l5)
                    ;
                  else
                    switch (j4.getAttributeType(d4, s5)) {
                      case "TrustedHTML":
                        f5 = le4.createHTML(f5);
                        break;
                      case "TrustedScriptURL":
                        f5 = le4.createScriptURL(f5);
                    }
                if (f5 !== m4)
                  try {
                    l5 ? e4.setAttributeNS(l5, a6, f5) : e4.setAttribute(a6, f5), bt(e4) ? Et(e4) : p3(o5.removed);
                  } catch (t6) {
                    At(a6, e4);
                  }
              } else
                At(a6, e4);
            }
            wt(de4.afterSanitizeAttributes, e4, null);
          }, xt = function e4(t5) {
            let n5 = null;
            const o6 = St(t5);
            for (wt(de4.beforeSanitizeShadowDOM, t5, null); n5 = o6.nextNode(); )
              wt(de4.uponSanitizeShadowNode, n5, null), Rt(n5), Dt(n5), n5.content instanceof s4 && e4(n5.content);
            wt(de4.afterSanitizeShadowDOM, t5, null);
          };
          return o5.sanitize = function(e4) {
            let t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n5 = null, r5 = null, i5 = null, l5 = null;
            if (rt2 = !e4, rt2 && (e4 = "<!-->"), "string" != typeof e4 && !Nt(e4)) {
              if ("function" != typeof e4.toString)
                throw b3("toString is not a function");
              if ("string" != typeof (e4 = e4.toString()))
                throw b3("dirty is not a string, aborting");
            }
            if (!o5.isSupported)
              return e4;
            if (Pe || gt(t5), o5.removed = [], "string" == typeof e4 && (Xe2 = false), Xe2) {
              if (e4.nodeName) {
                const t6 = pt2(e4.nodeName);
                if (!Ne3[t6] || De3[t6])
                  throw b3(
                    "root node is forbidden and cannot be sanitized in-place"
                  );
              }
            } else if (e4 instanceof w4)
              n5 = _t("<!---->"), r5 = n5.ownerDocument.importNode(e4, true), r5.nodeType === J3 && "BODY" === r5.nodeName || "HTML" === r5.nodeName ? n5 = r5 : n5.appendChild(r5);
            else {
              if (!Fe2 && !Me3 && !ze2 && -1 === e4.indexOf("<"))
                return le4 && We2 ? le4.createHTML(e4) : e4;
              if (n5 = _t(e4), !n5)
                return Fe2 ? null : We2 ? ce3 : "";
            }
            n5 && He2 && Et(n5.firstChild);
            const c5 = St(Xe2 ? e4 : n5);
            for (; i5 = c5.nextNode(); )
              Rt(i5), Dt(i5), i5.content instanceof s4 && xt(i5.content);
            if (Xe2)
              return e4;
            if (Fe2) {
              if (Be3)
                for (l5 = me3.call(n5.ownerDocument); n5.firstChild; )
                  l5.appendChild(n5.firstChild);
              else
                l5 = n5;
              return (Re3.shadowroot || Re3.shadowrootmode) && (l5 = fe3.call(a5, l5, true)), l5;
            }
            let m4 = ze2 ? n5.outerHTML : n5.innerHTML;
            return ze2 && Ne3["!doctype"] && n5.ownerDocument && n5.ownerDocument.doctype && n5.ownerDocument.doctype.name && S4(K3, n5.ownerDocument.doctype.name) && (m4 = "<!DOCTYPE " + n5.ownerDocument.doctype.name + ">\n" + m4), Me3 && u4([he3, ge3, Te3], (e5) => {
              m4 = y3(m4, e5, " ");
            }), le4 && We2 ? le4.createHTML(m4) : m4;
          }, o5.setConfig = function() {
            gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Pe = true;
          }, o5.clearConfig = function() {
            ft2 = null, Pe = false;
          }, o5.isValidAttribute = function(e4, t5, n5) {
            ft2 || gt({});
            const o6 = pt2(e4), r5 = pt2(t5);
            return Ot(o6, r5, n5);
          }, o5.addHook = function(e4, t5) {
            "function" == typeof t5 && f4(de4[e4], t5);
          }, o5.removeHook = function(e4, t5) {
            if (void 0 !== t5) {
              const n5 = m3(de4[e4], t5);
              return -1 === n5 ? void 0 : d3(de4[e4], n5, 1)[0];
            }
            return p3(de4[e4]);
          }, o5.removeHooks = function(e4) {
            de4[e4] = [];
          }, o5.removeAllHooks = function() {
            de4 = {
              afterSanitizeAttributes: [],
              afterSanitizeElements: [],
              afterSanitizeShadowDOM: [],
              beforeSanitizeAttributes: [],
              beforeSanitizeElements: [],
              beforeSanitizeShadowDOM: [],
              uponSanitizeAttribute: [],
              uponSanitizeElement: [],
              uponSanitizeShadowNode: []
            };
          }, o5;
        }();
        return re4;
      });
    }
  });

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/markdown-it-incremental-dom/markdown-it-incremental-dom.js
  var require_markdown_it_incremental_dom = __commonJS({
    "../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/markdown-it-incremental-dom/markdown-it-incremental-dom.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else {
          var a4 = factory();
          for (var i4 in a4)
            (typeof exports === "object" ? exports : root)[i4] = a4[i4];
        }
      })(window, function() {
        return (
          /******/
          function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module2 = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
              };
              modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              module2.l = true;
              return module2.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports2, name, getter) {
              if (!__webpack_require__.o(exports2, name)) {
                Object.defineProperty(exports2, name, { enumerable: true, get: getter });
              }
            };
            __webpack_require__.r = function(exports2) {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
            __webpack_require__.t = function(value, mode) {
              if (mode & 1)
                value = __webpack_require__(value);
              if (mode & 8)
                return value;
              if (mode & 4 && typeof value === "object" && value && value.__esModule)
                return value;
              var ns = /* @__PURE__ */ Object.create(null);
              __webpack_require__.r(ns);
              Object.defineProperty(ns, "default", { enumerable: true, value });
              if (mode & 2 && typeof value != "string")
                for (var key in value)
                  __webpack_require__.d(ns, key, function(key2) {
                    return value[key2];
                  }.bind(null, key));
              return ns;
            };
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function getDefault() {
                  return module2["default"];
                }
              ) : (
                /******/
                function getModuleExports() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 63);
          }([
            /* 0 */
            /***/
            function(module2, exports2) {
              var global = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
              if (typeof __g == "number")
                __g = global;
            },
            /* 1 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var dP = __webpack_require__(10);
              var createDesc = __webpack_require__(24);
              module2.exports = __webpack_require__(5) ? function(object, key, value) {
                return dP.f(object, key, createDesc(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            },
            /* 2 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var store = __webpack_require__(21)("wks");
              var uid = __webpack_require__(9);
              var Symbol2 = __webpack_require__(0).Symbol;
              var USE_SYMBOL = typeof Symbol2 == "function";
              var $exports = module2.exports = function(name) {
                return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
              };
              $exports.store = store;
            },
            /* 3 */
            /***/
            function(module2, exports2) {
              module2.exports = function(exec) {
                try {
                  return !!exec();
                } catch (e3) {
                  return true;
                }
              };
            },
            /* 4 */
            /***/
            function(module2, exports2) {
              var core = module2.exports = { version: "2.5.7" };
              if (typeof __e == "number")
                __e = core;
            },
            /* 5 */
            /***/
            function(module2, exports2, __webpack_require__) {
              module2.exports = !__webpack_require__(3)(function() {
                return Object.defineProperty({}, "a", { get: function() {
                  return 7;
                } }).a != 7;
              });
            },
            /* 6 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var global = __webpack_require__(0);
              var hide = __webpack_require__(1);
              var has = __webpack_require__(7);
              var SRC = __webpack_require__(9)("src");
              var TO_STRING = "toString";
              var $toString = Function[TO_STRING];
              var TPL = ("" + $toString).split(TO_STRING);
              __webpack_require__(4).inspectSource = function(it2) {
                return $toString.call(it2);
              };
              (module2.exports = function(O4, key, val, safe) {
                var isFunction = typeof val == "function";
                if (isFunction)
                  has(val, "name") || hide(val, "name", key);
                if (O4[key] === val)
                  return;
                if (isFunction)
                  has(val, SRC) || hide(val, SRC, O4[key] ? "" + O4[key] : TPL.join(String(key)));
                if (O4 === global) {
                  O4[key] = val;
                } else if (!safe) {
                  delete O4[key];
                  hide(O4, key, val);
                } else if (O4[key]) {
                  O4[key] = val;
                } else {
                  hide(O4, key, val);
                }
              })(Function.prototype, TO_STRING, function toString() {
                return typeof this == "function" && this[SRC] || $toString.call(this);
              });
            },
            /* 7 */
            /***/
            function(module2, exports2) {
              var hasOwnProperty = {}.hasOwnProperty;
              module2.exports = function(it2, key) {
                return hasOwnProperty.call(it2, key);
              };
            },
            /* 8 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var $keys = __webpack_require__(41);
              var enumBugKeys = __webpack_require__(27);
              module2.exports = Object.keys || function keys(O4) {
                return $keys(O4, enumBugKeys);
              };
            },
            /* 9 */
            /***/
            function(module2, exports2) {
              var id = 0;
              var px = Math.random();
              module2.exports = function(key) {
                return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
              };
            },
            /* 10 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var anObject = __webpack_require__(11);
              var IE8_DOM_DEFINE = __webpack_require__(31);
              var toPrimitive = __webpack_require__(32);
              var dP = Object.defineProperty;
              exports2.f = __webpack_require__(5) ? Object.defineProperty : function defineProperty(O4, P3, Attributes) {
                anObject(O4);
                P3 = toPrimitive(P3, true);
                anObject(Attributes);
                if (IE8_DOM_DEFINE)
                  try {
                    return dP(O4, P3, Attributes);
                  } catch (e3) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw TypeError("Accessors not supported!");
                if ("value" in Attributes)
                  O4[P3] = Attributes.value;
                return O4;
              };
            },
            /* 11 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var isObject = __webpack_require__(12);
              module2.exports = function(it2) {
                if (!isObject(it2))
                  throw TypeError(it2 + " is not an object!");
                return it2;
              };
            },
            /* 12 */
            /***/
            function(module2, exports2) {
              module2.exports = function(it2) {
                return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
              };
            },
            /* 13 */
            /***/
            function(module2, exports2) {
              module2.exports = {};
            },
            /* 14 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var IObject = __webpack_require__(25);
              var defined = __webpack_require__(15);
              module2.exports = function(it2) {
                return IObject(defined(it2));
              };
            },
            /* 15 */
            /***/
            function(module2, exports2) {
              module2.exports = function(it2) {
                if (it2 == void 0)
                  throw TypeError("Can't call method on  " + it2);
                return it2;
              };
            },
            /* 16 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var global = __webpack_require__(0);
              var core = __webpack_require__(4);
              var hide = __webpack_require__(1);
              var redefine = __webpack_require__(6);
              var ctx = __webpack_require__(36);
              var PROTOTYPE = "prototype";
              var $export = function(type, name, source) {
                var IS_FORCED = type & $export.F;
                var IS_GLOBAL = type & $export.G;
                var IS_STATIC = type & $export.S;
                var IS_PROTO = type & $export.P;
                var IS_BIND = type & $export.B;
                var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
                var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
                var expProto = exports3[PROTOTYPE] || (exports3[PROTOTYPE] = {});
                var key, own, out, exp;
                if (IS_GLOBAL)
                  source = name;
                for (key in source) {
                  own = !IS_FORCED && target && target[key] !== void 0;
                  out = (own ? target : source)[key];
                  exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                  if (target)
                    redefine(target, key, out, type & $export.U);
                  if (exports3[key] != out)
                    hide(exports3, key, exp);
                  if (IS_PROTO && expProto[key] != out)
                    expProto[key] = out;
                }
              };
              global.core = core;
              $export.F = 1;
              $export.G = 2;
              $export.S = 4;
              $export.P = 8;
              $export.B = 16;
              $export.W = 32;
              $export.U = 64;
              $export.R = 128;
              module2.exports = $export;
            },
            /* 17 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var shared = __webpack_require__(21)("keys");
              var uid = __webpack_require__(9);
              module2.exports = function(key) {
                return shared[key] || (shared[key] = uid(key));
              };
            },
            /* 18 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var defined = __webpack_require__(15);
              module2.exports = function(it2) {
                return Object(defined(it2));
              };
            },
            /* 19 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var $iterators = __webpack_require__(20);
              var getKeys = __webpack_require__(8);
              var redefine = __webpack_require__(6);
              var global = __webpack_require__(0);
              var hide = __webpack_require__(1);
              var Iterators = __webpack_require__(13);
              var wks = __webpack_require__(2);
              var ITERATOR = wks("iterator");
              var TO_STRING_TAG = wks("toStringTag");
              var ArrayValues = Iterators.Array;
              var DOMIterables = {
                CSSRuleList: true,
                // TODO: Not spec compliant, should be false.
                CSSStyleDeclaration: false,
                CSSValueList: false,
                ClientRectList: false,
                DOMRectList: false,
                DOMStringList: false,
                DOMTokenList: true,
                DataTransferItemList: false,
                FileList: false,
                HTMLAllCollection: false,
                HTMLCollection: false,
                HTMLFormElement: false,
                HTMLSelectElement: false,
                MediaList: true,
                // TODO: Not spec compliant, should be false.
                MimeTypeArray: false,
                NamedNodeMap: false,
                NodeList: true,
                PaintRequestList: false,
                Plugin: false,
                PluginArray: false,
                SVGLengthList: false,
                SVGNumberList: false,
                SVGPathSegList: false,
                SVGPointList: false,
                SVGStringList: false,
                SVGTransformList: false,
                SourceBufferList: false,
                StyleSheetList: true,
                // TODO: Not spec compliant, should be false.
                TextTrackCueList: false,
                TextTrackList: false,
                TouchList: false
              };
              for (var collections = getKeys(DOMIterables), i4 = 0; i4 < collections.length; i4++) {
                var NAME = collections[i4];
                var explicit = DOMIterables[NAME];
                var Collection = global[NAME];
                var proto = Collection && Collection.prototype;
                var key;
                if (proto) {
                  if (!proto[ITERATOR])
                    hide(proto, ITERATOR, ArrayValues);
                  if (!proto[TO_STRING_TAG])
                    hide(proto, TO_STRING_TAG, NAME);
                  Iterators[NAME] = ArrayValues;
                  if (explicit) {
                    for (key in $iterators)
                      if (!proto[key])
                        redefine(proto, key, $iterators[key], true);
                  }
                }
              }
            },
            /* 20 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var addToUnscopables = __webpack_require__(30);
              var step = __webpack_require__(33);
              var Iterators = __webpack_require__(13);
              var toIObject = __webpack_require__(14);
              module2.exports = __webpack_require__(35)(Array, "Array", function(iterated, kind) {
                this._t = toIObject(iterated);
                this._i = 0;
                this._k = kind;
              }, function() {
                var O4 = this._t;
                var kind = this._k;
                var index = this._i++;
                if (!O4 || index >= O4.length) {
                  this._t = void 0;
                  return step(1);
                }
                if (kind == "keys")
                  return step(0, index);
                if (kind == "values")
                  return step(0, O4[index]);
                return step(0, [index, O4[index]]);
              }, "values");
              Iterators.Arguments = Iterators.Array;
              addToUnscopables("keys");
              addToUnscopables("values");
              addToUnscopables("entries");
            },
            /* 21 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var core = __webpack_require__(4);
              var global = __webpack_require__(0);
              var SHARED = "__core-js_shared__";
              var store = global[SHARED] || (global[SHARED] = {});
              (module2.exports = function(key, value) {
                return store[key] || (store[key] = value !== void 0 ? value : {});
              })("versions", []).push({
                version: core.version,
                mode: __webpack_require__(22) ? "pure" : "global",
                copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
              });
            },
            /* 22 */
            /***/
            function(module2, exports2) {
              module2.exports = false;
            },
            /* 23 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var isObject = __webpack_require__(12);
              var document2 = __webpack_require__(0).document;
              var is = isObject(document2) && isObject(document2.createElement);
              module2.exports = function(it2) {
                return is ? document2.createElement(it2) : {};
              };
            },
            /* 24 */
            /***/
            function(module2, exports2) {
              module2.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            },
            /* 25 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var cof = __webpack_require__(34);
              module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it2) {
                return cof(it2) == "String" ? it2.split("") : Object(it2);
              };
            },
            /* 26 */
            /***/
            function(module2, exports2) {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module2.exports = function(it2) {
                return isNaN(it2 = +it2) ? 0 : (it2 > 0 ? floor : ceil)(it2);
              };
            },
            /* 27 */
            /***/
            function(module2, exports2) {
              module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
            },
            /* 28 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var def = __webpack_require__(10).f;
              var has = __webpack_require__(7);
              var TAG = __webpack_require__(2)("toStringTag");
              module2.exports = function(it2, tag, stat) {
                if (it2 && !has(it2 = stat ? it2 : it2.prototype, TAG))
                  def(it2, TAG, { configurable: true, value: tag });
              };
            },
            /* 29 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var Tokenizer = __webpack_require__(55);
              var formTags = {
                input: true,
                option: true,
                optgroup: true,
                select: true,
                button: true,
                datalist: true,
                textarea: true
              };
              var openImpliesClose = {
                tr: { tr: true, th: true, td: true },
                th: { th: true },
                td: { thead: true, th: true, td: true },
                body: { head: true, link: true, script: true },
                li: { li: true },
                p: { p: true },
                h1: { p: true },
                h2: { p: true },
                h3: { p: true },
                h4: { p: true },
                h5: { p: true },
                h6: { p: true },
                select: formTags,
                input: formTags,
                output: formTags,
                button: formTags,
                datalist: formTags,
                textarea: formTags,
                option: { option: true },
                optgroup: { optgroup: true }
              };
              var voidElements = {
                __proto__: null,
                area: true,
                base: true,
                basefont: true,
                br: true,
                col: true,
                command: true,
                embed: true,
                frame: true,
                hr: true,
                img: true,
                input: true,
                isindex: true,
                keygen: true,
                link: true,
                meta: true,
                param: true,
                source: true,
                track: true,
                wbr: true
              };
              var foreignContextElements = {
                __proto__: null,
                math: true,
                svg: true
              };
              var htmlIntegrationElements = {
                __proto__: null,
                mi: true,
                mo: true,
                mn: true,
                ms: true,
                mtext: true,
                "annotation-xml": true,
                foreignObject: true,
                desc: true,
                title: true
              };
              var re_nameEnd = /\s|\//;
              function Parser2(cbs, options) {
                this._options = options || {};
                this._cbs = cbs || {};
                this._tagname = "";
                this._attribname = "";
                this._attribvalue = "";
                this._attribs = null;
                this._stack = [];
                this._foreignContext = [];
                this.startIndex = 0;
                this.endIndex = null;
                this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
                this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
                if (this._options.Tokenizer) {
                  Tokenizer = this._options.Tokenizer;
                }
                this._tokenizer = new Tokenizer(this._options, this);
                if (this._cbs.onparserinit)
                  this._cbs.onparserinit(this);
              }
              __webpack_require__(61)(Parser2, __webpack_require__(62).EventEmitter);
              Parser2.prototype._updatePosition = function(initialOffset) {
                if (this.endIndex === null) {
                  if (this._tokenizer._sectionStart <= initialOffset) {
                    this.startIndex = 0;
                  } else {
                    this.startIndex = this._tokenizer._sectionStart - initialOffset;
                  }
                } else
                  this.startIndex = this.endIndex + 1;
                this.endIndex = this._tokenizer.getAbsoluteIndex();
              };
              Parser2.prototype.ontext = function(data) {
                this._updatePosition(1);
                this.endIndex--;
                if (this._cbs.ontext)
                  this._cbs.ontext(data);
              };
              Parser2.prototype.onopentagname = function(name) {
                if (this._lowerCaseTagNames) {
                  name = name.toLowerCase();
                }
                this._tagname = name;
                if (!this._options.xmlMode && name in openImpliesClose) {
                  for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el))
                    ;
                }
                if (this._options.xmlMode || !(name in voidElements)) {
                  this._stack.push(name);
                  if (name in foreignContextElements)
                    this._foreignContext.push(true);
                  else if (name in htmlIntegrationElements)
                    this._foreignContext.push(false);
                }
                if (this._cbs.onopentagname)
                  this._cbs.onopentagname(name);
                if (this._cbs.onopentag)
                  this._attribs = {};
              };
              Parser2.prototype.onopentagend = function() {
                this._updatePosition(1);
                if (this._attribs) {
                  if (this._cbs.onopentag)
                    this._cbs.onopentag(this._tagname, this._attribs);
                  this._attribs = null;
                }
                if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
                  this._cbs.onclosetag(this._tagname);
                }
                this._tagname = "";
              };
              Parser2.prototype.onclosetag = function(name) {
                this._updatePosition(1);
                if (this._lowerCaseTagNames) {
                  name = name.toLowerCase();
                }
                if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
                  var pos = this._stack.lastIndexOf(name);
                  if (pos !== -1) {
                    if (this._cbs.onclosetag) {
                      pos = this._stack.length - pos;
                      while (pos--)
                        this._cbs.onclosetag(this._stack.pop());
                    } else
                      this._stack.length = pos;
                  } else if (name === "p" && !this._options.xmlMode) {
                    this.onopentagname(name);
                    this._closeCurrentTag();
                  }
                } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
                  this.onopentagname(name);
                  this._closeCurrentTag();
                }
              };
              Parser2.prototype.onselfclosingtag = function() {
                if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
                  this._closeCurrentTag();
                } else {
                  this.onopentagend();
                }
              };
              Parser2.prototype._closeCurrentTag = function() {
                var name = this._tagname;
                this.onopentagend();
                if (this._stack[this._stack.length - 1] === name) {
                  if (this._cbs.onclosetag) {
                    this._cbs.onclosetag(name);
                  }
                  this._stack.pop();
                  if (name in foreignContextElements || name in htmlIntegrationElements) {
                    this._foreignContext.pop();
                  }
                }
              };
              Parser2.prototype.onattribname = function(name) {
                if (this._lowerCaseAttributeNames) {
                  name = name.toLowerCase();
                }
                this._attribname = name;
              };
              Parser2.prototype.onattribdata = function(value) {
                this._attribvalue += value;
              };
              Parser2.prototype.onattribend = function() {
                if (this._cbs.onattribute)
                  this._cbs.onattribute(this._attribname, this._attribvalue);
                if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
                  this._attribs[this._attribname] = this._attribvalue;
                }
                this._attribname = "";
                this._attribvalue = "";
              };
              Parser2.prototype._getInstructionName = function(value) {
                var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
                if (this._lowerCaseTagNames) {
                  name = name.toLowerCase();
                }
                return name;
              };
              Parser2.prototype.ondeclaration = function(value) {
                if (this._cbs.onprocessinginstruction) {
                  var name = this._getInstructionName(value);
                  this._cbs.onprocessinginstruction("!" + name, "!" + value);
                }
              };
              Parser2.prototype.onprocessinginstruction = function(value) {
                if (this._cbs.onprocessinginstruction) {
                  var name = this._getInstructionName(value);
                  this._cbs.onprocessinginstruction("?" + name, "?" + value);
                }
              };
              Parser2.prototype.oncomment = function(value) {
                this._updatePosition(4);
                if (this._cbs.oncomment)
                  this._cbs.oncomment(value);
                if (this._cbs.oncommentend)
                  this._cbs.oncommentend();
              };
              Parser2.prototype.oncdata = function(value) {
                this._updatePosition(1);
                if (this._options.xmlMode || this._options.recognizeCDATA) {
                  if (this._cbs.oncdatastart)
                    this._cbs.oncdatastart();
                  if (this._cbs.ontext)
                    this._cbs.ontext(value);
                  if (this._cbs.oncdataend)
                    this._cbs.oncdataend();
                } else {
                  this.oncomment("[CDATA[" + value + "]]");
                }
              };
              Parser2.prototype.onerror = function(err) {
                if (this._cbs.onerror)
                  this._cbs.onerror(err);
              };
              Parser2.prototype.onend = function() {
                if (this._cbs.onclosetag) {
                  for (var i4 = this._stack.length; i4 > 0; this._cbs.onclosetag(this._stack[--i4]))
                    ;
                }
                if (this._cbs.onend)
                  this._cbs.onend();
              };
              Parser2.prototype.reset = function() {
                if (this._cbs.onreset)
                  this._cbs.onreset();
                this._tokenizer.reset();
                this._tagname = "";
                this._attribname = "";
                this._attribs = null;
                this._stack = [];
                if (this._cbs.onparserinit)
                  this._cbs.onparserinit(this);
              };
              Parser2.prototype.parseComplete = function(data) {
                this.reset();
                this.end(data);
              };
              Parser2.prototype.write = function(chunk) {
                this._tokenizer.write(chunk);
              };
              Parser2.prototype.end = function(chunk) {
                this._tokenizer.end(chunk);
              };
              Parser2.prototype.pause = function() {
                this._tokenizer.pause();
              };
              Parser2.prototype.resume = function() {
                this._tokenizer.resume();
              };
              Parser2.prototype.parseChunk = Parser2.prototype.write;
              Parser2.prototype.done = Parser2.prototype.end;
              module2.exports = Parser2;
            },
            /* 30 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var UNSCOPABLES = __webpack_require__(2)("unscopables");
              var ArrayProto = Array.prototype;
              if (ArrayProto[UNSCOPABLES] == void 0)
                __webpack_require__(1)(ArrayProto, UNSCOPABLES, {});
              module2.exports = function(key) {
                ArrayProto[UNSCOPABLES][key] = true;
              };
            },
            /* 31 */
            /***/
            function(module2, exports2, __webpack_require__) {
              module2.exports = !__webpack_require__(5) && !__webpack_require__(3)(function() {
                return Object.defineProperty(__webpack_require__(23)("div"), "a", { get: function() {
                  return 7;
                } }).a != 7;
              });
            },
            /* 32 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var isObject = __webpack_require__(12);
              module2.exports = function(it2, S4) {
                if (!isObject(it2))
                  return it2;
                var fn, val;
                if (S4 && typeof (fn = it2.toString) == "function" && !isObject(val = fn.call(it2)))
                  return val;
                if (typeof (fn = it2.valueOf) == "function" && !isObject(val = fn.call(it2)))
                  return val;
                if (!S4 && typeof (fn = it2.toString) == "function" && !isObject(val = fn.call(it2)))
                  return val;
                throw TypeError("Can't convert object to primitive value");
              };
            },
            /* 33 */
            /***/
            function(module2, exports2) {
              module2.exports = function(done, value) {
                return { value, done: !!done };
              };
            },
            /* 34 */
            /***/
            function(module2, exports2) {
              var toString = {}.toString;
              module2.exports = function(it2) {
                return toString.call(it2).slice(8, -1);
              };
            },
            /* 35 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var LIBRARY = __webpack_require__(22);
              var $export = __webpack_require__(16);
              var redefine = __webpack_require__(6);
              var hide = __webpack_require__(1);
              var Iterators = __webpack_require__(13);
              var $iterCreate = __webpack_require__(38);
              var setToStringTag = __webpack_require__(28);
              var getPrototypeOf = __webpack_require__(46);
              var ITERATOR = __webpack_require__(2)("iterator");
              var BUGGY = !([].keys && "next" in [].keys());
              var FF_ITERATOR = "@@iterator";
              var KEYS = "keys";
              var VALUES = "values";
              var returnThis = function() {
                return this;
              };
              module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
                $iterCreate(Constructor, NAME, next);
                var getMethod = function(kind) {
                  if (!BUGGY && kind in proto)
                    return proto[kind];
                  switch (kind) {
                    case KEYS:
                      return function keys() {
                        return new Constructor(this, kind);
                      };
                    case VALUES:
                      return function values() {
                        return new Constructor(this, kind);
                      };
                  }
                  return function entries() {
                    return new Constructor(this, kind);
                  };
                };
                var TAG = NAME + " Iterator";
                var DEF_VALUES = DEFAULT == VALUES;
                var VALUES_BUG = false;
                var proto = Base.prototype;
                var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
                var $default = $native || getMethod(DEFAULT);
                var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
                var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
                var methods, key, IteratorPrototype;
                if ($anyNative) {
                  IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                  if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                    setToStringTag(IteratorPrototype, TAG, true);
                    if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                      hide(IteratorPrototype, ITERATOR, returnThis);
                  }
                }
                if (DEF_VALUES && $native && $native.name !== VALUES) {
                  VALUES_BUG = true;
                  $default = function values() {
                    return $native.call(this);
                  };
                }
                if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                  hide(proto, ITERATOR, $default);
                }
                Iterators[NAME] = $default;
                Iterators[TAG] = returnThis;
                if (DEFAULT) {
                  methods = {
                    values: DEF_VALUES ? $default : getMethod(VALUES),
                    keys: IS_SET ? $default : getMethod(KEYS),
                    entries: $entries
                  };
                  if (FORCED)
                    for (key in methods) {
                      if (!(key in proto))
                        redefine(proto, key, methods[key]);
                    }
                  else
                    $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
                }
                return methods;
              };
            },
            /* 36 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var aFunction = __webpack_require__(37);
              module2.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === void 0)
                  return fn;
                switch (length) {
                  case 1:
                    return function(a4) {
                      return fn.call(that, a4);
                    };
                  case 2:
                    return function(a4, b3) {
                      return fn.call(that, a4, b3);
                    };
                  case 3:
                    return function(a4, b3, c3) {
                      return fn.call(that, a4, b3, c3);
                    };
                }
                return function() {
                  return fn.apply(that, arguments);
                };
              };
            },
            /* 37 */
            /***/
            function(module2, exports2) {
              module2.exports = function(it2) {
                if (typeof it2 != "function")
                  throw TypeError(it2 + " is not a function!");
                return it2;
              };
            },
            /* 38 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var create = __webpack_require__(39);
              var descriptor = __webpack_require__(24);
              var setToStringTag = __webpack_require__(28);
              var IteratorPrototype = {};
              __webpack_require__(1)(IteratorPrototype, __webpack_require__(2)("iterator"), function() {
                return this;
              });
              module2.exports = function(Constructor, NAME, next) {
                Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
                setToStringTag(Constructor, NAME + " Iterator");
              };
            },
            /* 39 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var anObject = __webpack_require__(11);
              var dPs = __webpack_require__(40);
              var enumBugKeys = __webpack_require__(27);
              var IE_PROTO = __webpack_require__(17)("IE_PROTO");
              var Empty = function() {
              };
              var PROTOTYPE = "prototype";
              var createDict = function() {
                var iframe = __webpack_require__(23)("iframe");
                var i4 = enumBugKeys.length;
                var lt2 = "<";
                var gt = ">";
                var iframeDocument;
                iframe.style.display = "none";
                __webpack_require__(45).appendChild(iframe);
                iframe.src = "javascript:";
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(lt2 + "script" + gt + "document.F=Object" + lt2 + "/script" + gt);
                iframeDocument.close();
                createDict = iframeDocument.F;
                while (i4--)
                  delete createDict[PROTOTYPE][enumBugKeys[i4]];
                return createDict();
              };
              module2.exports = Object.create || function create(O4, Properties) {
                var result;
                if (O4 !== null) {
                  Empty[PROTOTYPE] = anObject(O4);
                  result = new Empty();
                  Empty[PROTOTYPE] = null;
                  result[IE_PROTO] = O4;
                } else
                  result = createDict();
                return Properties === void 0 ? result : dPs(result, Properties);
              };
            },
            /* 40 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var dP = __webpack_require__(10);
              var anObject = __webpack_require__(11);
              var getKeys = __webpack_require__(8);
              module2.exports = __webpack_require__(5) ? Object.defineProperties : function defineProperties(O4, Properties) {
                anObject(O4);
                var keys = getKeys(Properties);
                var length = keys.length;
                var i4 = 0;
                var P3;
                while (length > i4)
                  dP.f(O4, P3 = keys[i4++], Properties[P3]);
                return O4;
              };
            },
            /* 41 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var has = __webpack_require__(7);
              var toIObject = __webpack_require__(14);
              var arrayIndexOf = __webpack_require__(42)(false);
              var IE_PROTO = __webpack_require__(17)("IE_PROTO");
              module2.exports = function(object, names) {
                var O4 = toIObject(object);
                var i4 = 0;
                var result = [];
                var key;
                for (key in O4)
                  if (key != IE_PROTO)
                    has(O4, key) && result.push(key);
                while (names.length > i4)
                  if (has(O4, key = names[i4++])) {
                    ~arrayIndexOf(result, key) || result.push(key);
                  }
                return result;
              };
            },
            /* 42 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var toIObject = __webpack_require__(14);
              var toLength = __webpack_require__(43);
              var toAbsoluteIndex = __webpack_require__(44);
              module2.exports = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O4 = toIObject($this);
                  var length = toLength(O4.length);
                  var index = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O4[index++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index; index++)
                      if (IS_INCLUDES || index in O4) {
                        if (O4[index] === el)
                          return IS_INCLUDES || index || 0;
                      }
                  return !IS_INCLUDES && -1;
                };
              };
            },
            /* 43 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var toInteger = __webpack_require__(26);
              var min = Math.min;
              module2.exports = function(it2) {
                return it2 > 0 ? min(toInteger(it2), 9007199254740991) : 0;
              };
            },
            /* 44 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var toInteger = __webpack_require__(26);
              var max = Math.max;
              var min = Math.min;
              module2.exports = function(index, length) {
                index = toInteger(index);
                return index < 0 ? max(index + length, 0) : min(index, length);
              };
            },
            /* 45 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var document2 = __webpack_require__(0).document;
              module2.exports = document2 && document2.documentElement;
            },
            /* 46 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var has = __webpack_require__(7);
              var toObject = __webpack_require__(18);
              var IE_PROTO = __webpack_require__(17)("IE_PROTO");
              var ObjectProto = Object.prototype;
              module2.exports = Object.getPrototypeOf || function(O4) {
                O4 = toObject(O4);
                if (has(O4, IE_PROTO))
                  return O4[IE_PROTO];
                if (typeof O4.constructor == "function" && O4 instanceof O4.constructor) {
                  return O4.constructor.prototype;
                }
                return O4 instanceof Object ? ObjectProto : null;
              };
            },
            /* 47 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var toObject = __webpack_require__(18);
              var $keys = __webpack_require__(8);
              __webpack_require__(48)("keys", function() {
                return function keys(it2) {
                  return $keys(toObject(it2));
                };
              });
            },
            /* 48 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var $export = __webpack_require__(16);
              var core = __webpack_require__(4);
              var fails = __webpack_require__(3);
              module2.exports = function(KEY, exec) {
                var fn = (core.Object || {})[KEY] || Object[KEY];
                var exp = {};
                exp[KEY] = exec(fn);
                $export($export.S + $export.F * fails(function() {
                  fn(1);
                }), "Object", exp);
              };
            },
            /* 49 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var $export = __webpack_require__(16);
              $export($export.S + $export.F, "Object", { assign: __webpack_require__(50) });
            },
            /* 50 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var getKeys = __webpack_require__(8);
              var gOPS = __webpack_require__(51);
              var pIE = __webpack_require__(52);
              var toObject = __webpack_require__(18);
              var IObject = __webpack_require__(25);
              var $assign = Object.assign;
              module2.exports = !$assign || __webpack_require__(3)(function() {
                var A4 = {};
                var B3 = {};
                var S4 = Symbol();
                var K3 = "abcdefghijklmnopqrst";
                A4[S4] = 7;
                K3.split("").forEach(function(k4) {
                  B3[k4] = k4;
                });
                return $assign({}, A4)[S4] != 7 || Object.keys($assign({}, B3)).join("") != K3;
              }) ? function assign(target, source) {
                var T5 = toObject(target);
                var aLen = arguments.length;
                var index = 1;
                var getSymbols = gOPS.f;
                var isEnum = pIE.f;
                while (aLen > index) {
                  var S4 = IObject(arguments[index++]);
                  var keys = getSymbols ? getKeys(S4).concat(getSymbols(S4)) : getKeys(S4);
                  var length = keys.length;
                  var j3 = 0;
                  var key;
                  while (length > j3)
                    if (isEnum.call(S4, key = keys[j3++]))
                      T5[key] = S4[key];
                }
                return T5;
              } : $assign;
            },
            /* 51 */
            /***/
            function(module2, exports2) {
              exports2.f = Object.getOwnPropertySymbols;
            },
            /* 52 */
            /***/
            function(module2, exports2) {
              exports2.f = {}.propertyIsEnumerable;
            },
            /* 53 */
            /***/
            function(module2, exports2, __webpack_require__) {
              __webpack_require__(54)("replace", 2, function(defined, REPLACE, $replace) {
                return [function replace(searchValue, replaceValue) {
                  "use strict";
                  var O4 = defined(this);
                  var fn = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                  return fn !== void 0 ? fn.call(searchValue, O4, replaceValue) : $replace.call(String(O4), searchValue, replaceValue);
                }, $replace];
              });
            },
            /* 54 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var hide = __webpack_require__(1);
              var redefine = __webpack_require__(6);
              var fails = __webpack_require__(3);
              var defined = __webpack_require__(15);
              var wks = __webpack_require__(2);
              module2.exports = function(KEY, length, exec) {
                var SYMBOL = wks(KEY);
                var fns = exec(defined, SYMBOL, ""[KEY]);
                var strfn = fns[0];
                var rxfn = fns[1];
                if (fails(function() {
                  var O4 = {};
                  O4[SYMBOL] = function() {
                    return 7;
                  };
                  return ""[KEY](O4) != 7;
                })) {
                  redefine(String.prototype, KEY, strfn);
                  hide(
                    RegExp.prototype,
                    SYMBOL,
                    length == 2 ? function(string, arg) {
                      return rxfn.call(string, this, arg);
                    } : function(string) {
                      return rxfn.call(string, this);
                    }
                  );
                }
              };
            },
            /* 55 */
            /***/
            function(module2, exports2, __webpack_require__) {
              module2.exports = Tokenizer;
              var decodeCodePoint = __webpack_require__(56);
              var entityMap = __webpack_require__(58);
              var legacyMap = __webpack_require__(59);
              var xmlMap = __webpack_require__(60);
              var i4 = 0;
              var TEXT = i4++;
              var BEFORE_TAG_NAME = i4++;
              var IN_TAG_NAME = i4++;
              var IN_SELF_CLOSING_TAG = i4++;
              var BEFORE_CLOSING_TAG_NAME = i4++;
              var IN_CLOSING_TAG_NAME = i4++;
              var AFTER_CLOSING_TAG_NAME = i4++;
              var BEFORE_ATTRIBUTE_NAME = i4++;
              var IN_ATTRIBUTE_NAME = i4++;
              var AFTER_ATTRIBUTE_NAME = i4++;
              var BEFORE_ATTRIBUTE_VALUE = i4++;
              var IN_ATTRIBUTE_VALUE_DQ = i4++;
              var IN_ATTRIBUTE_VALUE_SQ = i4++;
              var IN_ATTRIBUTE_VALUE_NQ = i4++;
              var BEFORE_DECLARATION = i4++;
              var IN_DECLARATION = i4++;
              var IN_PROCESSING_INSTRUCTION = i4++;
              var BEFORE_COMMENT = i4++;
              var IN_COMMENT = i4++;
              var AFTER_COMMENT_1 = i4++;
              var AFTER_COMMENT_2 = i4++;
              var BEFORE_CDATA_1 = i4++;
              var BEFORE_CDATA_2 = i4++;
              var BEFORE_CDATA_3 = i4++;
              var BEFORE_CDATA_4 = i4++;
              var BEFORE_CDATA_5 = i4++;
              var BEFORE_CDATA_6 = i4++;
              var IN_CDATA = i4++;
              var AFTER_CDATA_1 = i4++;
              var AFTER_CDATA_2 = i4++;
              var BEFORE_SPECIAL = i4++;
              var BEFORE_SPECIAL_END = i4++;
              var BEFORE_SCRIPT_1 = i4++;
              var BEFORE_SCRIPT_2 = i4++;
              var BEFORE_SCRIPT_3 = i4++;
              var BEFORE_SCRIPT_4 = i4++;
              var BEFORE_SCRIPT_5 = i4++;
              var AFTER_SCRIPT_1 = i4++;
              var AFTER_SCRIPT_2 = i4++;
              var AFTER_SCRIPT_3 = i4++;
              var AFTER_SCRIPT_4 = i4++;
              var AFTER_SCRIPT_5 = i4++;
              var BEFORE_STYLE_1 = i4++;
              var BEFORE_STYLE_2 = i4++;
              var BEFORE_STYLE_3 = i4++;
              var BEFORE_STYLE_4 = i4++;
              var AFTER_STYLE_1 = i4++;
              var AFTER_STYLE_2 = i4++;
              var AFTER_STYLE_3 = i4++;
              var AFTER_STYLE_4 = i4++;
              var BEFORE_ENTITY = i4++;
              var BEFORE_NUMERIC_ENTITY = i4++;
              var IN_NAMED_ENTITY = i4++;
              var IN_NUMERIC_ENTITY = i4++;
              var IN_HEX_ENTITY = i4++;
              var j3 = 0;
              var SPECIAL_NONE = j3++;
              var SPECIAL_SCRIPT = j3++;
              var SPECIAL_STYLE = j3++;
              function whitespace(c3) {
                return c3 === " " || c3 === "\n" || c3 === "	" || c3 === "\f" || c3 === "\r";
              }
              function ifElseState(upper, SUCCESS, FAILURE) {
                var lower = upper.toLowerCase();
                if (upper === lower) {
                  return function(c3) {
                    if (c3 === lower) {
                      this._state = SUCCESS;
                    } else {
                      this._state = FAILURE;
                      this._index--;
                    }
                  };
                } else {
                  return function(c3) {
                    if (c3 === lower || c3 === upper) {
                      this._state = SUCCESS;
                    } else {
                      this._state = FAILURE;
                      this._index--;
                    }
                  };
                }
              }
              function consumeSpecialNameChar(upper, NEXT_STATE) {
                var lower = upper.toLowerCase();
                return function(c3) {
                  if (c3 === lower || c3 === upper) {
                    this._state = NEXT_STATE;
                  } else {
                    this._state = IN_TAG_NAME;
                    this._index--;
                  }
                };
              }
              function Tokenizer(options, cbs) {
                this._state = TEXT;
                this._buffer = "";
                this._sectionStart = 0;
                this._index = 0;
                this._bufferOffset = 0;
                this._baseState = TEXT;
                this._special = SPECIAL_NONE;
                this._cbs = cbs;
                this._running = true;
                this._ended = false;
                this._xmlMode = !!(options && options.xmlMode);
                this._decodeEntities = !!(options && options.decodeEntities);
              }
              Tokenizer.prototype._stateText = function(c3) {
                if (c3 === "<") {
                  if (this._index > this._sectionStart) {
                    this._cbs.ontext(this._getSection());
                  }
                  this._state = BEFORE_TAG_NAME;
                  this._sectionStart = this._index;
                } else if (this._decodeEntities && this._special === SPECIAL_NONE && c3 === "&") {
                  if (this._index > this._sectionStart) {
                    this._cbs.ontext(this._getSection());
                  }
                  this._baseState = TEXT;
                  this._state = BEFORE_ENTITY;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateBeforeTagName = function(c3) {
                if (c3 === "/") {
                  this._state = BEFORE_CLOSING_TAG_NAME;
                } else if (c3 === "<") {
                  this._cbs.ontext(this._getSection());
                  this._sectionStart = this._index;
                } else if (c3 === ">" || this._special !== SPECIAL_NONE || whitespace(c3)) {
                  this._state = TEXT;
                } else if (c3 === "!") {
                  this._state = BEFORE_DECLARATION;
                  this._sectionStart = this._index + 1;
                } else if (c3 === "?") {
                  this._state = IN_PROCESSING_INSTRUCTION;
                  this._sectionStart = this._index + 1;
                } else {
                  this._state = !this._xmlMode && (c3 === "s" || c3 === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateInTagName = function(c3) {
                if (c3 === "/" || c3 === ">" || whitespace(c3)) {
                  this._emitToken("onopentagname");
                  this._state = BEFORE_ATTRIBUTE_NAME;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateBeforeCloseingTagName = function(c3) {
                if (whitespace(c3))
                  ;
                else if (c3 === ">") {
                  this._state = TEXT;
                } else if (this._special !== SPECIAL_NONE) {
                  if (c3 === "s" || c3 === "S") {
                    this._state = BEFORE_SPECIAL_END;
                  } else {
                    this._state = TEXT;
                    this._index--;
                  }
                } else {
                  this._state = IN_CLOSING_TAG_NAME;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateInCloseingTagName = function(c3) {
                if (c3 === ">" || whitespace(c3)) {
                  this._emitToken("onclosetag");
                  this._state = AFTER_CLOSING_TAG_NAME;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateAfterCloseingTagName = function(c3) {
                if (c3 === ">") {
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                }
              };
              Tokenizer.prototype._stateBeforeAttributeName = function(c3) {
                if (c3 === ">") {
                  this._cbs.onopentagend();
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                } else if (c3 === "/") {
                  this._state = IN_SELF_CLOSING_TAG;
                } else if (!whitespace(c3)) {
                  this._state = IN_ATTRIBUTE_NAME;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateInSelfClosingTag = function(c3) {
                if (c3 === ">") {
                  this._cbs.onselfclosingtag();
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                } else if (!whitespace(c3)) {
                  this._state = BEFORE_ATTRIBUTE_NAME;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateInAttributeName = function(c3) {
                if (c3 === "=" || c3 === "/" || c3 === ">" || whitespace(c3)) {
                  this._cbs.onattribname(this._getSection());
                  this._sectionStart = -1;
                  this._state = AFTER_ATTRIBUTE_NAME;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateAfterAttributeName = function(c3) {
                if (c3 === "=") {
                  this._state = BEFORE_ATTRIBUTE_VALUE;
                } else if (c3 === "/" || c3 === ">") {
                  this._cbs.onattribend();
                  this._state = BEFORE_ATTRIBUTE_NAME;
                  this._index--;
                } else if (!whitespace(c3)) {
                  this._cbs.onattribend();
                  this._state = IN_ATTRIBUTE_NAME;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateBeforeAttributeValue = function(c3) {
                if (c3 === '"') {
                  this._state = IN_ATTRIBUTE_VALUE_DQ;
                  this._sectionStart = this._index + 1;
                } else if (c3 === "'") {
                  this._state = IN_ATTRIBUTE_VALUE_SQ;
                  this._sectionStart = this._index + 1;
                } else if (!whitespace(c3)) {
                  this._state = IN_ATTRIBUTE_VALUE_NQ;
                  this._sectionStart = this._index;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c3) {
                if (c3 === '"') {
                  this._emitToken("onattribdata");
                  this._cbs.onattribend();
                  this._state = BEFORE_ATTRIBUTE_NAME;
                } else if (this._decodeEntities && c3 === "&") {
                  this._emitToken("onattribdata");
                  this._baseState = this._state;
                  this._state = BEFORE_ENTITY;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c3) {
                if (c3 === "'") {
                  this._emitToken("onattribdata");
                  this._cbs.onattribend();
                  this._state = BEFORE_ATTRIBUTE_NAME;
                } else if (this._decodeEntities && c3 === "&") {
                  this._emitToken("onattribdata");
                  this._baseState = this._state;
                  this._state = BEFORE_ENTITY;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c3) {
                if (whitespace(c3) || c3 === ">") {
                  this._emitToken("onattribdata");
                  this._cbs.onattribend();
                  this._state = BEFORE_ATTRIBUTE_NAME;
                  this._index--;
                } else if (this._decodeEntities && c3 === "&") {
                  this._emitToken("onattribdata");
                  this._baseState = this._state;
                  this._state = BEFORE_ENTITY;
                  this._sectionStart = this._index;
                }
              };
              Tokenizer.prototype._stateBeforeDeclaration = function(c3) {
                this._state = c3 === "[" ? BEFORE_CDATA_1 : c3 === "-" ? BEFORE_COMMENT : IN_DECLARATION;
              };
              Tokenizer.prototype._stateInDeclaration = function(c3) {
                if (c3 === ">") {
                  this._cbs.ondeclaration(this._getSection());
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                }
              };
              Tokenizer.prototype._stateInProcessingInstruction = function(c3) {
                if (c3 === ">") {
                  this._cbs.onprocessinginstruction(this._getSection());
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                }
              };
              Tokenizer.prototype._stateBeforeComment = function(c3) {
                if (c3 === "-") {
                  this._state = IN_COMMENT;
                  this._sectionStart = this._index + 1;
                } else {
                  this._state = IN_DECLARATION;
                }
              };
              Tokenizer.prototype._stateInComment = function(c3) {
                if (c3 === "-")
                  this._state = AFTER_COMMENT_1;
              };
              Tokenizer.prototype._stateAfterComment1 = function(c3) {
                if (c3 === "-") {
                  this._state = AFTER_COMMENT_2;
                } else {
                  this._state = IN_COMMENT;
                }
              };
              Tokenizer.prototype._stateAfterComment2 = function(c3) {
                if (c3 === ">") {
                  this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                } else if (c3 !== "-") {
                  this._state = IN_COMMENT;
                }
              };
              Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
              Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
              Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
              Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
              Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
              Tokenizer.prototype._stateBeforeCdata6 = function(c3) {
                if (c3 === "[") {
                  this._state = IN_CDATA;
                  this._sectionStart = this._index + 1;
                } else {
                  this._state = IN_DECLARATION;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateInCdata = function(c3) {
                if (c3 === "]")
                  this._state = AFTER_CDATA_1;
              };
              Tokenizer.prototype._stateAfterCdata1 = function(c3) {
                if (c3 === "]")
                  this._state = AFTER_CDATA_2;
                else
                  this._state = IN_CDATA;
              };
              Tokenizer.prototype._stateAfterCdata2 = function(c3) {
                if (c3 === ">") {
                  this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
                  this._state = TEXT;
                  this._sectionStart = this._index + 1;
                } else if (c3 !== "]") {
                  this._state = IN_CDATA;
                }
              };
              Tokenizer.prototype._stateBeforeSpecial = function(c3) {
                if (c3 === "c" || c3 === "C") {
                  this._state = BEFORE_SCRIPT_1;
                } else if (c3 === "t" || c3 === "T") {
                  this._state = BEFORE_STYLE_1;
                } else {
                  this._state = IN_TAG_NAME;
                  this._index--;
                }
              };
              Tokenizer.prototype._stateBeforeSpecialEnd = function(c3) {
                if (this._special === SPECIAL_SCRIPT && (c3 === "c" || c3 === "C")) {
                  this._state = AFTER_SCRIPT_1;
                } else if (this._special === SPECIAL_STYLE && (c3 === "t" || c3 === "T")) {
                  this._state = AFTER_STYLE_1;
                } else
                  this._state = TEXT;
              };
              Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
              Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
              Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
              Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
              Tokenizer.prototype._stateBeforeScript5 = function(c3) {
                if (c3 === "/" || c3 === ">" || whitespace(c3)) {
                  this._special = SPECIAL_SCRIPT;
                }
                this._state = IN_TAG_NAME;
                this._index--;
              };
              Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
              Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
              Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
              Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
              Tokenizer.prototype._stateAfterScript5 = function(c3) {
                if (c3 === ">" || whitespace(c3)) {
                  this._special = SPECIAL_NONE;
                  this._state = IN_CLOSING_TAG_NAME;
                  this._sectionStart = this._index - 6;
                  this._index--;
                } else
                  this._state = TEXT;
              };
              Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
              Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
              Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
              Tokenizer.prototype._stateBeforeStyle4 = function(c3) {
                if (c3 === "/" || c3 === ">" || whitespace(c3)) {
                  this._special = SPECIAL_STYLE;
                }
                this._state = IN_TAG_NAME;
                this._index--;
              };
              Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
              Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
              Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
              Tokenizer.prototype._stateAfterStyle4 = function(c3) {
                if (c3 === ">" || whitespace(c3)) {
                  this._special = SPECIAL_NONE;
                  this._state = IN_CLOSING_TAG_NAME;
                  this._sectionStart = this._index - 5;
                  this._index--;
                } else
                  this._state = TEXT;
              };
              Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
              Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
              Tokenizer.prototype._parseNamedEntityStrict = function() {
                if (this._sectionStart + 1 < this._index) {
                  var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
                  if (map.hasOwnProperty(entity)) {
                    this._emitPartial(map[entity]);
                    this._sectionStart = this._index + 1;
                  }
                }
              };
              Tokenizer.prototype._parseLegacyEntity = function() {
                var start = this._sectionStart + 1, limit = this._index - start;
                if (limit > 6)
                  limit = 6;
                while (limit >= 2) {
                  var entity = this._buffer.substr(start, limit);
                  if (legacyMap.hasOwnProperty(entity)) {
                    this._emitPartial(legacyMap[entity]);
                    this._sectionStart += limit + 1;
                    return;
                  } else {
                    limit--;
                  }
                }
              };
              Tokenizer.prototype._stateInNamedEntity = function(c3) {
                if (c3 === ";") {
                  this._parseNamedEntityStrict();
                  if (this._sectionStart + 1 < this._index && !this._xmlMode) {
                    this._parseLegacyEntity();
                  }
                  this._state = this._baseState;
                } else if ((c3 < "a" || c3 > "z") && (c3 < "A" || c3 > "Z") && (c3 < "0" || c3 > "9")) {
                  if (this._xmlMode)
                    ;
                  else if (this._sectionStart + 1 === this._index)
                    ;
                  else if (this._baseState !== TEXT) {
                    if (c3 !== "=") {
                      this._parseNamedEntityStrict();
                    }
                  } else {
                    this._parseLegacyEntity();
                  }
                  this._state = this._baseState;
                  this._index--;
                }
              };
              Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
                var sectionStart = this._sectionStart + offset;
                if (sectionStart !== this._index) {
                  var entity = this._buffer.substring(sectionStart, this._index);
                  var parsed = parseInt(entity, base);
                  this._emitPartial(decodeCodePoint(parsed));
                  this._sectionStart = this._index;
                } else {
                  this._sectionStart--;
                }
                this._state = this._baseState;
              };
              Tokenizer.prototype._stateInNumericEntity = function(c3) {
                if (c3 === ";") {
                  this._decodeNumericEntity(2, 10);
                  this._sectionStart++;
                } else if (c3 < "0" || c3 > "9") {
                  if (!this._xmlMode) {
                    this._decodeNumericEntity(2, 10);
                  } else {
                    this._state = this._baseState;
                  }
                  this._index--;
                }
              };
              Tokenizer.prototype._stateInHexEntity = function(c3) {
                if (c3 === ";") {
                  this._decodeNumericEntity(3, 16);
                  this._sectionStart++;
                } else if ((c3 < "a" || c3 > "f") && (c3 < "A" || c3 > "F") && (c3 < "0" || c3 > "9")) {
                  if (!this._xmlMode) {
                    this._decodeNumericEntity(3, 16);
                  } else {
                    this._state = this._baseState;
                  }
                  this._index--;
                }
              };
              Tokenizer.prototype._cleanup = function() {
                if (this._sectionStart < 0) {
                  this._buffer = "";
                  this._bufferOffset += this._index;
                  this._index = 0;
                } else if (this._running) {
                  if (this._state === TEXT) {
                    if (this._sectionStart !== this._index) {
                      this._cbs.ontext(this._buffer.substr(this._sectionStart));
                    }
                    this._buffer = "";
                    this._bufferOffset += this._index;
                    this._index = 0;
                  } else if (this._sectionStart === this._index) {
                    this._buffer = "";
                    this._bufferOffset += this._index;
                    this._index = 0;
                  } else {
                    this._buffer = this._buffer.substr(this._sectionStart);
                    this._index -= this._sectionStart;
                    this._bufferOffset += this._sectionStart;
                  }
                  this._sectionStart = 0;
                }
              };
              Tokenizer.prototype.write = function(chunk) {
                if (this._ended)
                  this._cbs.onerror(Error(".write() after done!"));
                this._buffer += chunk;
                this._parse();
              };
              Tokenizer.prototype._parse = function() {
                while (this._index < this._buffer.length && this._running) {
                  var c3 = this._buffer.charAt(this._index);
                  if (this._state === TEXT) {
                    this._stateText(c3);
                  } else if (this._state === BEFORE_TAG_NAME) {
                    this._stateBeforeTagName(c3);
                  } else if (this._state === IN_TAG_NAME) {
                    this._stateInTagName(c3);
                  } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
                    this._stateBeforeCloseingTagName(c3);
                  } else if (this._state === IN_CLOSING_TAG_NAME) {
                    this._stateInCloseingTagName(c3);
                  } else if (this._state === AFTER_CLOSING_TAG_NAME) {
                    this._stateAfterCloseingTagName(c3);
                  } else if (this._state === IN_SELF_CLOSING_TAG) {
                    this._stateInSelfClosingTag(c3);
                  } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
                    this._stateBeforeAttributeName(c3);
                  } else if (this._state === IN_ATTRIBUTE_NAME) {
                    this._stateInAttributeName(c3);
                  } else if (this._state === AFTER_ATTRIBUTE_NAME) {
                    this._stateAfterAttributeName(c3);
                  } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
                    this._stateBeforeAttributeValue(c3);
                  } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
                    this._stateInAttributeValueDoubleQuotes(c3);
                  } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
                    this._stateInAttributeValueSingleQuotes(c3);
                  } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
                    this._stateInAttributeValueNoQuotes(c3);
                  } else if (this._state === BEFORE_DECLARATION) {
                    this._stateBeforeDeclaration(c3);
                  } else if (this._state === IN_DECLARATION) {
                    this._stateInDeclaration(c3);
                  } else if (this._state === IN_PROCESSING_INSTRUCTION) {
                    this._stateInProcessingInstruction(c3);
                  } else if (this._state === BEFORE_COMMENT) {
                    this._stateBeforeComment(c3);
                  } else if (this._state === IN_COMMENT) {
                    this._stateInComment(c3);
                  } else if (this._state === AFTER_COMMENT_1) {
                    this._stateAfterComment1(c3);
                  } else if (this._state === AFTER_COMMENT_2) {
                    this._stateAfterComment2(c3);
                  } else if (this._state === BEFORE_CDATA_1) {
                    this._stateBeforeCdata1(c3);
                  } else if (this._state === BEFORE_CDATA_2) {
                    this._stateBeforeCdata2(c3);
                  } else if (this._state === BEFORE_CDATA_3) {
                    this._stateBeforeCdata3(c3);
                  } else if (this._state === BEFORE_CDATA_4) {
                    this._stateBeforeCdata4(c3);
                  } else if (this._state === BEFORE_CDATA_5) {
                    this._stateBeforeCdata5(c3);
                  } else if (this._state === BEFORE_CDATA_6) {
                    this._stateBeforeCdata6(c3);
                  } else if (this._state === IN_CDATA) {
                    this._stateInCdata(c3);
                  } else if (this._state === AFTER_CDATA_1) {
                    this._stateAfterCdata1(c3);
                  } else if (this._state === AFTER_CDATA_2) {
                    this._stateAfterCdata2(c3);
                  } else if (this._state === BEFORE_SPECIAL) {
                    this._stateBeforeSpecial(c3);
                  } else if (this._state === BEFORE_SPECIAL_END) {
                    this._stateBeforeSpecialEnd(c3);
                  } else if (this._state === BEFORE_SCRIPT_1) {
                    this._stateBeforeScript1(c3);
                  } else if (this._state === BEFORE_SCRIPT_2) {
                    this._stateBeforeScript2(c3);
                  } else if (this._state === BEFORE_SCRIPT_3) {
                    this._stateBeforeScript3(c3);
                  } else if (this._state === BEFORE_SCRIPT_4) {
                    this._stateBeforeScript4(c3);
                  } else if (this._state === BEFORE_SCRIPT_5) {
                    this._stateBeforeScript5(c3);
                  } else if (this._state === AFTER_SCRIPT_1) {
                    this._stateAfterScript1(c3);
                  } else if (this._state === AFTER_SCRIPT_2) {
                    this._stateAfterScript2(c3);
                  } else if (this._state === AFTER_SCRIPT_3) {
                    this._stateAfterScript3(c3);
                  } else if (this._state === AFTER_SCRIPT_4) {
                    this._stateAfterScript4(c3);
                  } else if (this._state === AFTER_SCRIPT_5) {
                    this._stateAfterScript5(c3);
                  } else if (this._state === BEFORE_STYLE_1) {
                    this._stateBeforeStyle1(c3);
                  } else if (this._state === BEFORE_STYLE_2) {
                    this._stateBeforeStyle2(c3);
                  } else if (this._state === BEFORE_STYLE_3) {
                    this._stateBeforeStyle3(c3);
                  } else if (this._state === BEFORE_STYLE_4) {
                    this._stateBeforeStyle4(c3);
                  } else if (this._state === AFTER_STYLE_1) {
                    this._stateAfterStyle1(c3);
                  } else if (this._state === AFTER_STYLE_2) {
                    this._stateAfterStyle2(c3);
                  } else if (this._state === AFTER_STYLE_3) {
                    this._stateAfterStyle3(c3);
                  } else if (this._state === AFTER_STYLE_4) {
                    this._stateAfterStyle4(c3);
                  } else if (this._state === BEFORE_ENTITY) {
                    this._stateBeforeEntity(c3);
                  } else if (this._state === BEFORE_NUMERIC_ENTITY) {
                    this._stateBeforeNumericEntity(c3);
                  } else if (this._state === IN_NAMED_ENTITY) {
                    this._stateInNamedEntity(c3);
                  } else if (this._state === IN_NUMERIC_ENTITY) {
                    this._stateInNumericEntity(c3);
                  } else if (this._state === IN_HEX_ENTITY) {
                    this._stateInHexEntity(c3);
                  } else {
                    this._cbs.onerror(Error("unknown _state"), this._state);
                  }
                  this._index++;
                }
                this._cleanup();
              };
              Tokenizer.prototype.pause = function() {
                this._running = false;
              };
              Tokenizer.prototype.resume = function() {
                this._running = true;
                if (this._index < this._buffer.length) {
                  this._parse();
                }
                if (this._ended) {
                  this._finish();
                }
              };
              Tokenizer.prototype.end = function(chunk) {
                if (this._ended)
                  this._cbs.onerror(Error(".end() after done!"));
                if (chunk)
                  this.write(chunk);
                this._ended = true;
                if (this._running)
                  this._finish();
              };
              Tokenizer.prototype._finish = function() {
                if (this._sectionStart < this._index) {
                  this._handleTrailingData();
                }
                this._cbs.onend();
              };
              Tokenizer.prototype._handleTrailingData = function() {
                var data = this._buffer.substr(this._sectionStart);
                if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
                  this._cbs.oncdata(data);
                } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
                  this._cbs.oncomment(data);
                } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
                  this._parseLegacyEntity();
                  if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                  }
                } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
                  this._decodeNumericEntity(2, 10);
                  if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                  }
                } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
                  this._decodeNumericEntity(3, 16);
                  if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                  }
                } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
                  this._cbs.ontext(data);
                }
              };
              Tokenizer.prototype.reset = function() {
                Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
              };
              Tokenizer.prototype.getAbsoluteIndex = function() {
                return this._bufferOffset + this._index;
              };
              Tokenizer.prototype._getSection = function() {
                return this._buffer.substring(this._sectionStart, this._index);
              };
              Tokenizer.prototype._emitToken = function(name) {
                this._cbs[name](this._getSection());
                this._sectionStart = -1;
              };
              Tokenizer.prototype._emitPartial = function(value) {
                if (this._baseState !== TEXT) {
                  this._cbs.onattribdata(value);
                } else {
                  this._cbs.ontext(value);
                }
              };
            },
            /* 56 */
            /***/
            function(module2, exports2, __webpack_require__) {
              var decodeMap = __webpack_require__(57);
              module2.exports = decodeCodePoint;
              function decodeCodePoint(codePoint) {
                if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
                  return "\uFFFD";
                }
                if (codePoint in decodeMap) {
                  codePoint = decodeMap[codePoint];
                }
                var output = "";
                if (codePoint > 65535) {
                  codePoint -= 65536;
                  output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                output += String.fromCharCode(codePoint);
                return output;
              }
            },
            /* 57 */
            /***/
            function(module2) {
              module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
            },
            /* 58 */
            /***/
            function(module2) {
              module2.exports = { "Aacute": "\xC1", "aacute": "\xE1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\xC2", "acirc": "\xE2", "acute": "\xB4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\xC6", "aelig": "\xE6", "af": "\u2061", "Afr": "\u{1D504}", "afr": "\u{1D51E}", "Agrave": "\xC0", "agrave": "\xE0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\u{1D538}", "aopf": "\u{1D552}", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\xC5", "aring": "\xE5", "Ascr": "\u{1D49C}", "ascr": "\u{1D4B6}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\xC3", "atilde": "\xE3", "Auml": "\xC4", "auml": "\xE4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\u{1D505}", "bfr": "\u{1D51F}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\u{1D539}", "bopf": "\u{1D553}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\xC7", "ccedil": "\xE7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\u{1D49E}", "cscr": "\u{1D4B8}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\u{1D507}", "dfr": "\u{1D521}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\u{1D53B}", "dopf": "\u{1D555}", "Dot": "\xA8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\u{1D49F}", "dscr": "\u{1D4B9}", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\xC9", "eacute": "\xE9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\xCA", "ecirc": "\xEA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\u{1D508}", "efr": "\u{1D522}", "eg": "\u2A9A", "Egrave": "\xC8", "egrave": "\xE8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\u{1D53C}", "eopf": "\u{1D556}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\xD0", "eth": "\xF0", "Euml": "\xCB", "euml": "\xEB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\u{1D509}", "ffr": "\u{1D523}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\u{1D53D}", "fopf": "\u{1D557}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\u{1D50A}", "gfr": "\u{1D524}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\u{1D53E}", "gopf": "\u{1D558}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\u{1D4A2}", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\xCD", "iacute": "\xED", "ic": "\u2063", "Icirc": "\xCE", "icirc": "\xEE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "Igrave": "\xCC", "igrave": "\xEC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\u{1D540}", "iopf": "\u{1D55A}", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\xCF", "iuml": "\xEF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\u{1D50D}", "jfr": "\u{1D527}", "jmath": "\u0237", "Jopf": "\u{1D541}", "jopf": "\u{1D55B}", "Jscr": "\u{1D4A5}", "jscr": "\u{1D4BF}", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\u{1D50E}", "kfr": "\u{1D528}", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\u{1D542}", "kopf": "\u{1D55C}", "Kscr": "\u{1D4A6}", "kscr": "\u{1D4C0}", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\u{1D50F}", "lfr": "\u{1D529}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\u{1D543}", "lopf": "\u{1D55D}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\u{1D510}", "mfr": "\u{1D52A}", "mho": "\u2127", "micro": "\xB5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\xB7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\u{1D544}", "mopf": "\u{1D55E}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\u{1D511}", "nfr": "\u{1D52B}", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\xAC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\u{1D4A9}", "nscr": "\u{1D4C3}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\xD1", "ntilde": "\xF1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\xD3", "oacute": "\xF3", "oast": "\u229B", "Ocirc": "\xD4", "ocirc": "\xF4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\u{1D512}", "ofr": "\u{1D52C}", "ogon": "\u02DB", "Ograve": "\xD2", "ograve": "\xF2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\u{1D546}", "oopf": "\u{1D560}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\u{1D4AA}", "oscr": "\u2134", "Oslash": "\xD8", "oslash": "\xF8", "osol": "\u2298", "Otilde": "\xD5", "otilde": "\xF5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\xD6", "ouml": "\xF6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\xB6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\u{1D513}", "pfr": "\u{1D52D}", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\u{1D4AB}", "pscr": "\u{1D4C5}", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\u{1D514}", "qfr": "\u{1D52E}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\u{1D4AC}", "qscr": "\u{1D4C6}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\u{1D516}", "sfr": "\u{1D530}", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\u{1D54A}", "sopf": "\u{1D564}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\u{1D4AE}", "sscr": "\u{1D4C8}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\u{1D517}", "tfr": "\u{1D531}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\xDE", "thorn": "\xFE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\xD7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\u{1D54B}", "topf": "\u{1D565}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\u{1D4AF}", "tscr": "\u{1D4C9}", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\xDA", "uacute": "\xFA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\xDB", "ucirc": "\xFB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\u{1D518}", "ufr": "\u{1D532}", "Ugrave": "\xD9", "ugrave": "\xF9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\u{1D54C}", "uopf": "\u{1D566}", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\u{1D4B0}", "uscr": "\u{1D4CA}", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\xDC", "uuml": "\xFC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\u{1D519}", "vfr": "\u{1D533}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\u{1D54D}", "vopf": "\u{1D567}", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\u{1D4B1}", "vscr": "\u{1D4CB}", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\u{1D51A}", "wfr": "\u{1D534}", "Wopf": "\u{1D54E}", "wopf": "\u{1D568}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\u{1D4B2}", "wscr": "\u{1D4CC}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\u{1D51B}", "xfr": "\u{1D535}", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\u{1D54F}", "xopf": "\u{1D569}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\u{1D4B3}", "xscr": "\u{1D4CD}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\xDD", "yacute": "\xFD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\xA5", "Yfr": "\u{1D51C}", "yfr": "\u{1D536}", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\u{1D550}", "yopf": "\u{1D56A}", "Yscr": "\u{1D4B4}", "yscr": "\u{1D4CE}", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\xFF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\u{1D537}", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "Zscr": "\u{1D4B5}", "zscr": "\u{1D4CF}", "zwj": "\u200D", "zwnj": "\u200C" };
            },
            /* 59 */
            /***/
            function(module2) {
              module2.exports = { "Aacute": "\xC1", "aacute": "\xE1", "Acirc": "\xC2", "acirc": "\xE2", "acute": "\xB4", "AElig": "\xC6", "aelig": "\xE6", "Agrave": "\xC0", "agrave": "\xE0", "amp": "&", "AMP": "&", "Aring": "\xC5", "aring": "\xE5", "Atilde": "\xC3", "atilde": "\xE3", "Auml": "\xC4", "auml": "\xE4", "brvbar": "\xA6", "Ccedil": "\xC7", "ccedil": "\xE7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "Eacute": "\xC9", "eacute": "\xE9", "Ecirc": "\xCA", "ecirc": "\xEA", "Egrave": "\xC8", "egrave": "\xE8", "ETH": "\xD0", "eth": "\xF0", "Euml": "\xCB", "euml": "\xEB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "Iacute": "\xCD", "iacute": "\xED", "Icirc": "\xCE", "icirc": "\xEE", "iexcl": "\xA1", "Igrave": "\xCC", "igrave": "\xEC", "iquest": "\xBF", "Iuml": "\xCF", "iuml": "\xEF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "Ntilde": "\xD1", "ntilde": "\xF1", "Oacute": "\xD3", "oacute": "\xF3", "Ocirc": "\xD4", "ocirc": "\xF4", "Ograve": "\xD2", "ograve": "\xF2", "ordf": "\xAA", "ordm": "\xBA", "Oslash": "\xD8", "oslash": "\xF8", "Otilde": "\xD5", "otilde": "\xF5", "Ouml": "\xD6", "ouml": "\xF6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "THORN": "\xDE", "thorn": "\xFE", "times": "\xD7", "Uacute": "\xDA", "uacute": "\xFA", "Ucirc": "\xDB", "ucirc": "\xFB", "Ugrave": "\xD9", "ugrave": "\xF9", "uml": "\xA8", "Uuml": "\xDC", "uuml": "\xFC", "Yacute": "\xDD", "yacute": "\xFD", "yen": "\xA5", "yuml": "\xFF" };
            },
            /* 60 */
            /***/
            function(module2) {
              module2.exports = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": '"' };
            },
            /* 61 */
            /***/
            function(module2, exports2) {
              if (typeof Object.create === "function") {
                module2.exports = function inherits(ctor, superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                };
              } else {
                module2.exports = function inherits(ctor, superCtor) {
                  ctor.super_ = superCtor;
                  var TempCtor = function() {
                  };
                  TempCtor.prototype = superCtor.prototype;
                  ctor.prototype = new TempCtor();
                  ctor.prototype.constructor = ctor;
                };
              }
            },
            /* 62 */
            /***/
            function(module2, exports2) {
              function EventEmitter() {
                this._events = this._events || {};
                this._maxListeners = this._maxListeners || void 0;
              }
              module2.exports = EventEmitter;
              EventEmitter.EventEmitter = EventEmitter;
              EventEmitter.prototype._events = void 0;
              EventEmitter.prototype._maxListeners = void 0;
              EventEmitter.defaultMaxListeners = 10;
              EventEmitter.prototype.setMaxListeners = function(n3) {
                if (!isNumber(n3) || n3 < 0 || isNaN(n3))
                  throw TypeError("n must be a positive number");
                this._maxListeners = n3;
                return this;
              };
              EventEmitter.prototype.emit = function(type) {
                var er2, handler, len, args, i4, listeners;
                if (!this._events)
                  this._events = {};
                if (type === "error") {
                  if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                    er2 = arguments[1];
                    if (er2 instanceof Error) {
                      throw er2;
                    } else {
                      var err = new Error('Uncaught, unspecified "error" event. (' + er2 + ")");
                      err.context = er2;
                      throw err;
                    }
                  }
                }
                handler = this._events[type];
                if (isUndefined(handler))
                  return false;
                if (isFunction(handler)) {
                  switch (arguments.length) {
                    case 1:
                      handler.call(this);
                      break;
                    case 2:
                      handler.call(this, arguments[1]);
                      break;
                    case 3:
                      handler.call(this, arguments[1], arguments[2]);
                      break;
                    default:
                      args = Array.prototype.slice.call(arguments, 1);
                      handler.apply(this, args);
                  }
                } else if (isObject(handler)) {
                  args = Array.prototype.slice.call(arguments, 1);
                  listeners = handler.slice();
                  len = listeners.length;
                  for (i4 = 0; i4 < len; i4++)
                    listeners[i4].apply(this, args);
                }
                return true;
              };
              EventEmitter.prototype.addListener = function(type, listener) {
                var m3;
                if (!isFunction(listener))
                  throw TypeError("listener must be a function");
                if (!this._events)
                  this._events = {};
                if (this._events.newListener)
                  this.emit(
                    "newListener",
                    type,
                    isFunction(listener.listener) ? listener.listener : listener
                  );
                if (!this._events[type])
                  this._events[type] = listener;
                else if (isObject(this._events[type]))
                  this._events[type].push(listener);
                else
                  this._events[type] = [this._events[type], listener];
                if (isObject(this._events[type]) && !this._events[type].warned) {
                  if (!isUndefined(this._maxListeners)) {
                    m3 = this._maxListeners;
                  } else {
                    m3 = EventEmitter.defaultMaxListeners;
                  }
                  if (m3 && m3 > 0 && this._events[type].length > m3) {
                    this._events[type].warned = true;
                    console.error(
                      "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                      this._events[type].length
                    );
                    if (typeof console.trace === "function") {
                      console.trace();
                    }
                  }
                }
                return this;
              };
              EventEmitter.prototype.on = EventEmitter.prototype.addListener;
              EventEmitter.prototype.once = function(type, listener) {
                if (!isFunction(listener))
                  throw TypeError("listener must be a function");
                var fired = false;
                function g4() {
                  this.removeListener(type, g4);
                  if (!fired) {
                    fired = true;
                    listener.apply(this, arguments);
                  }
                }
                g4.listener = listener;
                this.on(type, g4);
                return this;
              };
              EventEmitter.prototype.removeListener = function(type, listener) {
                var list, position, length, i4;
                if (!isFunction(listener))
                  throw TypeError("listener must be a function");
                if (!this._events || !this._events[type])
                  return this;
                list = this._events[type];
                length = list.length;
                position = -1;
                if (list === listener || isFunction(list.listener) && list.listener === listener) {
                  delete this._events[type];
                  if (this._events.removeListener)
                    this.emit("removeListener", type, listener);
                } else if (isObject(list)) {
                  for (i4 = length; i4-- > 0; ) {
                    if (list[i4] === listener || list[i4].listener && list[i4].listener === listener) {
                      position = i4;
                      break;
                    }
                  }
                  if (position < 0)
                    return this;
                  if (list.length === 1) {
                    list.length = 0;
                    delete this._events[type];
                  } else {
                    list.splice(position, 1);
                  }
                  if (this._events.removeListener)
                    this.emit("removeListener", type, listener);
                }
                return this;
              };
              EventEmitter.prototype.removeAllListeners = function(type) {
                var key, listeners;
                if (!this._events)
                  return this;
                if (!this._events.removeListener) {
                  if (arguments.length === 0)
                    this._events = {};
                  else if (this._events[type])
                    delete this._events[type];
                  return this;
                }
                if (arguments.length === 0) {
                  for (key in this._events) {
                    if (key === "removeListener")
                      continue;
                    this.removeAllListeners(key);
                  }
                  this.removeAllListeners("removeListener");
                  this._events = {};
                  return this;
                }
                listeners = this._events[type];
                if (isFunction(listeners)) {
                  this.removeListener(type, listeners);
                } else if (listeners) {
                  while (listeners.length)
                    this.removeListener(type, listeners[listeners.length - 1]);
                }
                delete this._events[type];
                return this;
              };
              EventEmitter.prototype.listeners = function(type) {
                var ret;
                if (!this._events || !this._events[type])
                  ret = [];
                else if (isFunction(this._events[type]))
                  ret = [this._events[type]];
                else
                  ret = this._events[type].slice();
                return ret;
              };
              EventEmitter.prototype.listenerCount = function(type) {
                if (this._events) {
                  var evlistener = this._events[type];
                  if (isFunction(evlistener))
                    return 1;
                  else if (evlistener)
                    return evlistener.length;
                }
                return 0;
              };
              EventEmitter.listenerCount = function(emitter, type) {
                return emitter.listenerCount(type);
              };
              function isFunction(arg) {
                return typeof arg === "function";
              }
              function isNumber(arg) {
                return typeof arg === "number";
              }
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              function isUndefined(arg) {
                return arg === void 0;
              }
            },
            /* 63 */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var web_dom_iterable = __webpack_require__(19);
              var es6_array_iterator = __webpack_require__(20);
              var es6_object_keys = __webpack_require__(47);
              var es6_object_assign = __webpack_require__(49);
              var es6_regexp_replace = __webpack_require__(53);
              var Parser2 = __webpack_require__(29);
              var Parser_default = /* @__PURE__ */ __webpack_require__.n(Parser2);
              var renderer = function(incrementalDom) {
                var autoClosingStack = [];
                var autoClosing = function autoClosing2() {
                  var stack = autoClosingStack.shift();
                  if (!stack)
                    return;
                  stack.reverse().forEach(function(tag) {
                    return incrementalDom.elementClose(tag);
                  });
                };
                var attr = incrementalDom.attr, elementOpenEnd = incrementalDom.elementOpenEnd, elementVoid = incrementalDom.elementVoid, text2 = incrementalDom.text;
                var elementOpen = function elementOpen2(tag) {
                  if (autoClosingStack.length > 0)
                    autoClosingStack[0].push(tag);
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  incrementalDom.elementOpen.apply(incrementalDom, [tag].concat(args));
                };
                var elementOpenStart = function elementOpenStart2(tag) {
                  if (autoClosingStack.length > 0)
                    autoClosingStack[0].push(tag);
                  incrementalDom.elementOpenStart(tag);
                };
                var elementClose = function elementClose2(tag) {
                  if (autoClosingStack.length > 0)
                    autoClosingStack[0].pop();
                  incrementalDom.elementClose(tag);
                };
                var sanitizeName = function sanitizeName2(name) {
                  return name.replace(/[^-:\w]/g, "");
                };
                var iDOMParser = new Parser_default.a({
                  onopentag: function onopentag(name) {
                    return elementOpenEnd(sanitizeName(name));
                  },
                  onopentagname: function onopentagname(name) {
                    return elementOpenStart(sanitizeName(name));
                  },
                  onattribute: function onattribute(name, value) {
                    var sanitizedName = sanitizeName(name);
                    if (sanitizedName !== "")
                      attr(sanitizedName, value);
                  },
                  ontext: text2,
                  onclosetag: function onclosetag(name) {
                    return elementClose(sanitizeName(name));
                  }
                }, {
                  decodeEntities: true,
                  lowerCaseAttributeNames: false,
                  lowerCaseTags: false
                });
                var wrapIncrementalDOM = function wrapIncrementalDOM2(html) {
                  return typeof html === "function" ? html() : iDOMParser.write(html);
                };
                return {
                  renderAttrsToArray: function renderAttrsToArray(token) {
                    if (!token.attrs)
                      return [];
                    return token.attrs.reduce(function(v3, a4) {
                      return v3.concat(a4);
                    }, []);
                  },
                  renderInline: function renderInline(tokens, options, env) {
                    var _this = this;
                    return function() {
                      autoClosingStack.unshift([]);
                      tokens.forEach(function(current, i4) {
                        var type = current.type;
                        if (_this.rules[type] !== void 0) {
                          wrapIncrementalDOM(_this.rules[type](tokens, i4, options, env, _this));
                        } else {
                          _this.renderToken(tokens, i4, options)();
                        }
                      });
                      autoClosing();
                    };
                  },
                  renderToken: function renderToken(tokens, idx) {
                    var _this2 = this;
                    return function() {
                      var token = tokens[idx];
                      if (token.hidden)
                        return;
                      if (token.nesting === -1) {
                        elementClose(token.tag);
                      } else {
                        var func = token.nesting === 0 ? elementVoid : elementOpen;
                        func.apply(_this2, [token.tag, "", []].concat(_this2.renderAttrsToArray(token)));
                      }
                    };
                  },
                  render: function render3(tokens, options, env) {
                    var _this3 = this;
                    return function() {
                      autoClosingStack.unshift([]);
                      tokens.forEach(function(current, i4) {
                        var type = current.type;
                        if (type === "inline") {
                          _this3.renderInline(current.children, options, env)();
                        } else if (_this3.rules[type] !== void 0) {
                          wrapIncrementalDOM(_this3.rules[type](tokens, i4, options, env, _this3));
                        } else {
                          _this3.renderToken(tokens, i4, options, env)();
                        }
                      });
                      autoClosing();
                      iDOMParser.reset();
                    };
                  }
                };
              };
              var rules = function(incrementalDom) {
                var elementClose = incrementalDom.elementClose, elementOpen = incrementalDom.elementOpen, elementVoid = incrementalDom.elementVoid, _text = incrementalDom.text;
                return {
                  code_inline: function code_inline(tokens, idx, options, env, slf) {
                    var _this = this;
                    return function() {
                      elementOpen.apply(_this, ["code", "", []].concat(slf.renderAttrsToArray(tokens[idx])));
                      _text(tokens[idx].content);
                      elementClose("code");
                    };
                  },
                  code_block: function code_block(tokens, idx, options, env, slf) {
                    var _this2 = this;
                    return function() {
                      elementOpen.apply(_this2, ["pre", "", []].concat(slf.renderAttrsToArray(tokens[idx])));
                      elementOpen("code");
                      _text(tokens[idx].content);
                      elementClose("code");
                      elementClose("pre");
                    };
                  },
                  hardbreak: function hardbreak() {
                    return function() {
                      return elementVoid("br");
                    };
                  },
                  softbreak: function softbreak(tokens, idx, options) {
                    return function() {
                      return options.breaks ? elementVoid("br") : _text("\n");
                    };
                  },
                  text: function text2(tokens, idx) {
                    return function() {
                      return _text(tokens[idx].content);
                    };
                  }
                };
              };
              function _objectSpread(target) {
                for (var i4 = 1; i4 < arguments.length; i4++) {
                  var source = arguments[i4] != null ? arguments[i4] : {};
                  var ownKeys = Object.keys(source);
                  if (typeof Object.getOwnPropertySymbols === "function") {
                    ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                    }));
                  }
                  ownKeys.forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                }
                return target;
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              var markdown_it_incremental_dom = function(md, target) {
                var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var options = _objectSpread({
                  incrementalizeDefaultRules: true
                }, opts);
                var incrementalDOM = !target && window ? window.IncrementalDOM : target;
                var mixin = renderer(incrementalDOM);
                Object.defineProperty(md, "IncrementalDOMRenderer", {
                  get: function get() {
                    var extended = Object.assign(Object.create(Object.getPrototypeOf(md.renderer)), md.renderer, mixin);
                    if (options.incrementalizeDefaultRules) {
                      extended.rules = _objectSpread({}, extended.rules, rules(incrementalDOM));
                    }
                    return extended;
                  }
                });
                md.renderToIncrementalDOM = function(src) {
                  var env = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  return md.IncrementalDOMRenderer.render(md.parse(src, env), md.options, env);
                };
                md.renderInlineToIncrementalDOM = function(src) {
                  var env = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  return md.IncrementalDOMRenderer.render(md.parseInline(src, env), md.options, env);
                };
              };
              __webpack_require__.d(__webpack_exports__, "markdownitIncrementalDOM", function() {
                return markdown_it_incremental_dom;
              });
              var entry = __webpack_exports__["default"] = markdown_it_incremental_dom;
            }
            /******/
          ])
        );
      });
    }
  });

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/incremental-dom/incremental-dom.js
  var require_incremental_dom = __commonJS({
    "../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/incremental-dom/incremental-dom.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory((global || self || window).IncrementalDOM = {});
      })(exports, function(exports2) {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function Blank() {
        }
        Blank.prototype = /* @__PURE__ */ Object.create(null);
        var has = function(map, property) {
          return hasOwnProperty.call(map, property);
        };
        var createMap = function() {
          return new Blank();
        };
        var DATA_PROP = "__incrementalDOMData";
        function NodeData(nodeName, key) {
          this.attrs = createMap();
          this.attrsArr = [];
          this.newAttrs = createMap();
          this.staticsApplied = false;
          this.key = key;
          this.keyMap = createMap();
          this.keyMapValid = true;
          this.focused = false;
          this.nodeName = nodeName;
          this.text = null;
        }
        var initData = function(node, nodeName, key) {
          var data = new NodeData(nodeName, key);
          node[DATA_PROP] = data;
          return data;
        };
        var getData = function(node) {
          importNode(node);
          return node[DATA_PROP];
        };
        var importNode = function(node) {
          if (node[DATA_PROP]) {
            return;
          }
          var isElement = node instanceof Element;
          var nodeName = isElement ? node.localName : node.nodeName;
          var key = isElement ? node.getAttribute("key") : null;
          var data = initData(node, nodeName, key);
          if (key) {
            getData(node.parentNode).keyMap[key] = node;
          }
          if (isElement) {
            var attributes2 = node.attributes;
            var attrs = data.attrs;
            var newAttrs = data.newAttrs;
            var attrsArr = data.attrsArr;
            for (var i4 = 0; i4 < attributes2.length; i4 += 1) {
              var attr2 = attributes2[i4];
              var name = attr2.name;
              var value = attr2.value;
              attrs[name] = value;
              newAttrs[name] = void 0;
              attrsArr.push(name);
              attrsArr.push(value);
            }
          }
          for (var child = node.firstChild; child; child = child.nextSibling) {
            importNode(child);
          }
        };
        var getNamespaceForTag = function(tag, parent) {
          if (tag === "svg") {
            return "http://www.w3.org/2000/svg";
          }
          if (getData(parent).nodeName === "foreignObject") {
            return null;
          }
          return parent.namespaceURI;
        };
        var createElement = function(doc2, parent, tag, key) {
          var namespace = getNamespaceForTag(tag, parent);
          var el = void 0;
          if (namespace) {
            el = doc2.createElementNS(namespace, tag);
          } else {
            el = doc2.createElement(tag);
          }
          initData(el, tag, key);
          return el;
        };
        var createText = function(doc2) {
          var node = doc2.createTextNode("");
          initData(node, "#text", null);
          return node;
        };
        var notifications = {
          /**
           * Called after patch has compleated with any Nodes that have been created
           * and added to the DOM.
           * @type {?function(Array<!Node>)}
           */
          nodesCreated: null,
          /**
           * Called after patch has compleated with any Nodes that have been removed
           * from the DOM.
           * Note it's an applications responsibility to handle any childNodes.
           * @type {?function(Array<!Node>)}
           */
          nodesDeleted: null
        };
        function Context() {
          this.created = notifications.nodesCreated && [];
          this.deleted = notifications.nodesDeleted && [];
        }
        Context.prototype.markCreated = function(node) {
          if (this.created) {
            this.created.push(node);
          }
        };
        Context.prototype.markDeleted = function(node) {
          if (this.deleted) {
            this.deleted.push(node);
          }
        };
        Context.prototype.notifyChanges = function() {
          if (this.created && this.created.length > 0) {
            notifications.nodesCreated(this.created);
          }
          if (this.deleted && this.deleted.length > 0) {
            notifications.nodesDeleted(this.deleted);
          }
        };
        var isDocumentRoot = function(node) {
          return node instanceof Document || node instanceof DocumentFragment;
        };
        var getAncestry = function(node, root) {
          var ancestry = [];
          var cur = node;
          while (cur !== root) {
            ancestry.push(cur);
            cur = cur.parentNode;
          }
          return ancestry;
        };
        var getRoot = function(node) {
          var cur = node;
          var prev = cur;
          while (cur) {
            prev = cur;
            cur = cur.parentNode;
          }
          return prev;
        };
        var getActiveElement = function(node) {
          var root = getRoot(node);
          return isDocumentRoot(root) ? root.activeElement : null;
        };
        var getFocusedPath = function(node, root) {
          var activeElement = getActiveElement(node);
          if (!activeElement || !node.contains(activeElement)) {
            return [];
          }
          return getAncestry(activeElement, root);
        };
        var moveBefore = function(parentNode, node, referenceNode) {
          var insertReferenceNode = node.nextSibling;
          var cur = referenceNode;
          while (cur !== node) {
            var next = cur.nextSibling;
            parentNode.insertBefore(cur, insertReferenceNode);
            cur = next;
          }
        };
        var context = null;
        var currentNode = null;
        var currentParent = null;
        var doc = null;
        var markFocused = function(focusPath, focused) {
          for (var i4 = 0; i4 < focusPath.length; i4 += 1) {
            getData(focusPath[i4]).focused = focused;
          }
        };
        var patchFactory = function(run) {
          var f4 = function(node, fn, data) {
            var prevContext = context;
            var prevDoc = doc;
            var prevCurrentNode = currentNode;
            var prevCurrentParent = currentParent;
            var previousInAttributes = false;
            var previousInSkip = false;
            context = new Context();
            doc = node.ownerDocument;
            currentParent = node.parentNode;
            if (false) {
            }
            var focusPath = getFocusedPath(node, currentParent);
            markFocused(focusPath, true);
            var retVal = run(node, fn, data);
            markFocused(focusPath, false);
            if (false) {
            }
            context.notifyChanges();
            context = prevContext;
            doc = prevDoc;
            currentNode = prevCurrentNode;
            currentParent = prevCurrentParent;
            return retVal;
          };
          return f4;
        };
        var patchInner = patchFactory(function(node, fn, data) {
          currentNode = node;
          enterNode();
          fn(data);
          exitNode();
          if (false) {
          }
          return node;
        });
        var patchOuter = patchFactory(function(node, fn, data) {
          var startNode = (
            /** @type {!Element} */
            { nextSibling: node }
          );
          var expectedNextNode = null;
          var expectedPrevNode = null;
          if (false) {
          }
          currentNode = startNode;
          fn(data);
          if (false) {
          }
          if (node !== currentNode && node.parentNode) {
            removeChild(currentParent, node, getData(currentParent).keyMap);
          }
          return startNode === currentNode ? null : currentNode;
        });
        var matches = function(matchNode, nodeName, key) {
          var data = getData(matchNode);
          return nodeName === data.nodeName && key == data.key;
        };
        var alignWithDOM = function(nodeName, key) {
          if (currentNode && matches(currentNode, nodeName, key)) {
            return;
          }
          var parentData = getData(currentParent);
          var currentNodeData = currentNode && getData(currentNode);
          var keyMap = parentData.keyMap;
          var node = void 0;
          if (key) {
            var keyNode = keyMap[key];
            if (keyNode) {
              if (matches(keyNode, nodeName, key)) {
                node = keyNode;
              } else if (keyNode === currentNode) {
                context.markDeleted(keyNode);
              } else {
                removeChild(currentParent, keyNode, keyMap);
              }
            }
          }
          if (!node) {
            if (nodeName === "#text") {
              node = createText(doc);
            } else {
              node = createElement(doc, currentParent, nodeName, key);
            }
            if (key) {
              keyMap[key] = node;
            }
            context.markCreated(node);
          }
          if (getData(node).focused) {
            moveBefore(currentParent, node, currentNode);
          } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {
            currentParent.replaceChild(node, currentNode);
            parentData.keyMapValid = false;
          } else {
            currentParent.insertBefore(node, currentNode);
          }
          currentNode = node;
        };
        var removeChild = function(node, child, keyMap) {
          node.removeChild(child);
          context.markDeleted(
            /** @type {!Node}*/
            child
          );
          var key = getData(child).key;
          if (key) {
            delete keyMap[key];
          }
        };
        var clearUnvisitedDOM = function() {
          var node = currentParent;
          var data = getData(node);
          var keyMap = data.keyMap;
          var keyMapValid = data.keyMapValid;
          var child = node.lastChild;
          var key = void 0;
          if (child === currentNode && keyMapValid) {
            return;
          }
          while (child !== currentNode) {
            removeChild(node, child, keyMap);
            child = node.lastChild;
          }
          if (!keyMapValid) {
            for (key in keyMap) {
              child = keyMap[key];
              if (child.parentNode !== node) {
                context.markDeleted(child);
                delete keyMap[key];
              }
            }
            data.keyMapValid = true;
          }
        };
        var enterNode = function() {
          currentParent = currentNode;
          currentNode = null;
        };
        var getNextNode = function() {
          if (currentNode) {
            return currentNode.nextSibling;
          } else {
            return currentParent.firstChild;
          }
        };
        var nextNode = function() {
          currentNode = getNextNode();
        };
        var exitNode = function() {
          clearUnvisitedDOM();
          currentNode = currentParent;
          currentParent = currentParent.parentNode;
        };
        var coreElementOpen = function(tag, key) {
          nextNode();
          alignWithDOM(tag, key);
          enterNode();
          return (
            /** @type {!Element} */
            currentParent
          );
        };
        var coreElementClose = function() {
          if (false) {
          }
          exitNode();
          return (
            /** @type {!Element} */
            currentNode
          );
        };
        var coreText = function() {
          nextNode();
          alignWithDOM("#text", null);
          return (
            /** @type {!Text} */
            currentNode
          );
        };
        var currentElement = function() {
          if (false) {
          }
          return (
            /** @type {!Element} */
            currentParent
          );
        };
        var currentPointer = function() {
          if (false) {
          }
          return getNextNode();
        };
        var skip = function() {
          if (false) {
          }
          currentNode = currentParent.lastChild;
        };
        var skipNode = nextNode;
        var symbols2 = {
          default: "__default"
        };
        var getNamespace = function(name) {
          if (name.lastIndexOf("xml:", 0) === 0) {
            return "http://www.w3.org/XML/1998/namespace";
          }
          if (name.lastIndexOf("xlink:", 0) === 0) {
            return "http://www.w3.org/1999/xlink";
          }
        };
        var applyAttr = function(el, name, value) {
          if (value == null) {
            el.removeAttribute(name);
          } else {
            var attrNS = getNamespace(name);
            if (attrNS) {
              el.setAttributeNS(attrNS, name, value);
            } else {
              el.setAttribute(name, value);
            }
          }
        };
        var applyProp = function(el, name, value) {
          el[name] = value;
        };
        var setStyleValue = function(style, prop, value) {
          if (prop.indexOf("-") >= 0) {
            style.setProperty(
              prop,
              /** @type {string} */
              value
            );
          } else {
            style[prop] = value;
          }
        };
        var applyStyle = function(el, name, style) {
          if (typeof style === "string") {
            el.style.cssText = style;
          } else {
            el.style.cssText = "";
            var elStyle = el.style;
            var obj = (
              /** @type {!Object<string,string>} */
              style
            );
            for (var prop in obj) {
              if (has(obj, prop)) {
                setStyleValue(elStyle, prop, obj[prop]);
              }
            }
          }
        };
        var applyAttributeTyped = function(el, name, value) {
          var type = typeof value;
          if (type === "object" || type === "function") {
            applyProp(el, name, value);
          } else {
            applyAttr(
              el,
              name,
              /** @type {?(boolean|number|string)} */
              value
            );
          }
        };
        var updateAttribute = function(el, name, value) {
          var data = getData(el);
          var attrs = data.attrs;
          if (attrs[name] === value) {
            return;
          }
          var mutator = attributes[name] || attributes[symbols2.default];
          mutator(el, name, value);
          attrs[name] = value;
        };
        var attributes = createMap();
        attributes[symbols2.default] = applyAttributeTyped;
        attributes["style"] = applyStyle;
        var ATTRIBUTES_OFFSET = 3;
        var argsBuilder = [];
        var elementOpen = function(tag, key, statics, var_args) {
          if (false) {
          }
          var node = coreElementOpen(tag, key);
          var data = getData(node);
          if (!data.staticsApplied) {
            if (statics) {
              for (var _i = 0; _i < statics.length; _i += 2) {
                var name = (
                  /** @type {string} */
                  statics[_i]
                );
                var value = statics[_i + 1];
                updateAttribute(node, name, value);
              }
            }
            data.staticsApplied = true;
          }
          var attrsArr = data.attrsArr;
          var newAttrs = data.newAttrs;
          var isNew = !attrsArr.length;
          var i4 = ATTRIBUTES_OFFSET;
          var j3 = 0;
          for (; i4 < arguments.length; i4 += 2, j3 += 2) {
            var _attr = arguments[i4];
            if (isNew) {
              attrsArr[j3] = _attr;
              newAttrs[_attr] = void 0;
            } else if (attrsArr[j3] !== _attr) {
              break;
            }
            var value = arguments[i4 + 1];
            if (isNew || attrsArr[j3 + 1] !== value) {
              attrsArr[j3 + 1] = value;
              updateAttribute(node, _attr, value);
            }
          }
          if (i4 < arguments.length || j3 < attrsArr.length) {
            for (; i4 < arguments.length; i4 += 1, j3 += 1) {
              attrsArr[j3] = arguments[i4];
            }
            if (j3 < attrsArr.length) {
              attrsArr.length = j3;
            }
            for (i4 = 0; i4 < attrsArr.length; i4 += 2) {
              var name = (
                /** @type {string} */
                attrsArr[i4]
              );
              var value = attrsArr[i4 + 1];
              newAttrs[name] = value;
            }
            for (var _attr2 in newAttrs) {
              updateAttribute(node, _attr2, newAttrs[_attr2]);
              newAttrs[_attr2] = void 0;
            }
          }
          return node;
        };
        var elementOpenStart = function(tag, key, statics) {
          if (false) {
          }
          argsBuilder[0] = tag;
          argsBuilder[1] = key;
          argsBuilder[2] = statics;
        };
        var attr = function(name, value) {
          if (false) {
          }
          argsBuilder.push(name);
          argsBuilder.push(value);
        };
        var elementOpenEnd = function() {
          if (false) {
          }
          var node = elementOpen.apply(null, argsBuilder);
          argsBuilder.length = 0;
          return node;
        };
        var elementClose = function(tag) {
          if (false) {
          }
          var node = coreElementClose();
          if (false) {
          }
          return node;
        };
        var elementVoid = function(tag, key, statics, var_args) {
          elementOpen.apply(null, arguments);
          return elementClose(tag);
        };
        var text2 = function(value, var_args) {
          if (false) {
          }
          var node = coreText();
          var data = getData(node);
          if (data.text !== value) {
            data.text = /** @type {string} */
            value;
            var formatted = value;
            for (var i4 = 1; i4 < arguments.length; i4 += 1) {
              var fn = arguments[i4];
              formatted = fn(formatted);
            }
            node.data = formatted;
          }
          return node;
        };
        exports2.patch = patchInner;
        exports2.patchInner = patchInner;
        exports2.patchOuter = patchOuter;
        exports2.currentElement = currentElement;
        exports2.currentPointer = currentPointer;
        exports2.skip = skip;
        exports2.skipNode = skipNode;
        exports2.elementVoid = elementVoid;
        exports2.elementOpenStart = elementOpenStart;
        exports2.elementOpenEnd = elementOpenEnd;
        exports2.elementOpen = elementOpen;
        exports2.elementClose = elementClose;
        exports2.text = text2;
        exports2.attr = attr;
        exports2.symbols = symbols2;
        exports2.attributes = attributes;
        exports2.applyAttr = applyAttr;
        exports2.applyProp = applyProp;
        exports2.notifications = notifications;
        exports2.importNode = importNode;
      });
    }
  });

  // <stdin>
  var stdin_exports = {};
  __export(stdin_exports, {
    default: () => stdin_default
  });

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/markdown-it.min.js
  function e(e3) {
    if (e3.__esModule)
      return e3;
    var r3 = Object.defineProperty({}, "__esModule", { value: true });
    return Object.keys(e3).forEach(function(t3) {
      var n3 = Object.getOwnPropertyDescriptor(e3, t3);
      Object.defineProperty(r3, t3, n3.get ? n3 : { enumerable: true, get: function() {
        return e3[t3];
      } });
    }), r3;
  }
  var r = {};
  var t = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  var n = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  var s = {};
  var o = {};
  function i(e3, r3, t3) {
    var n3, s3, a4, c3, l4, u4 = "";
    for ("string" != typeof r3 && (t3 = r3, r3 = i.defaultChars), void 0 === t3 && (t3 = true), l4 = function(e4) {
      var r4, t4, n4 = o[e4];
      if (n4)
        return n4;
      for (n4 = o[e4] = [], r4 = 0; r4 < 128; r4++)
        t4 = String.fromCharCode(r4), /^[0-9a-z]$/i.test(t4) ? n4.push(t4) : n4.push("%" + ("0" + r4.toString(16).toUpperCase()).slice(-2));
      for (r4 = 0; r4 < e4.length; r4++)
        n4[e4.charCodeAt(r4)] = e4[r4];
      return n4;
    }(r3), n3 = 0, s3 = e3.length; n3 < s3; n3++)
      if (a4 = e3.charCodeAt(n3), t3 && 37 === a4 && n3 + 2 < s3 && /^[0-9a-f]{2}$/i.test(e3.slice(n3 + 1, n3 + 3)))
        u4 += e3.slice(n3, n3 + 3), n3 += 2;
      else if (a4 < 128)
        u4 += l4[a4];
      else if (a4 >= 55296 && a4 <= 57343) {
        if (a4 >= 55296 && a4 <= 56319 && n3 + 1 < s3 && (c3 = e3.charCodeAt(n3 + 1)) >= 56320 && c3 <= 57343) {
          u4 += encodeURIComponent(e3[n3] + e3[n3 + 1]), n3++;
          continue;
        }
        u4 += "%EF%BF%BD";
      } else
        u4 += encodeURIComponent(e3[n3]);
    return u4;
  }
  i.defaultChars = ";/?:@&=+$,-_.!~*'()#", i.componentChars = "-_.!~*'()";
  var a = i;
  var c = {};
  function l(e3, r3) {
    var t3;
    return "string" != typeof r3 && (r3 = l.defaultChars), t3 = function(e4) {
      var r4, t4, n3 = c[e4];
      if (n3)
        return n3;
      for (n3 = c[e4] = [], r4 = 0; r4 < 128; r4++)
        t4 = String.fromCharCode(r4), n3.push(t4);
      for (r4 = 0; r4 < e4.length; r4++)
        n3[t4 = e4.charCodeAt(r4)] = "%" + ("0" + t4.toString(16).toUpperCase()).slice(-2);
      return n3;
    }(r3), e3.replace(/(%[a-f0-9]{2})+/gi, function(e4) {
      var r4, n3, s3, o4, i4, a4, c3, l4 = "";
      for (r4 = 0, n3 = e4.length; r4 < n3; r4 += 3)
        (s3 = parseInt(e4.slice(r4 + 1, r4 + 3), 16)) < 128 ? l4 += t3[s3] : 192 == (224 & s3) && r4 + 3 < n3 && 128 == (192 & (o4 = parseInt(e4.slice(r4 + 4, r4 + 6), 16))) ? (l4 += (c3 = s3 << 6 & 1984 | 63 & o4) < 128 ? "\uFFFD\uFFFD" : String.fromCharCode(c3), r4 += 3) : 224 == (240 & s3) && r4 + 6 < n3 && (o4 = parseInt(e4.slice(r4 + 4, r4 + 6), 16), i4 = parseInt(e4.slice(r4 + 7, r4 + 9), 16), 128 == (192 & o4) && 128 == (192 & i4)) ? (l4 += (c3 = s3 << 12 & 61440 | o4 << 6 & 4032 | 63 & i4) < 2048 || c3 >= 55296 && c3 <= 57343 ? "\uFFFD\uFFFD\uFFFD" : String.fromCharCode(c3), r4 += 6) : 240 == (248 & s3) && r4 + 9 < n3 && (o4 = parseInt(e4.slice(r4 + 4, r4 + 6), 16), i4 = parseInt(e4.slice(r4 + 7, r4 + 9), 16), a4 = parseInt(e4.slice(r4 + 10, r4 + 12), 16), 128 == (192 & o4) && 128 == (192 & i4) && 128 == (192 & a4)) ? ((c3 = s3 << 18 & 1835008 | o4 << 12 & 258048 | i4 << 6 & 4032 | 63 & a4) < 65536 || c3 > 1114111 ? l4 += "\uFFFD\uFFFD\uFFFD\uFFFD" : (c3 -= 65536, l4 += String.fromCharCode(55296 + (c3 >> 10), 56320 + (1023 & c3))), r4 += 9) : l4 += "\uFFFD";
      return l4;
    });
  }
  l.defaultChars = ";/?:@&=+$,#", l.componentChars = "";
  var u = l;
  function p() {
    this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
  }
  var h = /^([a-z0-9.+-]+:)/i;
  var f = /:[0-9]*$/;
  var d = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var m = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
  var g = ["'"].concat(m);
  var _ = ["%", "/", "?", ";", "#"].concat(g);
  var k = ["/", "?", "#"];
  var b = /^[+a-z0-9A-Z_-]{0,63}$/;
  var v = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var C = { javascript: true, "javascript:": true };
  var y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  p.prototype.parse = function(e3, r3) {
    var t3, n3, s3, o4, i4, a4 = e3;
    if (a4 = a4.trim(), !r3 && 1 === e3.split("#").length) {
      var c3 = d.exec(a4);
      if (c3)
        return this.pathname = c3[1], c3[2] && (this.search = c3[2]), this;
    }
    var l4 = h.exec(a4);
    if (l4 && (s3 = (l4 = l4[0]).toLowerCase(), this.protocol = l4, a4 = a4.substr(l4.length)), (r3 || l4 || a4.match(/^\/\/[^@\/]+@[^@\/]+/)) && (!(i4 = "//" === a4.substr(0, 2)) || l4 && C[l4] || (a4 = a4.substr(2), this.slashes = true)), !C[l4] && (i4 || l4 && !y[l4])) {
      var u4, p3, f4 = -1;
      for (t3 = 0; t3 < k.length; t3++)
        -1 !== (o4 = a4.indexOf(k[t3])) && (-1 === f4 || o4 < f4) && (f4 = o4);
      for (-1 !== (p3 = -1 === f4 ? a4.lastIndexOf("@") : a4.lastIndexOf("@", f4)) && (u4 = a4.slice(0, p3), a4 = a4.slice(p3 + 1), this.auth = u4), f4 = -1, t3 = 0; t3 < _.length; t3++)
        -1 !== (o4 = a4.indexOf(_[t3])) && (-1 === f4 || o4 < f4) && (f4 = o4);
      -1 === f4 && (f4 = a4.length), ":" === a4[f4 - 1] && f4--;
      var m3 = a4.slice(0, f4);
      a4 = a4.slice(f4), this.parseHost(m3), this.hostname = this.hostname || "";
      var g4 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
      if (!g4) {
        var A4 = this.hostname.split(/\./);
        for (t3 = 0, n3 = A4.length; t3 < n3; t3++) {
          var x3 = A4[t3];
          if (x3 && !x3.match(b)) {
            for (var D4 = "", w3 = 0, E4 = x3.length; w3 < E4; w3++)
              x3.charCodeAt(w3) > 127 ? D4 += "x" : D4 += x3[w3];
            if (!D4.match(b)) {
              var q3 = A4.slice(0, t3), S4 = A4.slice(t3 + 1), F3 = x3.match(v);
              F3 && (q3.push(F3[1]), S4.unshift(F3[2])), S4.length && (a4 = S4.join(".") + a4), this.hostname = q3.join(".");
              break;
            }
          }
        }
      }
      this.hostname.length > 255 && (this.hostname = ""), g4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
    }
    var L4 = a4.indexOf("#");
    -1 !== L4 && (this.hash = a4.substr(L4), a4 = a4.slice(0, L4));
    var z3 = a4.indexOf("?");
    return -1 !== z3 && (this.search = a4.substr(z3), a4 = a4.slice(0, z3)), a4 && (this.pathname = a4), y[s3] && this.hostname && !this.pathname && (this.pathname = ""), this;
  }, p.prototype.parseHost = function(e3) {
    var r3 = f.exec(e3);
    r3 && (":" !== (r3 = r3[0]) && (this.port = r3.substr(1)), e3 = e3.substr(0, e3.length - r3.length)), e3 && (this.hostname = e3);
  };
  var A = function(e3, r3) {
    if (e3 && e3 instanceof p)
      return e3;
    var t3 = new p();
    return t3.parse(e3, r3), t3;
  };
  s.encode = a, s.decode = u, s.format = function(e3) {
    var r3 = "";
    return r3 += e3.protocol || "", r3 += e3.slashes ? "//" : "", r3 += e3.auth ? e3.auth + "@" : "", e3.hostname && -1 !== e3.hostname.indexOf(":") ? r3 += "[" + e3.hostname + "]" : r3 += e3.hostname || "", r3 += e3.port ? ":" + e3.port : "", r3 += e3.pathname || "", r3 += e3.search || "", r3 += e3.hash || "";
  }, s.parse = A;
  var x = {};
  var D = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var w = /[\0-\x1F\x7F-\x9F]/;
  var E = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  x.Any = D, x.Cc = w, x.Cf = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, x.P = n, x.Z = E, function(e3) {
    var r3 = Object.prototype.hasOwnProperty;
    function o4(e4, t3) {
      return r3.call(e4, t3);
    }
    function i4(e4) {
      return !(e4 >= 55296 && e4 <= 57343) && (!(e4 >= 64976 && e4 <= 65007) && (65535 != (65535 & e4) && 65534 != (65535 & e4) && (!(e4 >= 0 && e4 <= 8) && (11 !== e4 && (!(e4 >= 14 && e4 <= 31) && (!(e4 >= 127 && e4 <= 159) && !(e4 > 1114111)))))));
    }
    function a4(e4) {
      if (e4 > 65535) {
        var r4 = 55296 + ((e4 -= 65536) >> 10), t3 = 56320 + (1023 & e4);
        return String.fromCharCode(r4, t3);
      }
      return String.fromCharCode(e4);
    }
    var c3 = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, l4 = new RegExp(c3.source + "|" + /&([a-z#][a-z0-9]{1,31});/gi.source, "gi"), u4 = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, p3 = t;
    var h3 = /[&<>"]/, f4 = /[&<>"]/g, d3 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
    function m3(e4) {
      return d3[e4];
    }
    var g4 = /[.?*+^$[\]\\(){}|-]/g;
    var _4 = n;
    e3.lib = {}, e3.lib.mdurl = s, e3.lib.ucmicro = x, e3.assign = function(e4) {
      var r4 = Array.prototype.slice.call(arguments, 1);
      return r4.forEach(function(r5) {
        if (r5) {
          if ("object" != typeof r5)
            throw new TypeError(r5 + "must be object");
          Object.keys(r5).forEach(function(t3) {
            e4[t3] = r5[t3];
          });
        }
      }), e4;
    }, e3.isString = function(e4) {
      return "[object String]" === function(e5) {
        return Object.prototype.toString.call(e5);
      }(e4);
    }, e3.has = o4, e3.unescapeMd = function(e4) {
      return e4.indexOf("\\") < 0 ? e4 : e4.replace(c3, "$1");
    }, e3.unescapeAll = function(e4) {
      return e4.indexOf("\\") < 0 && e4.indexOf("&") < 0 ? e4 : e4.replace(l4, function(e5, r4, t3) {
        return r4 || function(e6, r5) {
          var t4 = 0;
          return o4(p3, r5) ? p3[r5] : 35 === r5.charCodeAt(0) && u4.test(r5) && i4(t4 = "x" === r5[1].toLowerCase() ? parseInt(r5.slice(2), 16) : parseInt(r5.slice(1), 10)) ? a4(t4) : e6;
        }(e5, t3);
      });
    }, e3.isValidEntityCode = i4, e3.fromCodePoint = a4, e3.escapeHtml = function(e4) {
      return h3.test(e4) ? e4.replace(f4, m3) : e4;
    }, e3.arrayReplaceAt = function(e4, r4, t3) {
      return [].concat(e4.slice(0, r4), t3, e4.slice(r4 + 1));
    }, e3.isSpace = function(e4) {
      switch (e4) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }, e3.isWhiteSpace = function(e4) {
      if (e4 >= 8192 && e4 <= 8202)
        return true;
      switch (e4) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }, e3.isMdAsciiPunct = function(e4) {
      switch (e4) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }, e3.isPunctChar = function(e4) {
      return _4.test(e4);
    }, e3.escapeRE = function(e4) {
      return e4.replace(g4, "\\$&");
    }, e3.normalizeReference = function(e4) {
      return e4 = e4.trim().replace(/\s+/g, " "), "\u1E7E" === "\u1E9E".toLowerCase() && (e4 = e4.replace(//g, "\xDF")), e4.toLowerCase().toUpperCase();
    };
  }(r);
  var q = {};
  var S = r.unescapeAll;
  var F = r.unescapeAll;
  q.parseLinkLabel = function(e3, r3, t3) {
    var n3, s3, o4, i4, a4 = -1, c3 = e3.posMax, l4 = e3.pos;
    for (e3.pos = r3 + 1, n3 = 1; e3.pos < c3; ) {
      if (93 === (o4 = e3.src.charCodeAt(e3.pos)) && 0 === --n3) {
        s3 = true;
        break;
      }
      if (i4 = e3.pos, e3.md.inline.skipToken(e3), 91 === o4) {
        if (i4 === e3.pos - 1)
          n3++;
        else if (t3)
          return e3.pos = l4, -1;
      }
    }
    return s3 && (a4 = e3.pos), e3.pos = l4, a4;
  }, q.parseLinkDestination = function(e3, r3, t3) {
    var n3, s3, o4 = r3, i4 = { ok: false, pos: 0, lines: 0, str: "" };
    if (60 === e3.charCodeAt(r3)) {
      for (r3++; r3 < t3; ) {
        if (10 === (n3 = e3.charCodeAt(r3)))
          return i4;
        if (60 === n3)
          return i4;
        if (62 === n3)
          return i4.pos = r3 + 1, i4.str = S(e3.slice(o4 + 1, r3)), i4.ok = true, i4;
        92 === n3 && r3 + 1 < t3 ? r3 += 2 : r3++;
      }
      return i4;
    }
    for (s3 = 0; r3 < t3 && 32 !== (n3 = e3.charCodeAt(r3)) && !(n3 < 32 || 127 === n3); )
      if (92 === n3 && r3 + 1 < t3) {
        if (32 === e3.charCodeAt(r3 + 1))
          break;
        r3 += 2;
      } else {
        if (40 === n3 && ++s3 > 32)
          return i4;
        if (41 === n3) {
          if (0 === s3)
            break;
          s3--;
        }
        r3++;
      }
    return o4 === r3 || 0 !== s3 || (i4.str = S(e3.slice(o4, r3)), i4.lines = 0, i4.pos = r3, i4.ok = true), i4;
  }, q.parseLinkTitle = function(e3, r3, t3) {
    var n3, s3, o4 = 0, i4 = r3, a4 = { ok: false, pos: 0, lines: 0, str: "" };
    if (r3 >= t3)
      return a4;
    if (34 !== (s3 = e3.charCodeAt(r3)) && 39 !== s3 && 40 !== s3)
      return a4;
    for (r3++, 40 === s3 && (s3 = 41); r3 < t3; ) {
      if ((n3 = e3.charCodeAt(r3)) === s3)
        return a4.pos = r3 + 1, a4.lines = o4, a4.str = F(e3.slice(i4 + 1, r3)), a4.ok = true, a4;
      if (40 === n3 && 41 === s3)
        return a4;
      10 === n3 ? o4++ : 92 === n3 && r3 + 1 < t3 && (r3++, 10 === e3.charCodeAt(r3) && o4++), r3++;
    }
    return a4;
  };
  var L = r.assign;
  var z = r.unescapeAll;
  var T = r.escapeHtml;
  var I = {};
  function M() {
    this.rules = L({}, I);
  }
  I.code_inline = function(e3, r3, t3, n3, s3) {
    var o4 = e3[r3];
    return "<code" + s3.renderAttrs(o4) + ">" + T(e3[r3].content) + "</code>";
  }, I.code_block = function(e3, r3, t3, n3, s3) {
    var o4 = e3[r3];
    return "<pre" + s3.renderAttrs(o4) + "><code>" + T(e3[r3].content) + "</code></pre>\n";
  }, I.fence = function(e3, r3, t3, n3, s3) {
    var o4, i4, a4, c3, l4, u4 = e3[r3], p3 = u4.info ? z(u4.info).trim() : "", h3 = "", f4 = "";
    return p3 && (h3 = (a4 = p3.split(/(\s+)/g))[0], f4 = a4.slice(2).join("")), 0 === (o4 = t3.highlight && t3.highlight(u4.content, h3, f4) || T(u4.content)).indexOf("<pre") ? o4 + "\n" : p3 ? (i4 = u4.attrIndex("class"), c3 = u4.attrs ? u4.attrs.slice() : [], i4 < 0 ? c3.push(["class", t3.langPrefix + h3]) : (c3[i4] = c3[i4].slice(), c3[i4][1] += " " + t3.langPrefix + h3), l4 = { attrs: c3 }, "<pre><code" + s3.renderAttrs(l4) + ">" + o4 + "</code></pre>\n") : "<pre><code" + s3.renderAttrs(u4) + ">" + o4 + "</code></pre>\n";
  }, I.image = function(e3, r3, t3, n3, s3) {
    var o4 = e3[r3];
    return o4.attrs[o4.attrIndex("alt")][1] = s3.renderInlineAsText(o4.children, t3, n3), s3.renderToken(e3, r3, t3);
  }, I.hardbreak = function(e3, r3, t3) {
    return t3.xhtmlOut ? "<br />\n" : "<br>\n";
  }, I.softbreak = function(e3, r3, t3) {
    return t3.breaks ? t3.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  }, I.text = function(e3, r3) {
    return T(e3[r3].content);
  }, I.html_block = function(e3, r3) {
    return e3[r3].content;
  }, I.html_inline = function(e3, r3) {
    return e3[r3].content;
  }, M.prototype.renderAttrs = function(e3) {
    var r3, t3, n3;
    if (!e3.attrs)
      return "";
    for (n3 = "", r3 = 0, t3 = e3.attrs.length; r3 < t3; r3++)
      n3 += " " + T(e3.attrs[r3][0]) + '="' + T(e3.attrs[r3][1]) + '"';
    return n3;
  }, M.prototype.renderToken = function(e3, r3, t3) {
    var n3, s3 = "", o4 = false, i4 = e3[r3];
    return i4.hidden ? "" : (i4.block && -1 !== i4.nesting && r3 && e3[r3 - 1].hidden && (s3 += "\n"), s3 += (-1 === i4.nesting ? "</" : "<") + i4.tag, s3 += this.renderAttrs(i4), 0 === i4.nesting && t3.xhtmlOut && (s3 += " /"), i4.block && (o4 = true, 1 === i4.nesting && r3 + 1 < e3.length && ("inline" === (n3 = e3[r3 + 1]).type || n3.hidden || -1 === n3.nesting && n3.tag === i4.tag) && (o4 = false)), s3 += o4 ? ">\n" : ">");
  }, M.prototype.renderInline = function(e3, r3, t3) {
    for (var n3, s3 = "", o4 = this.rules, i4 = 0, a4 = e3.length; i4 < a4; i4++)
      void 0 !== o4[n3 = e3[i4].type] ? s3 += o4[n3](e3, i4, r3, t3, this) : s3 += this.renderToken(e3, i4, r3);
    return s3;
  }, M.prototype.renderInlineAsText = function(e3, r3, t3) {
    for (var n3 = "", s3 = 0, o4 = e3.length; s3 < o4; s3++)
      "text" === e3[s3].type ? n3 += e3[s3].content : "image" === e3[s3].type ? n3 += this.renderInlineAsText(e3[s3].children, r3, t3) : "softbreak" === e3[s3].type && (n3 += "\n");
    return n3;
  }, M.prototype.render = function(e3, r3, t3) {
    var n3, s3, o4, i4 = "", a4 = this.rules;
    for (n3 = 0, s3 = e3.length; n3 < s3; n3++)
      "inline" === (o4 = e3[n3].type) ? i4 += this.renderInline(e3[n3].children, r3, t3) : void 0 !== a4[o4] ? i4 += a4[e3[n3].type](e3, n3, r3, t3, this) : i4 += this.renderToken(e3, n3, r3, t3);
    return i4;
  };
  var R = M;
  function B() {
    this.__rules__ = [], this.__cache__ = null;
  }
  B.prototype.__find__ = function(e3) {
    for (var r3 = 0; r3 < this.__rules__.length; r3++)
      if (this.__rules__[r3].name === e3)
        return r3;
    return -1;
  }, B.prototype.__compile__ = function() {
    var e3 = this, r3 = [""];
    e3.__rules__.forEach(function(e4) {
      e4.enabled && e4.alt.forEach(function(e5) {
        r3.indexOf(e5) < 0 && r3.push(e5);
      });
    }), e3.__cache__ = {}, r3.forEach(function(r4) {
      e3.__cache__[r4] = [], e3.__rules__.forEach(function(t3) {
        t3.enabled && (r4 && t3.alt.indexOf(r4) < 0 || e3.__cache__[r4].push(t3.fn));
      });
    });
  }, B.prototype.at = function(e3, r3, t3) {
    var n3 = this.__find__(e3), s3 = t3 || {};
    if (-1 === n3)
      throw new Error("Parser rule not found: " + e3);
    this.__rules__[n3].fn = r3, this.__rules__[n3].alt = s3.alt || [], this.__cache__ = null;
  }, B.prototype.before = function(e3, r3, t3, n3) {
    var s3 = this.__find__(e3), o4 = n3 || {};
    if (-1 === s3)
      throw new Error("Parser rule not found: " + e3);
    this.__rules__.splice(s3, 0, { name: r3, enabled: true, fn: t3, alt: o4.alt || [] }), this.__cache__ = null;
  }, B.prototype.after = function(e3, r3, t3, n3) {
    var s3 = this.__find__(e3), o4 = n3 || {};
    if (-1 === s3)
      throw new Error("Parser rule not found: " + e3);
    this.__rules__.splice(s3 + 1, 0, { name: r3, enabled: true, fn: t3, alt: o4.alt || [] }), this.__cache__ = null;
  }, B.prototype.push = function(e3, r3, t3) {
    var n3 = t3 || {};
    this.__rules__.push({ name: e3, enabled: true, fn: r3, alt: n3.alt || [] }), this.__cache__ = null;
  }, B.prototype.enable = function(e3, r3) {
    Array.isArray(e3) || (e3 = [e3]);
    var t3 = [];
    return e3.forEach(function(e4) {
      var n3 = this.__find__(e4);
      if (n3 < 0) {
        if (r3)
          return;
        throw new Error("Rules manager: invalid rule name " + e4);
      }
      this.__rules__[n3].enabled = true, t3.push(e4);
    }, this), this.__cache__ = null, t3;
  }, B.prototype.enableOnly = function(e3, r3) {
    Array.isArray(e3) || (e3 = [e3]), this.__rules__.forEach(function(e4) {
      e4.enabled = false;
    }), this.enable(e3, r3);
  }, B.prototype.disable = function(e3, r3) {
    Array.isArray(e3) || (e3 = [e3]);
    var t3 = [];
    return e3.forEach(function(e4) {
      var n3 = this.__find__(e4);
      if (n3 < 0) {
        if (r3)
          return;
        throw new Error("Rules manager: invalid rule name " + e4);
      }
      this.__rules__[n3].enabled = false, t3.push(e4);
    }, this), this.__cache__ = null, t3;
  }, B.prototype.getRules = function(e3) {
    return null === this.__cache__ && this.__compile__(), this.__cache__[e3] || [];
  };
  var N = B;
  var O = /\r\n?|\n/g;
  var P = /\0/g;
  var j = r.arrayReplaceAt;
  function U(e3) {
    return /^<\/a\s*>/i.test(e3);
  }
  var V = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  var Z = /\((c|tm|r)\)/i;
  var $ = /\((c|tm|r)\)/gi;
  var G = { c: "\xA9", r: "\xAE", tm: "\u2122" };
  function H(e3, r3) {
    return G[r3.toLowerCase()];
  }
  function J(e3) {
    var r3, t3, n3 = 0;
    for (r3 = e3.length - 1; r3 >= 0; r3--)
      "text" !== (t3 = e3[r3]).type || n3 || (t3.content = t3.content.replace($, H)), "link_open" === t3.type && "auto" === t3.info && n3--, "link_close" === t3.type && "auto" === t3.info && n3++;
  }
  function W(e3) {
    var r3, t3, n3 = 0;
    for (r3 = e3.length - 1; r3 >= 0; r3--)
      "text" !== (t3 = e3[r3]).type || n3 || V.test(t3.content) && (t3.content = t3.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/gm, "$1\u2014").replace(/(^|\s)--(?=\s|$)/gm, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, "$1\u2013")), "link_open" === t3.type && "auto" === t3.info && n3--, "link_close" === t3.type && "auto" === t3.info && n3++;
  }
  var Y = r.isWhiteSpace;
  var K = r.isPunctChar;
  var Q = r.isMdAsciiPunct;
  var X = /['"]/;
  var ee = /['"]/g;
  function re(e3, r3, t3) {
    return e3.slice(0, r3) + t3 + e3.slice(r3 + 1);
  }
  function te(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3, v3, C3, y3;
    for (v3 = [], t3 = 0; t3 < e3.length; t3++) {
      for (n3 = e3[t3], c3 = e3[t3].level, k4 = v3.length - 1; k4 >= 0 && !(v3[k4].level <= c3); k4--)
        ;
      if (v3.length = k4 + 1, "text" === n3.type) {
        i4 = 0, a4 = (s3 = n3.content).length;
        e:
          for (; i4 < a4 && (ee.lastIndex = i4, o4 = ee.exec(s3)); ) {
            if (g4 = _4 = true, i4 = o4.index + 1, b3 = "'" === o4[0], u4 = 32, o4.index - 1 >= 0)
              u4 = s3.charCodeAt(o4.index - 1);
            else
              for (k4 = t3 - 1; k4 >= 0 && ("softbreak" !== e3[k4].type && "hardbreak" !== e3[k4].type); k4--)
                if (e3[k4].content) {
                  u4 = e3[k4].content.charCodeAt(e3[k4].content.length - 1);
                  break;
                }
            if (p3 = 32, i4 < a4)
              p3 = s3.charCodeAt(i4);
            else
              for (k4 = t3 + 1; k4 < e3.length && ("softbreak" !== e3[k4].type && "hardbreak" !== e3[k4].type); k4++)
                if (e3[k4].content) {
                  p3 = e3[k4].content.charCodeAt(0);
                  break;
                }
            if (h3 = Q(u4) || K(String.fromCharCode(u4)), f4 = Q(p3) || K(String.fromCharCode(p3)), d3 = Y(u4), (m3 = Y(p3)) ? g4 = false : f4 && (d3 || h3 || (g4 = false)), d3 ? _4 = false : h3 && (m3 || f4 || (_4 = false)), 34 === p3 && '"' === o4[0] && u4 >= 48 && u4 <= 57 && (_4 = g4 = false), g4 && _4 && (g4 = h3, _4 = f4), g4 || _4) {
              if (_4) {
                for (k4 = v3.length - 1; k4 >= 0 && (l4 = v3[k4], !(v3[k4].level < c3)); k4--)
                  if (l4.single === b3 && v3[k4].level === c3) {
                    l4 = v3[k4], b3 ? (C3 = r3.md.options.quotes[2], y3 = r3.md.options.quotes[3]) : (C3 = r3.md.options.quotes[0], y3 = r3.md.options.quotes[1]), n3.content = re(n3.content, o4.index, y3), e3[l4.token].content = re(e3[l4.token].content, l4.pos, C3), i4 += y3.length - 1, l4.token === t3 && (i4 += C3.length - 1), a4 = (s3 = n3.content).length, v3.length = k4;
                    continue e;
                  }
              }
              g4 ? v3.push({ token: t3, pos: o4.index, single: b3, level: c3 }) : _4 && b3 && (n3.content = re(n3.content, o4.index, "\u2019"));
            } else
              b3 && (n3.content = re(n3.content, o4.index, "\u2019"));
          }
      }
    }
  }
  function ne(e3, r3, t3) {
    this.type = e3, this.tag = r3, this.attrs = null, this.map = null, this.nesting = t3, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
  }
  ne.prototype.attrIndex = function(e3) {
    var r3, t3, n3;
    if (!this.attrs)
      return -1;
    for (t3 = 0, n3 = (r3 = this.attrs).length; t3 < n3; t3++)
      if (r3[t3][0] === e3)
        return t3;
    return -1;
  }, ne.prototype.attrPush = function(e3) {
    this.attrs ? this.attrs.push(e3) : this.attrs = [e3];
  }, ne.prototype.attrSet = function(e3, r3) {
    var t3 = this.attrIndex(e3), n3 = [e3, r3];
    t3 < 0 ? this.attrPush(n3) : this.attrs[t3] = n3;
  }, ne.prototype.attrGet = function(e3) {
    var r3 = this.attrIndex(e3), t3 = null;
    return r3 >= 0 && (t3 = this.attrs[r3][1]), t3;
  }, ne.prototype.attrJoin = function(e3, r3) {
    var t3 = this.attrIndex(e3);
    t3 < 0 ? this.attrPush([e3, r3]) : this.attrs[t3][1] = this.attrs[t3][1] + " " + r3;
  };
  var se = ne;
  var oe = se;
  function ie(e3, r3, t3) {
    this.src = e3, this.env = t3, this.tokens = [], this.inlineMode = false, this.md = r3;
  }
  ie.prototype.Token = oe;
  var ae = ie;
  var ce = N;
  var le = [["normalize", function(e3) {
    var r3;
    r3 = (r3 = e3.src.replace(O, "\n")).replace(P, "\uFFFD"), e3.src = r3;
  }], ["block", function(e3) {
    var r3;
    e3.inlineMode ? ((r3 = new e3.Token("inline", "", 0)).content = e3.src, r3.map = [0, 1], r3.children = [], e3.tokens.push(r3)) : e3.md.block.parse(e3.src, e3.md, e3.env, e3.tokens);
  }], ["inline", function(e3) {
    var r3, t3, n3, s3 = e3.tokens;
    for (t3 = 0, n3 = s3.length; t3 < n3; t3++)
      "inline" === (r3 = s3[t3]).type && e3.md.inline.parse(r3.content, e3.md, e3.env, r3.children);
  }], ["linkify", function(e3) {
    var r3, t3, n3, s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3 = e3.tokens;
    if (e3.md.options.linkify) {
      for (t3 = 0, n3 = b3.length; t3 < n3; t3++)
        if ("inline" === b3[t3].type && e3.md.linkify.pretest(b3[t3].content))
          for (f4 = 0, r3 = (s3 = b3[t3].children).length - 1; r3 >= 0; r3--)
            if ("link_close" !== (i4 = s3[r3]).type) {
              if ("html_inline" === i4.type && (k4 = i4.content, /^<a[>\s]/i.test(k4) && f4 > 0 && f4--, U(i4.content) && f4++), !(f4 > 0) && "text" === i4.type && e3.md.linkify.test(i4.content)) {
                for (l4 = i4.content, _4 = e3.md.linkify.match(l4), a4 = [], h3 = i4.level, p3 = 0, _4.length > 0 && 0 === _4[0].index && r3 > 0 && "text_special" === s3[r3 - 1].type && (_4 = _4.slice(1)), c3 = 0; c3 < _4.length; c3++)
                  d3 = _4[c3].url, m3 = e3.md.normalizeLink(d3), e3.md.validateLink(m3) && (g4 = _4[c3].text, g4 = _4[c3].schema ? "mailto:" !== _4[c3].schema || /^mailto:/i.test(g4) ? e3.md.normalizeLinkText(g4) : e3.md.normalizeLinkText("mailto:" + g4).replace(/^mailto:/, "") : e3.md.normalizeLinkText("http://" + g4).replace(/^http:\/\//, ""), (u4 = _4[c3].index) > p3 && ((o4 = new e3.Token("text", "", 0)).content = l4.slice(p3, u4), o4.level = h3, a4.push(o4)), (o4 = new e3.Token("link_open", "a", 1)).attrs = [["href", m3]], o4.level = h3++, o4.markup = "linkify", o4.info = "auto", a4.push(o4), (o4 = new e3.Token("text", "", 0)).content = g4, o4.level = h3, a4.push(o4), (o4 = new e3.Token("link_close", "a", -1)).level = --h3, o4.markup = "linkify", o4.info = "auto", a4.push(o4), p3 = _4[c3].lastIndex);
                p3 < l4.length && ((o4 = new e3.Token("text", "", 0)).content = l4.slice(p3), o4.level = h3, a4.push(o4)), b3[t3].children = s3 = j(s3, r3, a4);
              }
            } else
              for (r3--; s3[r3].level !== i4.level && "link_open" !== s3[r3].type; )
                r3--;
    }
  }], ["replacements", function(e3) {
    var r3;
    if (e3.md.options.typographer)
      for (r3 = e3.tokens.length - 1; r3 >= 0; r3--)
        "inline" === e3.tokens[r3].type && (Z.test(e3.tokens[r3].content) && J(e3.tokens[r3].children), V.test(e3.tokens[r3].content) && W(e3.tokens[r3].children));
  }], ["smartquotes", function(e3) {
    var r3;
    if (e3.md.options.typographer)
      for (r3 = e3.tokens.length - 1; r3 >= 0; r3--)
        "inline" === e3.tokens[r3].type && X.test(e3.tokens[r3].content) && te(e3.tokens[r3].children, e3);
  }], ["text_join", function(e3) {
    var r3, t3, n3, s3, o4, i4, a4 = e3.tokens;
    for (r3 = 0, t3 = a4.length; r3 < t3; r3++)
      if ("inline" === a4[r3].type) {
        for (o4 = (n3 = a4[r3].children).length, s3 = 0; s3 < o4; s3++)
          "text_special" === n3[s3].type && (n3[s3].type = "text");
        for (s3 = i4 = 0; s3 < o4; s3++)
          "text" === n3[s3].type && s3 + 1 < o4 && "text" === n3[s3 + 1].type ? n3[s3 + 1].content = n3[s3].content + n3[s3 + 1].content : (s3 !== i4 && (n3[i4] = n3[s3]), i4++);
        s3 !== i4 && (n3.length = i4);
      }
  }]];
  function ue() {
    this.ruler = new ce();
    for (var e3 = 0; e3 < le.length; e3++)
      this.ruler.push(le[e3][0], le[e3][1]);
  }
  ue.prototype.process = function(e3) {
    var r3, t3, n3;
    for (r3 = 0, t3 = (n3 = this.ruler.getRules("")).length; r3 < t3; r3++)
      n3[r3](e3);
  }, ue.prototype.State = ae;
  var pe = ue;
  var he = r.isSpace;
  function fe(e3, r3) {
    var t3 = e3.bMarks[r3] + e3.tShift[r3], n3 = e3.eMarks[r3];
    return e3.src.slice(t3, n3);
  }
  function de(e3) {
    var r3, t3 = [], n3 = 0, s3 = e3.length, o4 = false, i4 = 0, a4 = "";
    for (r3 = e3.charCodeAt(n3); n3 < s3; )
      124 === r3 && (o4 ? (a4 += e3.substring(i4, n3 - 1), i4 = n3) : (t3.push(a4 + e3.substring(i4, n3)), a4 = "", i4 = n3 + 1)), o4 = 92 === r3, n3++, r3 = e3.charCodeAt(n3);
    return t3.push(a4 + e3.substring(i4)), t3;
  }
  var me = r.isSpace;
  var ge = r.isSpace;
  var _e = r.isSpace;
  function ke(e3, r3) {
    var t3, n3, s3, o4;
    return n3 = e3.bMarks[r3] + e3.tShift[r3], s3 = e3.eMarks[r3], 42 !== (t3 = e3.src.charCodeAt(n3++)) && 45 !== t3 && 43 !== t3 || n3 < s3 && (o4 = e3.src.charCodeAt(n3), !_e(o4)) ? -1 : n3;
  }
  function be(e3, r3) {
    var t3, n3 = e3.bMarks[r3] + e3.tShift[r3], s3 = n3, o4 = e3.eMarks[r3];
    if (s3 + 1 >= o4)
      return -1;
    if ((t3 = e3.src.charCodeAt(s3++)) < 48 || t3 > 57)
      return -1;
    for (; ; ) {
      if (s3 >= o4)
        return -1;
      if (!((t3 = e3.src.charCodeAt(s3++)) >= 48 && t3 <= 57)) {
        if (41 === t3 || 46 === t3)
          break;
        return -1;
      }
      if (s3 - n3 >= 10)
        return -1;
    }
    return s3 < o4 && (t3 = e3.src.charCodeAt(s3), !_e(t3)) ? -1 : s3;
  }
  var ve = r.normalizeReference;
  var Ce = r.isSpace;
  var ye = {};
  var Ae = `<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^"'=<>\`\\x00-\\x20]+|'[^']*'|"[^"]*"))?)*\\s*\\/?>`;
  var xe = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var De = new RegExp("^(?:" + Ae + "|" + xe + "|<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->|<[?][\\s\\S]*?[?]>|<![A-Z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)");
  var we = new RegExp("^(?:" + Ae + "|" + xe + ")");
  ye.HTML_TAG_RE = De, ye.HTML_OPEN_CLOSE_TAG_RE = we;
  var Ee = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"];
  var qe = ye.HTML_OPEN_CLOSE_TAG_RE;
  var Se = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + Ee.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(qe.source + "\\s*$"), /^$/, false]];
  var Fe = r.isSpace;
  var Le = se;
  var ze = r.isSpace;
  function Te(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3;
    for (this.src = e3, this.md = r3, this.env = t3, this.tokens = n3, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", p3 = false, i4 = a4 = l4 = u4 = 0, c3 = (o4 = this.src).length; a4 < c3; a4++) {
      if (s3 = o4.charCodeAt(a4), !p3) {
        if (ze(s3)) {
          l4++, 9 === s3 ? u4 += 4 - u4 % 4 : u4++;
          continue;
        }
        p3 = true;
      }
      10 !== s3 && a4 !== c3 - 1 || (10 !== s3 && a4++, this.bMarks.push(i4), this.eMarks.push(a4), this.tShift.push(l4), this.sCount.push(u4), this.bsCount.push(0), p3 = false, l4 = 0, u4 = 0, i4 = a4 + 1);
    }
    this.bMarks.push(o4.length), this.eMarks.push(o4.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
  }
  Te.prototype.push = function(e3, r3, t3) {
    var n3 = new Le(e3, r3, t3);
    return n3.block = true, t3 < 0 && this.level--, n3.level = this.level, t3 > 0 && this.level++, this.tokens.push(n3), n3;
  }, Te.prototype.isEmpty = function(e3) {
    return this.bMarks[e3] + this.tShift[e3] >= this.eMarks[e3];
  }, Te.prototype.skipEmptyLines = function(e3) {
    for (var r3 = this.lineMax; e3 < r3 && !(this.bMarks[e3] + this.tShift[e3] < this.eMarks[e3]); e3++)
      ;
    return e3;
  }, Te.prototype.skipSpaces = function(e3) {
    for (var r3, t3 = this.src.length; e3 < t3 && (r3 = this.src.charCodeAt(e3), ze(r3)); e3++)
      ;
    return e3;
  }, Te.prototype.skipSpacesBack = function(e3, r3) {
    if (e3 <= r3)
      return e3;
    for (; e3 > r3; )
      if (!ze(this.src.charCodeAt(--e3)))
        return e3 + 1;
    return e3;
  }, Te.prototype.skipChars = function(e3, r3) {
    for (var t3 = this.src.length; e3 < t3 && this.src.charCodeAt(e3) === r3; e3++)
      ;
    return e3;
  }, Te.prototype.skipCharsBack = function(e3, r3, t3) {
    if (e3 <= t3)
      return e3;
    for (; e3 > t3; )
      if (r3 !== this.src.charCodeAt(--e3))
        return e3 + 1;
    return e3;
  }, Te.prototype.getLines = function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3 = e3;
    if (e3 >= r3)
      return "";
    for (l4 = new Array(r3 - e3), s3 = 0; p3 < r3; p3++, s3++) {
      for (o4 = 0, u4 = a4 = this.bMarks[p3], c3 = p3 + 1 < r3 || n3 ? this.eMarks[p3] + 1 : this.eMarks[p3]; a4 < c3 && o4 < t3; ) {
        if (i4 = this.src.charCodeAt(a4), ze(i4))
          9 === i4 ? o4 += 4 - (o4 + this.bsCount[p3]) % 4 : o4++;
        else {
          if (!(a4 - u4 < this.tShift[p3]))
            break;
          o4++;
        }
        a4++;
      }
      l4[s3] = o4 > t3 ? new Array(o4 - t3 + 1).join(" ") + this.src.slice(a4, c3) : this.src.slice(a4, c3);
    }
    return l4.join("");
  }, Te.prototype.Token = Le;
  var Ie = Te;
  var Me = N;
  var Re = [["table", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3, v3, C3;
    if (r3 + 2 > t3)
      return false;
    if (l4 = r3 + 1, e3.sCount[l4] < e3.blkIndent)
      return false;
    if (e3.sCount[l4] - e3.blkIndent >= 4)
      return false;
    if ((i4 = e3.bMarks[l4] + e3.tShift[l4]) >= e3.eMarks[l4])
      return false;
    if (124 !== (v3 = e3.src.charCodeAt(i4++)) && 45 !== v3 && 58 !== v3)
      return false;
    if (i4 >= e3.eMarks[l4])
      return false;
    if (124 !== (C3 = e3.src.charCodeAt(i4++)) && 45 !== C3 && 58 !== C3 && !he(C3))
      return false;
    if (45 === v3 && he(C3))
      return false;
    for (; i4 < e3.eMarks[l4]; ) {
      if (124 !== (s3 = e3.src.charCodeAt(i4)) && 45 !== s3 && 58 !== s3 && !he(s3))
        return false;
      i4++;
    }
    for (u4 = (o4 = fe(e3, r3 + 1)).split("|"), f4 = [], a4 = 0; a4 < u4.length; a4++) {
      if (!(d3 = u4[a4].trim())) {
        if (0 === a4 || a4 === u4.length - 1)
          continue;
        return false;
      }
      if (!/^:?-+:?$/.test(d3))
        return false;
      58 === d3.charCodeAt(d3.length - 1) ? f4.push(58 === d3.charCodeAt(0) ? "center" : "right") : 58 === d3.charCodeAt(0) ? f4.push("left") : f4.push("");
    }
    if (-1 === (o4 = fe(e3, r3).trim()).indexOf("|"))
      return false;
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if ((u4 = de(o4)).length && "" === u4[0] && u4.shift(), u4.length && "" === u4[u4.length - 1] && u4.pop(), 0 === (p3 = u4.length) || p3 !== f4.length)
      return false;
    if (n3)
      return true;
    for (_4 = e3.parentType, e3.parentType = "table", b3 = e3.md.block.ruler.getRules("blockquote"), (h3 = e3.push("table_open", "table", 1)).map = m3 = [r3, 0], (h3 = e3.push("thead_open", "thead", 1)).map = [r3, r3 + 1], (h3 = e3.push("tr_open", "tr", 1)).map = [r3, r3 + 1], a4 = 0; a4 < u4.length; a4++)
      h3 = e3.push("th_open", "th", 1), f4[a4] && (h3.attrs = [["style", "text-align:" + f4[a4]]]), (h3 = e3.push("inline", "", 0)).content = u4[a4].trim(), h3.children = [], h3 = e3.push("th_close", "th", -1);
    for (h3 = e3.push("tr_close", "tr", -1), h3 = e3.push("thead_close", "thead", -1), l4 = r3 + 2; l4 < t3 && !(e3.sCount[l4] < e3.blkIndent); l4++) {
      for (k4 = false, a4 = 0, c3 = b3.length; a4 < c3; a4++)
        if (b3[a4](e3, l4, t3, true)) {
          k4 = true;
          break;
        }
      if (k4)
        break;
      if (!(o4 = fe(e3, l4).trim()))
        break;
      if (e3.sCount[l4] - e3.blkIndent >= 4)
        break;
      for ((u4 = de(o4)).length && "" === u4[0] && u4.shift(), u4.length && "" === u4[u4.length - 1] && u4.pop(), l4 === r3 + 2 && ((h3 = e3.push("tbody_open", "tbody", 1)).map = g4 = [r3 + 2, 0]), (h3 = e3.push("tr_open", "tr", 1)).map = [l4, l4 + 1], a4 = 0; a4 < p3; a4++)
        h3 = e3.push("td_open", "td", 1), f4[a4] && (h3.attrs = [["style", "text-align:" + f4[a4]]]), (h3 = e3.push("inline", "", 0)).content = u4[a4] ? u4[a4].trim() : "", h3.children = [], h3 = e3.push("td_close", "td", -1);
      h3 = e3.push("tr_close", "tr", -1);
    }
    return g4 && (h3 = e3.push("tbody_close", "tbody", -1), g4[1] = l4), h3 = e3.push("table_close", "table", -1), m3[1] = l4, e3.parentType = _4, e3.line = l4, true;
  }, ["paragraph", "reference"]], ["code", function(e3, r3, t3) {
    var n3, s3, o4;
    if (e3.sCount[r3] - e3.blkIndent < 4)
      return false;
    for (s3 = n3 = r3 + 1; n3 < t3; )
      if (e3.isEmpty(n3))
        n3++;
      else {
        if (!(e3.sCount[n3] - e3.blkIndent >= 4))
          break;
        s3 = ++n3;
      }
    return e3.line = s3, (o4 = e3.push("code_block", "code", 0)).content = e3.getLines(r3, s3, 4 + e3.blkIndent, false) + "\n", o4.map = [r3, e3.line], true;
  }], ["fence", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3 = false, h3 = e3.bMarks[r3] + e3.tShift[r3], f4 = e3.eMarks[r3];
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (h3 + 3 > f4)
      return false;
    if (126 !== (s3 = e3.src.charCodeAt(h3)) && 96 !== s3)
      return false;
    if (c3 = h3, (o4 = (h3 = e3.skipChars(h3, s3)) - c3) < 3)
      return false;
    if (u4 = e3.src.slice(c3, h3), i4 = e3.src.slice(h3, f4), 96 === s3 && i4.indexOf(String.fromCharCode(s3)) >= 0)
      return false;
    if (n3)
      return true;
    for (a4 = r3; !(++a4 >= t3) && !((h3 = c3 = e3.bMarks[a4] + e3.tShift[a4]) < (f4 = e3.eMarks[a4]) && e3.sCount[a4] < e3.blkIndent); )
      if (e3.src.charCodeAt(h3) === s3 && !(e3.sCount[a4] - e3.blkIndent >= 4 || (h3 = e3.skipChars(h3, s3)) - c3 < o4 || (h3 = e3.skipSpaces(h3)) < f4)) {
        p3 = true;
        break;
      }
    return o4 = e3.sCount[r3], e3.line = a4 + (p3 ? 1 : 0), (l4 = e3.push("fence", "code", 0)).info = i4, l4.content = e3.getLines(r3 + 1, a4, o4, true), l4.markup = u4, l4.map = [r3, e3.line], true;
  }, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3, v3, C3, y3, A4, x3 = e3.lineMax, D4 = e3.bMarks[r3] + e3.tShift[r3], w3 = e3.eMarks[r3];
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (62 !== e3.src.charCodeAt(D4++))
      return false;
    if (n3)
      return true;
    for (a4 = h3 = e3.sCount[r3] + 1, 32 === e3.src.charCodeAt(D4) ? (D4++, a4++, h3++, s3 = false, b3 = true) : 9 === e3.src.charCodeAt(D4) ? (b3 = true, (e3.bsCount[r3] + h3) % 4 == 3 ? (D4++, a4++, h3++, s3 = false) : s3 = true) : b3 = false, f4 = [e3.bMarks[r3]], e3.bMarks[r3] = D4; D4 < w3 && (o4 = e3.src.charCodeAt(D4), me(o4)); )
      9 === o4 ? h3 += 4 - (h3 + e3.bsCount[r3] + (s3 ? 1 : 0)) % 4 : h3++, D4++;
    for (d3 = [e3.bsCount[r3]], e3.bsCount[r3] = e3.sCount[r3] + 1 + (b3 ? 1 : 0), l4 = D4 >= w3, _4 = [e3.sCount[r3]], e3.sCount[r3] = h3 - a4, k4 = [e3.tShift[r3]], e3.tShift[r3] = D4 - e3.bMarks[r3], C3 = e3.md.block.ruler.getRules("blockquote"), g4 = e3.parentType, e3.parentType = "blockquote", p3 = r3 + 1; p3 < t3 && (A4 = e3.sCount[p3] < e3.blkIndent, !((D4 = e3.bMarks[p3] + e3.tShift[p3]) >= (w3 = e3.eMarks[p3]))); p3++)
      if (62 !== e3.src.charCodeAt(D4++) || A4) {
        if (l4)
          break;
        for (v3 = false, i4 = 0, c3 = C3.length; i4 < c3; i4++)
          if (C3[i4](e3, p3, t3, true)) {
            v3 = true;
            break;
          }
        if (v3) {
          e3.lineMax = p3, 0 !== e3.blkIndent && (f4.push(e3.bMarks[p3]), d3.push(e3.bsCount[p3]), k4.push(e3.tShift[p3]), _4.push(e3.sCount[p3]), e3.sCount[p3] -= e3.blkIndent);
          break;
        }
        f4.push(e3.bMarks[p3]), d3.push(e3.bsCount[p3]), k4.push(e3.tShift[p3]), _4.push(e3.sCount[p3]), e3.sCount[p3] = -1;
      } else {
        for (a4 = h3 = e3.sCount[p3] + 1, 32 === e3.src.charCodeAt(D4) ? (D4++, a4++, h3++, s3 = false, b3 = true) : 9 === e3.src.charCodeAt(D4) ? (b3 = true, (e3.bsCount[p3] + h3) % 4 == 3 ? (D4++, a4++, h3++, s3 = false) : s3 = true) : b3 = false, f4.push(e3.bMarks[p3]), e3.bMarks[p3] = D4; D4 < w3 && (o4 = e3.src.charCodeAt(D4), me(o4)); )
          9 === o4 ? h3 += 4 - (h3 + e3.bsCount[p3] + (s3 ? 1 : 0)) % 4 : h3++, D4++;
        l4 = D4 >= w3, d3.push(e3.bsCount[p3]), e3.bsCount[p3] = e3.sCount[p3] + 1 + (b3 ? 1 : 0), _4.push(e3.sCount[p3]), e3.sCount[p3] = h3 - a4, k4.push(e3.tShift[p3]), e3.tShift[p3] = D4 - e3.bMarks[p3];
      }
    for (m3 = e3.blkIndent, e3.blkIndent = 0, (y3 = e3.push("blockquote_open", "blockquote", 1)).markup = ">", y3.map = u4 = [r3, 0], e3.md.block.tokenize(e3, r3, p3), (y3 = e3.push("blockquote_close", "blockquote", -1)).markup = ">", e3.lineMax = x3, e3.parentType = g4, u4[1] = e3.line, i4 = 0; i4 < k4.length; i4++)
      e3.bMarks[i4 + r3] = f4[i4], e3.tShift[i4 + r3] = k4[i4], e3.sCount[i4 + r3] = _4[i4], e3.bsCount[i4 + r3] = d3[i4];
    return e3.blkIndent = m3, true;
  }, ["paragraph", "reference", "blockquote", "list"]], ["hr", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3 = e3.bMarks[r3] + e3.tShift[r3], l4 = e3.eMarks[r3];
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (42 !== (s3 = e3.src.charCodeAt(c3++)) && 45 !== s3 && 95 !== s3)
      return false;
    for (o4 = 1; c3 < l4; ) {
      if ((i4 = e3.src.charCodeAt(c3++)) !== s3 && !ge(i4))
        return false;
      i4 === s3 && o4++;
    }
    return !(o4 < 3) && (n3 || (e3.line = r3 + 1, (a4 = e3.push("hr", "hr", 0)).map = [r3, e3.line], a4.markup = Array(o4 + 1).join(String.fromCharCode(s3))), true);
  }, ["paragraph", "reference", "blockquote", "list"]], ["list", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3, v3, C3, y3, A4, x3, D4, w3, E4, q3, S4, F3, L4, z3 = false, T5 = true;
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (e3.listIndent >= 0 && e3.sCount[r3] - e3.listIndent >= 4 && e3.sCount[r3] < e3.blkIndent)
      return false;
    if (n3 && "paragraph" === e3.parentType && e3.sCount[r3] >= e3.blkIndent && (z3 = true), (w3 = be(e3, r3)) >= 0) {
      if (u4 = true, q3 = e3.bMarks[r3] + e3.tShift[r3], g4 = Number(e3.src.slice(q3, w3 - 1)), z3 && 1 !== g4)
        return false;
    } else {
      if (!((w3 = ke(e3, r3)) >= 0))
        return false;
      u4 = false;
    }
    if (z3 && e3.skipSpaces(w3) >= e3.eMarks[r3])
      return false;
    if (m3 = e3.src.charCodeAt(w3 - 1), n3)
      return true;
    for (d3 = e3.tokens.length, u4 ? (L4 = e3.push("ordered_list_open", "ol", 1), 1 !== g4 && (L4.attrs = [["start", g4]])) : L4 = e3.push("bullet_list_open", "ul", 1), L4.map = f4 = [r3, 0], L4.markup = String.fromCharCode(m3), k4 = r3, E4 = false, F3 = e3.md.block.ruler.getRules("list"), C3 = e3.parentType, e3.parentType = "list"; k4 < t3; ) {
      for (D4 = w3, _4 = e3.eMarks[k4], l4 = b3 = e3.sCount[k4] + w3 - (e3.bMarks[r3] + e3.tShift[r3]); D4 < _4; ) {
        if (9 === (s3 = e3.src.charCodeAt(D4)))
          b3 += 4 - (b3 + e3.bsCount[k4]) % 4;
        else {
          if (32 !== s3)
            break;
          b3++;
        }
        D4++;
      }
      if ((c3 = (o4 = D4) >= _4 ? 1 : b3 - l4) > 4 && (c3 = 1), a4 = l4 + c3, (L4 = e3.push("list_item_open", "li", 1)).markup = String.fromCharCode(m3), L4.map = p3 = [r3, 0], u4 && (L4.info = e3.src.slice(q3, w3 - 1)), x3 = e3.tight, A4 = e3.tShift[r3], y3 = e3.sCount[r3], v3 = e3.listIndent, e3.listIndent = e3.blkIndent, e3.blkIndent = a4, e3.tight = true, e3.tShift[r3] = o4 - e3.bMarks[r3], e3.sCount[r3] = b3, o4 >= _4 && e3.isEmpty(r3 + 1) ? e3.line = Math.min(e3.line + 2, t3) : e3.md.block.tokenize(e3, r3, t3, true), e3.tight && !E4 || (T5 = false), E4 = e3.line - r3 > 1 && e3.isEmpty(e3.line - 1), e3.blkIndent = e3.listIndent, e3.listIndent = v3, e3.tShift[r3] = A4, e3.sCount[r3] = y3, e3.tight = x3, (L4 = e3.push("list_item_close", "li", -1)).markup = String.fromCharCode(m3), k4 = r3 = e3.line, p3[1] = k4, o4 = e3.bMarks[r3], k4 >= t3)
        break;
      if (e3.sCount[k4] < e3.blkIndent)
        break;
      if (e3.sCount[r3] - e3.blkIndent >= 4)
        break;
      for (S4 = false, i4 = 0, h3 = F3.length; i4 < h3; i4++)
        if (F3[i4](e3, k4, t3, true)) {
          S4 = true;
          break;
        }
      if (S4)
        break;
      if (u4) {
        if ((w3 = be(e3, k4)) < 0)
          break;
        q3 = e3.bMarks[k4] + e3.tShift[k4];
      } else if ((w3 = ke(e3, k4)) < 0)
        break;
      if (m3 !== e3.src.charCodeAt(w3 - 1))
        break;
    }
    return (L4 = u4 ? e3.push("ordered_list_close", "ol", -1) : e3.push("bullet_list_close", "ul", -1)).markup = String.fromCharCode(m3), f4[1] = k4, e3.line = k4, e3.parentType = C3, T5 && function(e4, r4) {
      var t4, n4, s4 = e4.level + 2;
      for (t4 = r4 + 2, n4 = e4.tokens.length - 2; t4 < n4; t4++)
        e4.tokens[t4].level === s4 && "paragraph_open" === e4.tokens[t4].type && (e4.tokens[t4 + 2].hidden = true, e4.tokens[t4].hidden = true, t4 += 2);
    }(e3, d3), true;
  }, ["paragraph", "reference", "blockquote"]], ["reference", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4, _4, k4, b3, v3 = 0, C3 = e3.bMarks[r3] + e3.tShift[r3], y3 = e3.eMarks[r3], A4 = r3 + 1;
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (91 !== e3.src.charCodeAt(C3))
      return false;
    for (; ++C3 < y3; )
      if (93 === e3.src.charCodeAt(C3) && 92 !== e3.src.charCodeAt(C3 - 1)) {
        if (C3 + 1 === y3)
          return false;
        if (58 !== e3.src.charCodeAt(C3 + 1))
          return false;
        break;
      }
    for (a4 = e3.lineMax, k4 = e3.md.block.ruler.getRules("reference"), f4 = e3.parentType, e3.parentType = "reference"; A4 < a4 && !e3.isEmpty(A4); A4++)
      if (!(e3.sCount[A4] - e3.blkIndent > 3 || e3.sCount[A4] < 0)) {
        for (_4 = false, l4 = 0, u4 = k4.length; l4 < u4; l4++)
          if (k4[l4](e3, A4, a4, true)) {
            _4 = true;
            break;
          }
        if (_4)
          break;
      }
    for (y3 = (g4 = e3.getLines(r3, A4, e3.blkIndent, false).trim()).length, C3 = 1; C3 < y3; C3++) {
      if (91 === (s3 = g4.charCodeAt(C3)))
        return false;
      if (93 === s3) {
        h3 = C3;
        break;
      }
      (10 === s3 || 92 === s3 && ++C3 < y3 && 10 === g4.charCodeAt(C3)) && v3++;
    }
    if (h3 < 0 || 58 !== g4.charCodeAt(h3 + 1))
      return false;
    for (C3 = h3 + 2; C3 < y3; C3++)
      if (10 === (s3 = g4.charCodeAt(C3)))
        v3++;
      else if (!Ce(s3))
        break;
    if (!(d3 = e3.md.helpers.parseLinkDestination(g4, C3, y3)).ok)
      return false;
    if (c3 = e3.md.normalizeLink(d3.str), !e3.md.validateLink(c3))
      return false;
    for (o4 = C3 = d3.pos, i4 = v3 += d3.lines, m3 = C3; C3 < y3; C3++)
      if (10 === (s3 = g4.charCodeAt(C3)))
        v3++;
      else if (!Ce(s3))
        break;
    for (d3 = e3.md.helpers.parseLinkTitle(g4, C3, y3), C3 < y3 && m3 !== C3 && d3.ok ? (b3 = d3.str, C3 = d3.pos, v3 += d3.lines) : (b3 = "", C3 = o4, v3 = i4); C3 < y3 && (s3 = g4.charCodeAt(C3), Ce(s3)); )
      C3++;
    if (C3 < y3 && 10 !== g4.charCodeAt(C3) && b3)
      for (b3 = "", C3 = o4, v3 = i4; C3 < y3 && (s3 = g4.charCodeAt(C3), Ce(s3)); )
        C3++;
    return !(C3 < y3 && 10 !== g4.charCodeAt(C3)) && (!!(p3 = ve(g4.slice(1, h3))) && (n3 || (void 0 === e3.env.references && (e3.env.references = {}), void 0 === e3.env.references[p3] && (e3.env.references[p3] = { title: b3, href: c3 }), e3.parentType = f4, e3.line = r3 + v3 + 1), true));
  }], ["html_block", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3 = e3.bMarks[r3] + e3.tShift[r3], l4 = e3.eMarks[r3];
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (!e3.md.options.html)
      return false;
    if (60 !== e3.src.charCodeAt(c3))
      return false;
    for (a4 = e3.src.slice(c3, l4), s3 = 0; s3 < Se.length && !Se[s3][0].test(a4); s3++)
      ;
    if (s3 === Se.length)
      return false;
    if (n3)
      return Se[s3][2];
    if (o4 = r3 + 1, !Se[s3][1].test(a4)) {
      for (; o4 < t3 && !(e3.sCount[o4] < e3.blkIndent); o4++)
        if (c3 = e3.bMarks[o4] + e3.tShift[o4], l4 = e3.eMarks[o4], a4 = e3.src.slice(c3, l4), Se[s3][1].test(a4)) {
          0 !== a4.length && o4++;
          break;
        }
    }
    return e3.line = o4, (i4 = e3.push("html_block", "", 0)).map = [r3, o4], i4.content = e3.getLines(r3, o4, e3.blkIndent, true), true;
  }, ["paragraph", "reference", "blockquote"]], ["heading", function(e3, r3, t3, n3) {
    var s3, o4, i4, a4, c3 = e3.bMarks[r3] + e3.tShift[r3], l4 = e3.eMarks[r3];
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    if (35 !== (s3 = e3.src.charCodeAt(c3)) || c3 >= l4)
      return false;
    for (o4 = 1, s3 = e3.src.charCodeAt(++c3); 35 === s3 && c3 < l4 && o4 <= 6; )
      o4++, s3 = e3.src.charCodeAt(++c3);
    return !(o4 > 6 || c3 < l4 && !Fe(s3)) && (n3 || (l4 = e3.skipSpacesBack(l4, c3), (i4 = e3.skipCharsBack(l4, 35, c3)) > c3 && Fe(e3.src.charCodeAt(i4 - 1)) && (l4 = i4), e3.line = r3 + 1, (a4 = e3.push("heading_open", "h" + String(o4), 1)).markup = "########".slice(0, o4), a4.map = [r3, e3.line], (a4 = e3.push("inline", "", 0)).content = e3.src.slice(c3, l4).trim(), a4.map = [r3, e3.line], a4.children = [], (a4 = e3.push("heading_close", "h" + String(o4), -1)).markup = "########".slice(0, o4)), true);
  }, ["paragraph", "reference", "blockquote"]], ["lheading", function(e3, r3, t3) {
    var n3, s3, o4, i4, a4, c3, l4, u4, p3, h3, f4 = r3 + 1, d3 = e3.md.block.ruler.getRules("paragraph");
    if (e3.sCount[r3] - e3.blkIndent >= 4)
      return false;
    for (h3 = e3.parentType, e3.parentType = "paragraph"; f4 < t3 && !e3.isEmpty(f4); f4++)
      if (!(e3.sCount[f4] - e3.blkIndent > 3)) {
        if (e3.sCount[f4] >= e3.blkIndent && (c3 = e3.bMarks[f4] + e3.tShift[f4]) < (l4 = e3.eMarks[f4]) && (45 === (p3 = e3.src.charCodeAt(c3)) || 61 === p3) && (c3 = e3.skipChars(c3, p3), (c3 = e3.skipSpaces(c3)) >= l4)) {
          u4 = 61 === p3 ? 1 : 2;
          break;
        }
        if (!(e3.sCount[f4] < 0)) {
          for (s3 = false, o4 = 0, i4 = d3.length; o4 < i4; o4++)
            if (d3[o4](e3, f4, t3, true)) {
              s3 = true;
              break;
            }
          if (s3)
            break;
        }
      }
    return !!u4 && (n3 = e3.getLines(r3, f4, e3.blkIndent, false).trim(), e3.line = f4 + 1, (a4 = e3.push("heading_open", "h" + String(u4), 1)).markup = String.fromCharCode(p3), a4.map = [r3, e3.line], (a4 = e3.push("inline", "", 0)).content = n3, a4.map = [r3, e3.line - 1], a4.children = [], (a4 = e3.push("heading_close", "h" + String(u4), -1)).markup = String.fromCharCode(p3), e3.parentType = h3, true);
  }], ["paragraph", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3 = r3 + 1, l4 = e3.md.block.ruler.getRules("paragraph"), u4 = e3.lineMax;
    for (a4 = e3.parentType, e3.parentType = "paragraph"; c3 < u4 && !e3.isEmpty(c3); c3++)
      if (!(e3.sCount[c3] - e3.blkIndent > 3 || e3.sCount[c3] < 0)) {
        for (n3 = false, s3 = 0, o4 = l4.length; s3 < o4; s3++)
          if (l4[s3](e3, c3, u4, true)) {
            n3 = true;
            break;
          }
        if (n3)
          break;
      }
    return t3 = e3.getLines(r3, c3, e3.blkIndent, false).trim(), e3.line = c3, (i4 = e3.push("paragraph_open", "p", 1)).map = [r3, e3.line], (i4 = e3.push("inline", "", 0)).content = t3, i4.map = [r3, e3.line], i4.children = [], i4 = e3.push("paragraph_close", "p", -1), e3.parentType = a4, true;
  }]];
  function Be() {
    this.ruler = new Me();
    for (var e3 = 0; e3 < Re.length; e3++)
      this.ruler.push(Re[e3][0], Re[e3][1], { alt: (Re[e3][2] || []).slice() });
  }
  Be.prototype.tokenize = function(e3, r3, t3) {
    for (var n3, s3 = this.ruler.getRules(""), o4 = s3.length, i4 = r3, a4 = false, c3 = e3.md.options.maxNesting; i4 < t3 && (e3.line = i4 = e3.skipEmptyLines(i4), !(i4 >= t3)) && !(e3.sCount[i4] < e3.blkIndent); ) {
      if (e3.level >= c3) {
        e3.line = t3;
        break;
      }
      for (n3 = 0; n3 < o4 && !s3[n3](e3, i4, t3, false); n3++)
        ;
      e3.tight = !a4, e3.isEmpty(e3.line - 1) && (a4 = true), (i4 = e3.line) < t3 && e3.isEmpty(i4) && (a4 = true, i4++, e3.line = i4);
    }
  }, Be.prototype.parse = function(e3, r3, t3, n3) {
    var s3;
    e3 && (s3 = new this.State(e3, r3, t3, n3), this.tokenize(s3, s3.line, s3.lineMax));
  }, Be.prototype.State = Ie;
  var Ne = Be;
  function Oe(e3) {
    switch (e3) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  for (Pe = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, je = r.isSpace, Ue = r.isSpace, Ve = [], Ze = 0; Ze < 256; Ze++)
    Ve.push(0);
  var Pe;
  var je;
  var Ue;
  var Ve;
  var Ze;
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e3) {
    Ve[e3.charCodeAt(0)] = 1;
  });
  var $e = {};
  function Ge(e3, r3) {
    var t3, n3, s3, o4, i4, a4 = [], c3 = r3.length;
    for (t3 = 0; t3 < c3; t3++)
      126 === (s3 = r3[t3]).marker && -1 !== s3.end && (o4 = r3[s3.end], (i4 = e3.tokens[s3.token]).type = "s_open", i4.tag = "s", i4.nesting = 1, i4.markup = "~~", i4.content = "", (i4 = e3.tokens[o4.token]).type = "s_close", i4.tag = "s", i4.nesting = -1, i4.markup = "~~", i4.content = "", "text" === e3.tokens[o4.token - 1].type && "~" === e3.tokens[o4.token - 1].content && a4.push(o4.token - 1));
    for (; a4.length; ) {
      for (n3 = (t3 = a4.pop()) + 1; n3 < e3.tokens.length && "s_close" === e3.tokens[n3].type; )
        n3++;
      t3 !== --n3 && (i4 = e3.tokens[n3], e3.tokens[n3] = e3.tokens[t3], e3.tokens[t3] = i4);
    }
  }
  $e.tokenize = function(e3, r3) {
    var t3, n3, s3, o4, i4 = e3.pos, a4 = e3.src.charCodeAt(i4);
    if (r3)
      return false;
    if (126 !== a4)
      return false;
    if (s3 = (n3 = e3.scanDelims(e3.pos, true)).length, o4 = String.fromCharCode(a4), s3 < 2)
      return false;
    for (s3 % 2 && (e3.push("text", "", 0).content = o4, s3--), t3 = 0; t3 < s3; t3 += 2)
      e3.push("text", "", 0).content = o4 + o4, e3.delimiters.push({ marker: a4, length: 0, token: e3.tokens.length - 1, end: -1, open: n3.can_open, close: n3.can_close });
    return e3.pos += n3.length, true;
  }, $e.postProcess = function(e3) {
    var r3, t3 = e3.tokens_meta, n3 = e3.tokens_meta.length;
    for (Ge(e3, e3.delimiters), r3 = 0; r3 < n3; r3++)
      t3[r3] && t3[r3].delimiters && Ge(e3, t3[r3].delimiters);
  };
  var He = {};
  function Je(e3, r3) {
    var t3, n3, s3, o4, i4, a4;
    for (t3 = r3.length - 1; t3 >= 0; t3--)
      95 !== (n3 = r3[t3]).marker && 42 !== n3.marker || -1 !== n3.end && (s3 = r3[n3.end], a4 = t3 > 0 && r3[t3 - 1].end === n3.end + 1 && r3[t3 - 1].marker === n3.marker && r3[t3 - 1].token === n3.token - 1 && r3[n3.end + 1].token === s3.token + 1, i4 = String.fromCharCode(n3.marker), (o4 = e3.tokens[n3.token]).type = a4 ? "strong_open" : "em_open", o4.tag = a4 ? "strong" : "em", o4.nesting = 1, o4.markup = a4 ? i4 + i4 : i4, o4.content = "", (o4 = e3.tokens[s3.token]).type = a4 ? "strong_close" : "em_close", o4.tag = a4 ? "strong" : "em", o4.nesting = -1, o4.markup = a4 ? i4 + i4 : i4, o4.content = "", a4 && (e3.tokens[r3[t3 - 1].token].content = "", e3.tokens[r3[n3.end + 1].token].content = "", t3--));
  }
  He.tokenize = function(e3, r3) {
    var t3, n3, s3 = e3.pos, o4 = e3.src.charCodeAt(s3);
    if (r3)
      return false;
    if (95 !== o4 && 42 !== o4)
      return false;
    for (n3 = e3.scanDelims(e3.pos, 42 === o4), t3 = 0; t3 < n3.length; t3++)
      e3.push("text", "", 0).content = String.fromCharCode(o4), e3.delimiters.push({ marker: o4, length: n3.length, token: e3.tokens.length - 1, end: -1, open: n3.can_open, close: n3.can_close });
    return e3.pos += n3.length, true;
  }, He.postProcess = function(e3) {
    var r3, t3 = e3.tokens_meta, n3 = e3.tokens_meta.length;
    for (Je(e3, e3.delimiters), r3 = 0; r3 < n3; r3++)
      t3[r3] && t3[r3].delimiters && Je(e3, t3[r3].delimiters);
  };
  var We = r.normalizeReference;
  var Ye = r.isSpace;
  var Ke = r.normalizeReference;
  var Qe = r.isSpace;
  var Xe = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var er = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  var rr = ye.HTML_TAG_RE;
  var tr = t;
  var nr = r.has;
  var sr = r.isValidEntityCode;
  var or = r.fromCodePoint;
  var ir = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var ar = /^&([a-z][a-z0-9]{1,31});/i;
  function cr(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4 = {}, p3 = r3.length;
    if (p3) {
      var h3 = 0, f4 = -2, d3 = [];
      for (t3 = 0; t3 < p3; t3++)
        if (s3 = r3[t3], d3.push(0), r3[h3].marker === s3.marker && f4 === s3.token - 1 || (h3 = t3), f4 = s3.token, s3.length = s3.length || 0, s3.close) {
          for (u4.hasOwnProperty(s3.marker) || (u4[s3.marker] = [-1, -1, -1, -1, -1, -1]), i4 = u4[s3.marker][(s3.open ? 3 : 0) + s3.length % 3], a4 = n3 = h3 - d3[h3] - 1; n3 > i4; n3 -= d3[n3] + 1)
            if ((o4 = r3[n3]).marker === s3.marker && o4.open && o4.end < 0 && (c3 = false, (o4.close || s3.open) && (o4.length + s3.length) % 3 == 0 && (o4.length % 3 == 0 && s3.length % 3 == 0 || (c3 = true)), !c3)) {
              l4 = n3 > 0 && !r3[n3 - 1].open ? d3[n3 - 1] + 1 : 0, d3[t3] = t3 - n3 + l4, d3[n3] = l4, s3.open = false, o4.end = t3, o4.close = false, a4 = -1, f4 = -2;
              break;
            }
          -1 !== a4 && (u4[s3.marker][(s3.open ? 3 : 0) + (s3.length || 0) % 3] = a4);
        }
    }
  }
  var lr = se;
  var ur = r.isWhiteSpace;
  var pr = r.isPunctChar;
  var hr = r.isMdAsciiPunct;
  function fr(e3, r3, t3, n3) {
    this.src = e3, this.env = t3, this.md = r3, this.tokens = n3, this.tokens_meta = Array(n3.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
  }
  fr.prototype.pushPending = function() {
    var e3 = new lr("text", "", 0);
    return e3.content = this.pending, e3.level = this.pendingLevel, this.tokens.push(e3), this.pending = "", e3;
  }, fr.prototype.push = function(e3, r3, t3) {
    this.pending && this.pushPending();
    var n3 = new lr(e3, r3, t3), s3 = null;
    return t3 < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), n3.level = this.level, t3 > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], s3 = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(n3), this.tokens_meta.push(s3), n3;
  }, fr.prototype.scanDelims = function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4, p3 = e3, h3 = true, f4 = true, d3 = this.posMax, m3 = this.src.charCodeAt(e3);
    for (t3 = e3 > 0 ? this.src.charCodeAt(e3 - 1) : 32; p3 < d3 && this.src.charCodeAt(p3) === m3; )
      p3++;
    return s3 = p3 - e3, n3 = p3 < d3 ? this.src.charCodeAt(p3) : 32, c3 = hr(t3) || pr(String.fromCharCode(t3)), u4 = hr(n3) || pr(String.fromCharCode(n3)), a4 = ur(t3), (l4 = ur(n3)) ? h3 = false : u4 && (a4 || c3 || (h3 = false)), a4 ? f4 = false : c3 && (l4 || u4 || (f4 = false)), r3 ? (o4 = h3, i4 = f4) : (o4 = h3 && (!f4 || c3), i4 = f4 && (!h3 || u4)), { can_open: o4, can_close: i4, length: s3 };
  }, fr.prototype.Token = lr;
  var dr = fr;
  var mr = N;
  var gr = [["text", function(e3, r3) {
    for (var t3 = e3.pos; t3 < e3.posMax && !Oe(e3.src.charCodeAt(t3)); )
      t3++;
    return t3 !== e3.pos && (r3 || (e3.pending += e3.src.slice(e3.pos, t3)), e3.pos = t3, true);
  }], ["linkify", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3;
    return !!e3.md.options.linkify && (!(e3.linkLevel > 0) && (!((t3 = e3.pos) + 3 > e3.posMax) && (58 === e3.src.charCodeAt(t3) && (47 === e3.src.charCodeAt(t3 + 1) && (47 === e3.src.charCodeAt(t3 + 2) && (!!(n3 = e3.pending.match(Pe)) && (s3 = n3[1], !!(o4 = e3.md.linkify.matchAtStart(e3.src.slice(t3 - s3.length))) && (i4 = (i4 = o4.url).replace(/\*+$/, ""), a4 = e3.md.normalizeLink(i4), !!e3.md.validateLink(a4) && (r3 || (e3.pending = e3.pending.slice(0, -s3.length), (c3 = e3.push("link_open", "a", 1)).attrs = [["href", a4]], c3.markup = "linkify", c3.info = "auto", (c3 = e3.push("text", "", 0)).content = e3.md.normalizeLinkText(i4), (c3 = e3.push("link_close", "a", -1)).markup = "linkify", c3.info = "auto"), e3.pos += i4.length - s3.length, true)))))))));
  }], ["newline", function(e3, r3) {
    var t3, n3, s3, o4 = e3.pos;
    if (10 !== e3.src.charCodeAt(o4))
      return false;
    if (t3 = e3.pending.length - 1, n3 = e3.posMax, !r3)
      if (t3 >= 0 && 32 === e3.pending.charCodeAt(t3))
        if (t3 >= 1 && 32 === e3.pending.charCodeAt(t3 - 1)) {
          for (s3 = t3 - 1; s3 >= 1 && 32 === e3.pending.charCodeAt(s3 - 1); )
            s3--;
          e3.pending = e3.pending.slice(0, s3), e3.push("hardbreak", "br", 0);
        } else
          e3.pending = e3.pending.slice(0, -1), e3.push("softbreak", "br", 0);
      else
        e3.push("softbreak", "br", 0);
    for (o4++; o4 < n3 && je(e3.src.charCodeAt(o4)); )
      o4++;
    return e3.pos = o4, true;
  }], ["escape", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4 = e3.pos, c3 = e3.posMax;
    if (92 !== e3.src.charCodeAt(a4))
      return false;
    if (++a4 >= c3)
      return false;
    if (10 === (t3 = e3.src.charCodeAt(a4))) {
      for (r3 || e3.push("hardbreak", "br", 0), a4++; a4 < c3 && (t3 = e3.src.charCodeAt(a4), Ue(t3)); )
        a4++;
      return e3.pos = a4, true;
    }
    return o4 = e3.src[a4], t3 >= 55296 && t3 <= 56319 && a4 + 1 < c3 && (n3 = e3.src.charCodeAt(a4 + 1)) >= 56320 && n3 <= 57343 && (o4 += e3.src[a4 + 1], a4++), s3 = "\\" + o4, r3 || (i4 = e3.push("text_special", "", 0), t3 < 256 && 0 !== Ve[t3] ? i4.content = o4 : i4.content = s3, i4.markup = s3, i4.info = "escape"), e3.pos = a4 + 1, true;
  }], ["backticks", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4 = e3.pos;
    if (96 !== e3.src.charCodeAt(u4))
      return false;
    for (t3 = u4, u4++, n3 = e3.posMax; u4 < n3 && 96 === e3.src.charCodeAt(u4); )
      u4++;
    if (c3 = (s3 = e3.src.slice(t3, u4)).length, e3.backticksScanned && (e3.backticks[c3] || 0) <= t3)
      return r3 || (e3.pending += s3), e3.pos += c3, true;
    for (i4 = a4 = u4; -1 !== (i4 = e3.src.indexOf("`", a4)); ) {
      for (a4 = i4 + 1; a4 < n3 && 96 === e3.src.charCodeAt(a4); )
        a4++;
      if ((l4 = a4 - i4) === c3)
        return r3 || ((o4 = e3.push("code_inline", "code", 0)).markup = s3, o4.content = e3.src.slice(u4, i4).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e3.pos = a4, true;
      e3.backticks[l4] = i4;
    }
    return e3.backticksScanned = true, r3 || (e3.pending += s3), e3.pos += c3, true;
  }], ["strikethrough", $e.tokenize], ["emphasis", He.tokenize], ["link", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4 = "", p3 = "", h3 = e3.pos, f4 = e3.posMax, d3 = e3.pos, m3 = true;
    if (91 !== e3.src.charCodeAt(e3.pos))
      return false;
    if (i4 = e3.pos + 1, (o4 = e3.md.helpers.parseLinkLabel(e3, e3.pos, true)) < 0)
      return false;
    if ((a4 = o4 + 1) < f4 && 40 === e3.src.charCodeAt(a4)) {
      for (m3 = false, a4++; a4 < f4 && (n3 = e3.src.charCodeAt(a4), Ye(n3) || 10 === n3); a4++)
        ;
      if (a4 >= f4)
        return false;
      if (d3 = a4, (c3 = e3.md.helpers.parseLinkDestination(e3.src, a4, e3.posMax)).ok) {
        for (u4 = e3.md.normalizeLink(c3.str), e3.md.validateLink(u4) ? a4 = c3.pos : u4 = "", d3 = a4; a4 < f4 && (n3 = e3.src.charCodeAt(a4), Ye(n3) || 10 === n3); a4++)
          ;
        if (c3 = e3.md.helpers.parseLinkTitle(e3.src, a4, e3.posMax), a4 < f4 && d3 !== a4 && c3.ok)
          for (p3 = c3.str, a4 = c3.pos; a4 < f4 && (n3 = e3.src.charCodeAt(a4), Ye(n3) || 10 === n3); a4++)
            ;
      }
      (a4 >= f4 || 41 !== e3.src.charCodeAt(a4)) && (m3 = true), a4++;
    }
    if (m3) {
      if (void 0 === e3.env.references)
        return false;
      if (a4 < f4 && 91 === e3.src.charCodeAt(a4) ? (d3 = a4 + 1, (a4 = e3.md.helpers.parseLinkLabel(e3, a4)) >= 0 ? s3 = e3.src.slice(d3, a4++) : a4 = o4 + 1) : a4 = o4 + 1, s3 || (s3 = e3.src.slice(i4, o4)), !(l4 = e3.env.references[We(s3)]))
        return e3.pos = h3, false;
      u4 = l4.href, p3 = l4.title;
    }
    return r3 || (e3.pos = i4, e3.posMax = o4, e3.push("link_open", "a", 1).attrs = t3 = [["href", u4]], p3 && t3.push(["title", p3]), e3.linkLevel++, e3.md.inline.tokenize(e3), e3.linkLevel--, e3.push("link_close", "a", -1)), e3.pos = a4, e3.posMax = f4, true;
  }], ["image", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3 = "", g4 = e3.pos, _4 = e3.posMax;
    if (33 !== e3.src.charCodeAt(e3.pos))
      return false;
    if (91 !== e3.src.charCodeAt(e3.pos + 1))
      return false;
    if (a4 = e3.pos + 2, (i4 = e3.md.helpers.parseLinkLabel(e3, e3.pos + 1, false)) < 0)
      return false;
    if ((c3 = i4 + 1) < _4 && 40 === e3.src.charCodeAt(c3)) {
      for (c3++; c3 < _4 && (n3 = e3.src.charCodeAt(c3), Qe(n3) || 10 === n3); c3++)
        ;
      if (c3 >= _4)
        return false;
      for (d3 = c3, (u4 = e3.md.helpers.parseLinkDestination(e3.src, c3, e3.posMax)).ok && (m3 = e3.md.normalizeLink(u4.str), e3.md.validateLink(m3) ? c3 = u4.pos : m3 = ""), d3 = c3; c3 < _4 && (n3 = e3.src.charCodeAt(c3), Qe(n3) || 10 === n3); c3++)
        ;
      if (u4 = e3.md.helpers.parseLinkTitle(e3.src, c3, e3.posMax), c3 < _4 && d3 !== c3 && u4.ok)
        for (p3 = u4.str, c3 = u4.pos; c3 < _4 && (n3 = e3.src.charCodeAt(c3), Qe(n3) || 10 === n3); c3++)
          ;
      else
        p3 = "";
      if (c3 >= _4 || 41 !== e3.src.charCodeAt(c3))
        return e3.pos = g4, false;
      c3++;
    } else {
      if (void 0 === e3.env.references)
        return false;
      if (c3 < _4 && 91 === e3.src.charCodeAt(c3) ? (d3 = c3 + 1, (c3 = e3.md.helpers.parseLinkLabel(e3, c3)) >= 0 ? o4 = e3.src.slice(d3, c3++) : c3 = i4 + 1) : c3 = i4 + 1, o4 || (o4 = e3.src.slice(a4, i4)), !(l4 = e3.env.references[Ke(o4)]))
        return e3.pos = g4, false;
      m3 = l4.href, p3 = l4.title;
    }
    return r3 || (s3 = e3.src.slice(a4, i4), e3.md.inline.parse(s3, e3.md, e3.env, f4 = []), (h3 = e3.push("image", "img", 0)).attrs = t3 = [["src", m3], ["alt", ""]], h3.children = f4, h3.content = s3, p3 && t3.push(["title", p3])), e3.pos = c3, e3.posMax = _4, true;
  }], ["autolink", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4, c3 = e3.pos;
    if (60 !== e3.src.charCodeAt(c3))
      return false;
    for (i4 = e3.pos, a4 = e3.posMax; ; ) {
      if (++c3 >= a4)
        return false;
      if (60 === (o4 = e3.src.charCodeAt(c3)))
        return false;
      if (62 === o4)
        break;
    }
    return t3 = e3.src.slice(i4 + 1, c3), er.test(t3) ? (n3 = e3.md.normalizeLink(t3), !!e3.md.validateLink(n3) && (r3 || ((s3 = e3.push("link_open", "a", 1)).attrs = [["href", n3]], s3.markup = "autolink", s3.info = "auto", (s3 = e3.push("text", "", 0)).content = e3.md.normalizeLinkText(t3), (s3 = e3.push("link_close", "a", -1)).markup = "autolink", s3.info = "auto"), e3.pos += t3.length + 2, true)) : !!Xe.test(t3) && (n3 = e3.md.normalizeLink("mailto:" + t3), !!e3.md.validateLink(n3) && (r3 || ((s3 = e3.push("link_open", "a", 1)).attrs = [["href", n3]], s3.markup = "autolink", s3.info = "auto", (s3 = e3.push("text", "", 0)).content = e3.md.normalizeLinkText(t3), (s3 = e3.push("link_close", "a", -1)).markup = "autolink", s3.info = "auto"), e3.pos += t3.length + 2, true));
  }], ["html_inline", function(e3, r3) {
    var t3, n3, s3, o4, i4, a4 = e3.pos;
    return !!e3.md.options.html && (s3 = e3.posMax, !(60 !== e3.src.charCodeAt(a4) || a4 + 2 >= s3) && (!(33 !== (t3 = e3.src.charCodeAt(a4 + 1)) && 63 !== t3 && 47 !== t3 && !function(e4) {
      var r4 = 32 | e4;
      return r4 >= 97 && r4 <= 122;
    }(t3)) && (!!(n3 = e3.src.slice(a4).match(rr)) && (r3 || ((o4 = e3.push("html_inline", "", 0)).content = e3.src.slice(a4, a4 + n3[0].length), i4 = o4.content, /^<a[>\s]/i.test(i4) && e3.linkLevel++, function(e4) {
      return /^<\/a\s*>/i.test(e4);
    }(o4.content) && e3.linkLevel--), e3.pos += n3[0].length, true))));
  }], ["entity", function(e3, r3) {
    var t3, n3, s3, o4 = e3.pos, i4 = e3.posMax;
    if (38 !== e3.src.charCodeAt(o4))
      return false;
    if (o4 + 1 >= i4)
      return false;
    if (35 === e3.src.charCodeAt(o4 + 1)) {
      if (n3 = e3.src.slice(o4).match(ir))
        return r3 || (t3 = "x" === n3[1][0].toLowerCase() ? parseInt(n3[1].slice(1), 16) : parseInt(n3[1], 10), (s3 = e3.push("text_special", "", 0)).content = sr(t3) ? or(t3) : or(65533), s3.markup = n3[0], s3.info = "entity"), e3.pos += n3[0].length, true;
    } else if ((n3 = e3.src.slice(o4).match(ar)) && nr(tr, n3[1]))
      return r3 || ((s3 = e3.push("text_special", "", 0)).content = tr[n3[1]], s3.markup = n3[0], s3.info = "entity"), e3.pos += n3[0].length, true;
    return false;
  }]];
  var _r = [["balance_pairs", function(e3) {
    var r3, t3 = e3.tokens_meta, n3 = e3.tokens_meta.length;
    for (cr(0, e3.delimiters), r3 = 0; r3 < n3; r3++)
      t3[r3] && t3[r3].delimiters && cr(0, t3[r3].delimiters);
  }], ["strikethrough", $e.postProcess], ["emphasis", He.postProcess], ["fragments_join", function(e3) {
    var r3, t3, n3 = 0, s3 = e3.tokens, o4 = e3.tokens.length;
    for (r3 = t3 = 0; r3 < o4; r3++)
      s3[r3].nesting < 0 && n3--, s3[r3].level = n3, s3[r3].nesting > 0 && n3++, "text" === s3[r3].type && r3 + 1 < o4 && "text" === s3[r3 + 1].type ? s3[r3 + 1].content = s3[r3].content + s3[r3 + 1].content : (r3 !== t3 && (s3[t3] = s3[r3]), t3++);
    r3 !== t3 && (s3.length = t3);
  }]];
  function kr() {
    var e3;
    for (this.ruler = new mr(), e3 = 0; e3 < gr.length; e3++)
      this.ruler.push(gr[e3][0], gr[e3][1]);
    for (this.ruler2 = new mr(), e3 = 0; e3 < _r.length; e3++)
      this.ruler2.push(_r[e3][0], _r[e3][1]);
  }
  kr.prototype.skipToken = function(e3) {
    var r3, t3, n3 = e3.pos, s3 = this.ruler.getRules(""), o4 = s3.length, i4 = e3.md.options.maxNesting, a4 = e3.cache;
    if (void 0 === a4[n3]) {
      if (e3.level < i4)
        for (t3 = 0; t3 < o4 && (e3.level++, r3 = s3[t3](e3, true), e3.level--, !r3); t3++)
          ;
      else
        e3.pos = e3.posMax;
      r3 || e3.pos++, a4[n3] = e3.pos;
    } else
      e3.pos = a4[n3];
  }, kr.prototype.tokenize = function(e3) {
    for (var r3, t3, n3 = this.ruler.getRules(""), s3 = n3.length, o4 = e3.posMax, i4 = e3.md.options.maxNesting; e3.pos < o4; ) {
      if (e3.level < i4)
        for (t3 = 0; t3 < s3 && !(r3 = n3[t3](e3, false)); t3++)
          ;
      if (r3) {
        if (e3.pos >= o4)
          break;
      } else
        e3.pending += e3.src[e3.pos++];
    }
    e3.pending && e3.pushPending();
  }, kr.prototype.parse = function(e3, r3, t3, n3) {
    var s3, o4, i4, a4 = new this.State(e3, r3, t3, n3);
    for (this.tokenize(a4), i4 = (o4 = this.ruler2.getRules("")).length, s3 = 0; s3 < i4; s3++)
      o4[s3](a4);
  }, kr.prototype.State = dr;
  var br = kr;
  function vr(e3) {
    var r3 = Array.prototype.slice.call(arguments, 1);
    return r3.forEach(function(r4) {
      r4 && Object.keys(r4).forEach(function(t3) {
        e3[t3] = r4[t3];
      });
    }), e3;
  }
  function Cr(e3) {
    return Object.prototype.toString.call(e3);
  }
  function yr(e3) {
    return "[object Function]" === Cr(e3);
  }
  function Ar(e3) {
    return e3.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var xr = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
  var Dr = { "http:": { validate: function(e3, r3, t3) {
    var n3 = e3.slice(r3);
    return t3.re.http || (t3.re.http = new RegExp("^\\/\\/" + t3.re.src_auth + t3.re.src_host_port_strict + t3.re.src_path, "i")), t3.re.http.test(n3) ? n3.match(t3.re.http)[0].length : 0;
  } }, "https:": "http:", "ftp:": "http:", "//": { validate: function(e3, r3, t3) {
    var n3 = e3.slice(r3);
    return t3.re.no_http || (t3.re.no_http = new RegExp("^" + t3.re.src_auth + "(?:localhost|(?:(?:" + t3.re.src_domain + ")\\.)+" + t3.re.src_domain_root + ")" + t3.re.src_port + t3.re.src_host_terminator + t3.re.src_path, "i")), t3.re.no_http.test(n3) ? r3 >= 3 && ":" === e3[r3 - 3] || r3 >= 3 && "/" === e3[r3 - 3] ? 0 : n3.match(t3.re.no_http)[0].length : 0;
  } }, "mailto:": { validate: function(e3, r3, t3) {
    var n3 = e3.slice(r3);
    return t3.re.mailto || (t3.re.mailto = new RegExp("^" + t3.re.src_email_name + "@" + t3.re.src_host_strict, "i")), t3.re.mailto.test(n3) ? n3.match(t3.re.mailto)[0].length : 0;
  } } };
  var wr = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
  function Er(e3) {
    var r3 = e3.re = function(e4) {
      var r4 = {};
      return e4 = e4 || {}, r4.src_Any = D.source, r4.src_Cc = w.source, r4.src_Z = E.source, r4.src_P = n.source, r4.src_ZPCc = [r4.src_Z, r4.src_P, r4.src_Cc].join("|"), r4.src_ZCc = [r4.src_Z, r4.src_Cc].join("|"), r4.src_pseudo_letter = "(?:(?![><\uFF5C]|" + r4.src_ZPCc + ")" + r4.src_Any + ")", r4.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", r4.src_auth = "(?:(?:(?!" + r4.src_ZCc + "|[@/\\[\\]()]).)+@)?", r4.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", r4.src_host_terminator = "(?=$|[><\uFF5C]|" + r4.src_ZPCc + ")(?!" + (e4["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + r4.src_ZPCc + "))", r4.src_path = "(?:[/?#](?:(?!" + r4.src_ZCc + `|[><\uFF5C]|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + r4.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + r4.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + r4.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + r4.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + r4.src_ZCc + "|[']).)+\\'|\\'(?=" + r4.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + r4.src_ZCc + "|[.]|$)|" + (e4["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + r4.src_ZCc + "|$)|;(?!" + r4.src_ZCc + "|$)|\\!+(?!" + r4.src_ZCc + "|[!]|$)|\\?(?!" + r4.src_ZCc + "|[?]|$))+|\\/)?", r4.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', r4.src_xn = "xn--[a-z0-9\\-]{1,59}", r4.src_domain_root = "(?:" + r4.src_xn + "|" + r4.src_pseudo_letter + "{1,63})", r4.src_domain = "(?:" + r4.src_xn + "|(?:" + r4.src_pseudo_letter + ")|(?:" + r4.src_pseudo_letter + "(?:-|" + r4.src_pseudo_letter + "){0,61}" + r4.src_pseudo_letter + "))", r4.src_host = "(?:(?:(?:(?:" + r4.src_domain + ")\\.)*" + r4.src_domain + "))", r4.tpl_host_fuzzy = "(?:" + r4.src_ip4 + "|(?:(?:(?:" + r4.src_domain + ")\\.)+(?:%TLDS%)))", r4.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + r4.src_domain + ")\\.)+(?:%TLDS%))", r4.src_host_strict = r4.src_host + r4.src_host_terminator, r4.tpl_host_fuzzy_strict = r4.tpl_host_fuzzy + r4.src_host_terminator, r4.src_host_port_strict = r4.src_host + r4.src_port + r4.src_host_terminator, r4.tpl_host_port_fuzzy_strict = r4.tpl_host_fuzzy + r4.src_port + r4.src_host_terminator, r4.tpl_host_port_no_ip_fuzzy_strict = r4.tpl_host_no_ip_fuzzy + r4.src_port + r4.src_host_terminator, r4.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + r4.src_ZPCc + "|>|$))", r4.tpl_email_fuzzy = '(^|[><\uFF5C]|"|\\(|' + r4.src_ZCc + ")(" + r4.src_email_name + "@" + r4.tpl_host_fuzzy_strict + ")", r4.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + r4.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + r4.tpl_host_port_fuzzy_strict + r4.src_path + ")", r4.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + r4.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + r4.tpl_host_port_no_ip_fuzzy_strict + r4.src_path + ")", r4;
    }(e3.__opts__), t3 = e3.__tlds__.slice();
    function s3(e4) {
      return e4.replace("%TLDS%", r3.src_tlds);
    }
    e3.onCompile(), e3.__tlds_replaced__ || t3.push("a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]"), t3.push(r3.src_xn), r3.src_tlds = t3.join("|"), r3.email_fuzzy = RegExp(s3(r3.tpl_email_fuzzy), "i"), r3.link_fuzzy = RegExp(s3(r3.tpl_link_fuzzy), "i"), r3.link_no_ip_fuzzy = RegExp(s3(r3.tpl_link_no_ip_fuzzy), "i"), r3.host_fuzzy_test = RegExp(s3(r3.tpl_host_fuzzy_test), "i");
    var o4 = [];
    function i4(e4, r4) {
      throw new Error('(LinkifyIt) Invalid schema "' + e4 + '": ' + r4);
    }
    e3.__compiled__ = {}, Object.keys(e3.__schemas__).forEach(function(r4) {
      var t4 = e3.__schemas__[r4];
      if (null !== t4) {
        var n3 = { validate: null, link: null };
        if (e3.__compiled__[r4] = n3, "[object Object]" === Cr(t4))
          return !function(e4) {
            return "[object RegExp]" === Cr(e4);
          }(t4.validate) ? yr(t4.validate) ? n3.validate = t4.validate : i4(r4, t4) : n3.validate = /* @__PURE__ */ function(e4) {
            return function(r5, t5) {
              var n4 = r5.slice(t5);
              return e4.test(n4) ? n4.match(e4)[0].length : 0;
            };
          }(t4.validate), void (yr(t4.normalize) ? n3.normalize = t4.normalize : t4.normalize ? i4(r4, t4) : n3.normalize = function(e4, r5) {
            r5.normalize(e4);
          });
        !function(e4) {
          return "[object String]" === Cr(e4);
        }(t4) ? i4(r4, t4) : o4.push(r4);
      }
    }), o4.forEach(function(r4) {
      e3.__compiled__[e3.__schemas__[r4]] && (e3.__compiled__[r4].validate = e3.__compiled__[e3.__schemas__[r4]].validate, e3.__compiled__[r4].normalize = e3.__compiled__[e3.__schemas__[r4]].normalize);
    }), e3.__compiled__[""] = { validate: null, normalize: function(e4, r4) {
      r4.normalize(e4);
    } };
    var a4 = Object.keys(e3.__compiled__).filter(function(r4) {
      return r4.length > 0 && e3.__compiled__[r4];
    }).map(Ar).join("|");
    e3.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + r3.src_ZPCc + "))(" + a4 + ")", "i"), e3.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + r3.src_ZPCc + "))(" + a4 + ")", "ig"), e3.re.schema_at_start = RegExp("^" + e3.re.schema_search.source, "i"), e3.re.pretest = RegExp("(" + e3.re.schema_test.source + ")|(" + e3.re.host_fuzzy_test.source + ")|@", "i"), function(e4) {
      e4.__index__ = -1, e4.__text_cache__ = "";
    }(e3);
  }
  function qr(e3, r3) {
    var t3 = e3.__index__, n3 = e3.__last_index__, s3 = e3.__text_cache__.slice(t3, n3);
    this.schema = e3.__schema__.toLowerCase(), this.index = t3 + r3, this.lastIndex = n3 + r3, this.raw = s3, this.text = s3, this.url = s3;
  }
  function Sr(e3, r3) {
    var t3 = new qr(e3, r3);
    return e3.__compiled__[t3.schema].normalize(t3, e3), t3;
  }
  function Fr(e3, r3) {
    if (!(this instanceof Fr))
      return new Fr(e3, r3);
    var t3;
    r3 || (t3 = e3, Object.keys(t3 || {}).reduce(function(e4, r4) {
      return e4 || xr.hasOwnProperty(r4);
    }, false) && (r3 = e3, e3 = {})), this.__opts__ = vr({}, xr, r3), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = vr({}, Dr, e3), this.__compiled__ = {}, this.__tlds__ = wr, this.__tlds_replaced__ = false, this.re = {}, Er(this);
  }
  Fr.prototype.add = function(e3, r3) {
    return this.__schemas__[e3] = r3, Er(this), this;
  }, Fr.prototype.set = function(e3) {
    return this.__opts__ = vr(this.__opts__, e3), this;
  }, Fr.prototype.test = function(e3) {
    if (this.__text_cache__ = e3, this.__index__ = -1, !e3.length)
      return false;
    var r3, t3, n3, s3, o4, i4, a4, c3;
    if (this.re.schema_test.test(e3)) {
      for ((a4 = this.re.schema_search).lastIndex = 0; null !== (r3 = a4.exec(e3)); )
        if (s3 = this.testSchemaAt(e3, r3[2], a4.lastIndex)) {
          this.__schema__ = r3[2], this.__index__ = r3.index + r3[1].length, this.__last_index__ = r3.index + r3[0].length + s3;
          break;
        }
    }
    return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c3 = e3.search(this.re.host_fuzzy_test)) >= 0 && (this.__index__ < 0 || c3 < this.__index__) && null !== (t3 = e3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (o4 = t3.index + t3[1].length, (this.__index__ < 0 || o4 < this.__index__) && (this.__schema__ = "", this.__index__ = o4, this.__last_index__ = t3.index + t3[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && e3.indexOf("@") >= 0 && null !== (n3 = e3.match(this.re.email_fuzzy)) && (o4 = n3.index + n3[1].length, i4 = n3.index + n3[0].length, (this.__index__ < 0 || o4 < this.__index__ || o4 === this.__index__ && i4 > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o4, this.__last_index__ = i4)), this.__index__ >= 0;
  }, Fr.prototype.pretest = function(e3) {
    return this.re.pretest.test(e3);
  }, Fr.prototype.testSchemaAt = function(e3, r3, t3) {
    return this.__compiled__[r3.toLowerCase()] ? this.__compiled__[r3.toLowerCase()].validate(e3, t3, this) : 0;
  }, Fr.prototype.match = function(e3) {
    var r3 = 0, t3 = [];
    this.__index__ >= 0 && this.__text_cache__ === e3 && (t3.push(Sr(this, r3)), r3 = this.__last_index__);
    for (var n3 = r3 ? e3.slice(r3) : e3; this.test(n3); )
      t3.push(Sr(this, r3)), n3 = n3.slice(this.__last_index__), r3 += this.__last_index__;
    return t3.length ? t3 : null;
  }, Fr.prototype.matchAtStart = function(e3) {
    if (this.__text_cache__ = e3, this.__index__ = -1, !e3.length)
      return null;
    var r3 = this.re.schema_at_start.exec(e3);
    if (!r3)
      return null;
    var t3 = this.testSchemaAt(e3, r3[2], r3[0].length);
    return t3 ? (this.__schema__ = r3[2], this.__index__ = r3.index + r3[1].length, this.__last_index__ = r3.index + r3[0].length + t3, Sr(this, 0)) : null;
  }, Fr.prototype.tlds = function(e3, r3) {
    return e3 = Array.isArray(e3) ? e3 : [e3], r3 ? (this.__tlds__ = this.__tlds__.concat(e3).sort().filter(function(e4, r4, t3) {
      return e4 !== t3[r4 - 1];
    }).reverse(), Er(this), this) : (this.__tlds__ = e3.slice(), this.__tlds_replaced__ = true, Er(this), this);
  }, Fr.prototype.normalize = function(e3) {
    e3.schema || (e3.url = "http://" + e3.url), "mailto:" !== e3.schema || /^mailto:/i.test(e3.url) || (e3.url = "mailto:" + e3.url);
  }, Fr.prototype.onCompile = function() {
  };
  var Lr = Fr;
  var zr = 2147483647;
  var Tr = /^xn--/;
  var Ir = /[^\x20-\x7E]/;
  var Mr = /[\x2E\u3002\uFF0E\uFF61]/g;
  var Rr = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
  var Br = Math.floor;
  var Nr = String.fromCharCode;
  function Or(e3) {
    throw new RangeError(Rr[e3]);
  }
  function Pr(e3, r3) {
    for (var t3 = e3.length, n3 = []; t3--; )
      n3[t3] = r3(e3[t3]);
    return n3;
  }
  function jr(e3, r3) {
    var t3 = e3.split("@"), n3 = "";
    return t3.length > 1 && (n3 = t3[0] + "@", e3 = t3[1]), n3 + Pr((e3 = e3.replace(Mr, ".")).split("."), r3).join(".");
  }
  function Ur(e3) {
    for (var r3, t3, n3 = [], s3 = 0, o4 = e3.length; s3 < o4; )
      (r3 = e3.charCodeAt(s3++)) >= 55296 && r3 <= 56319 && s3 < o4 ? 56320 == (64512 & (t3 = e3.charCodeAt(s3++))) ? n3.push(((1023 & r3) << 10) + (1023 & t3) + 65536) : (n3.push(r3), s3--) : n3.push(r3);
    return n3;
  }
  function Vr(e3) {
    return Pr(e3, function(e4) {
      var r3 = "";
      return e4 > 65535 && (r3 += Nr((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), r3 += Nr(e4);
    }).join("");
  }
  function Zr(e3, r3) {
    return e3 + 22 + 75 * (e3 < 26) - ((0 != r3) << 5);
  }
  function $r(e3, r3, t3) {
    var n3 = 0;
    for (e3 = t3 ? Br(e3 / 700) : e3 >> 1, e3 += Br(e3 / r3); e3 > 455; n3 += 36)
      e3 = Br(e3 / 35);
    return Br(n3 + 36 * e3 / (e3 + 38));
  }
  function Gr(e3) {
    var r3, t3, n3, s3, o4, i4, a4, c3, l4, u4, p3, h3 = [], f4 = e3.length, d3 = 0, m3 = 128, g4 = 72;
    for ((t3 = e3.lastIndexOf("-")) < 0 && (t3 = 0), n3 = 0; n3 < t3; ++n3)
      e3.charCodeAt(n3) >= 128 && Or("not-basic"), h3.push(e3.charCodeAt(n3));
    for (s3 = t3 > 0 ? t3 + 1 : 0; s3 < f4; ) {
      for (o4 = d3, i4 = 1, a4 = 36; s3 >= f4 && Or("invalid-input"), ((c3 = (p3 = e3.charCodeAt(s3++)) - 48 < 10 ? p3 - 22 : p3 - 65 < 26 ? p3 - 65 : p3 - 97 < 26 ? p3 - 97 : 36) >= 36 || c3 > Br((zr - d3) / i4)) && Or("overflow"), d3 += c3 * i4, !(c3 < (l4 = a4 <= g4 ? 1 : a4 >= g4 + 26 ? 26 : a4 - g4)); a4 += 36)
        i4 > Br(zr / (u4 = 36 - l4)) && Or("overflow"), i4 *= u4;
      g4 = $r(d3 - o4, r3 = h3.length + 1, 0 == o4), Br(d3 / r3) > zr - m3 && Or("overflow"), m3 += Br(d3 / r3), d3 %= r3, h3.splice(d3++, 0, m3);
    }
    return Vr(h3);
  }
  function Hr(e3) {
    var r3, t3, n3, s3, o4, i4, a4, c3, l4, u4, p3, h3, f4, d3, m3, g4 = [];
    for (h3 = (e3 = Ur(e3)).length, r3 = 128, t3 = 0, o4 = 72, i4 = 0; i4 < h3; ++i4)
      (p3 = e3[i4]) < 128 && g4.push(Nr(p3));
    for (n3 = s3 = g4.length, s3 && g4.push("-"); n3 < h3; ) {
      for (a4 = zr, i4 = 0; i4 < h3; ++i4)
        (p3 = e3[i4]) >= r3 && p3 < a4 && (a4 = p3);
      for (a4 - r3 > Br((zr - t3) / (f4 = n3 + 1)) && Or("overflow"), t3 += (a4 - r3) * f4, r3 = a4, i4 = 0; i4 < h3; ++i4)
        if ((p3 = e3[i4]) < r3 && ++t3 > zr && Or("overflow"), p3 == r3) {
          for (c3 = t3, l4 = 36; !(c3 < (u4 = l4 <= o4 ? 1 : l4 >= o4 + 26 ? 26 : l4 - o4)); l4 += 36)
            m3 = c3 - u4, d3 = 36 - u4, g4.push(Nr(Zr(u4 + m3 % d3, 0))), c3 = Br(m3 / d3);
          g4.push(Nr(Zr(c3, 0))), o4 = $r(t3, f4, n3 == s3), t3 = 0, ++n3;
        }
      ++t3, ++r3;
    }
    return g4.join("");
  }
  function Jr(e3) {
    return jr(e3, function(e4) {
      return Tr.test(e4) ? Gr(e4.slice(4).toLowerCase()) : e4;
    });
  }
  function Wr(e3) {
    return jr(e3, function(e4) {
      return Ir.test(e4) ? "xn--" + Hr(e4) : e4;
    });
  }
  var Yr = { decode: Ur, encode: Vr };
  var Kr = { version: "1.4.1", ucs2: Yr, toASCII: Wr, toUnicode: Jr, encode: Hr, decode: Gr };
  var Qr = r;
  var Xr = q;
  var et = R;
  var rt = pe;
  var tt = Ne;
  var nt = br;
  var st = Lr;
  var ot = s;
  var it = e(Object.freeze({ __proto__: null, decode: Gr, encode: Hr, toUnicode: Jr, toASCII: Wr, version: "1.4.1", ucs2: Yr, default: Kr }));
  var at = { default: { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, zero: { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, commonmark: { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } } };
  var ct = /^(vbscript|javascript|file|data):/;
  var lt = /^data:image\/(gif|png|jpeg|webp);/;
  function ut(e3) {
    var r3 = e3.trim().toLowerCase();
    return !ct.test(r3) || !!lt.test(r3);
  }
  var pt = ["http:", "https:", "mailto:"];
  function ht(e3) {
    var r3 = ot.parse(e3, true);
    if (r3.hostname && (!r3.protocol || pt.indexOf(r3.protocol) >= 0))
      try {
        r3.hostname = it.toASCII(r3.hostname);
      } catch (e4) {
      }
    return ot.encode(ot.format(r3));
  }
  function ft(e3) {
    var r3 = ot.parse(e3, true);
    if (r3.hostname && (!r3.protocol || pt.indexOf(r3.protocol) >= 0))
      try {
        r3.hostname = it.toUnicode(r3.hostname);
      } catch (e4) {
      }
    return ot.decode(ot.format(r3), ot.decode.defaultChars + "%");
  }
  function dt(e3, r3) {
    if (!(this instanceof dt))
      return new dt(e3, r3);
    r3 || Qr.isString(e3) || (r3 = e3 || {}, e3 = "default"), this.inline = new nt(), this.block = new tt(), this.core = new rt(), this.renderer = new et(), this.linkify = new st(), this.validateLink = ut, this.normalizeLink = ht, this.normalizeLinkText = ft, this.utils = Qr, this.helpers = Qr.assign({}, Xr), this.options = {}, this.configure(e3), r3 && this.set(r3);
  }
  dt.prototype.set = function(e3) {
    return Qr.assign(this.options, e3), this;
  }, dt.prototype.configure = function(e3) {
    var r3, t3 = this;
    if (Qr.isString(e3) && !(e3 = at[r3 = e3]))
      throw new Error('Wrong `markdown-it` preset "' + r3 + '", check name');
    if (!e3)
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    return e3.options && t3.set(e3.options), e3.components && Object.keys(e3.components).forEach(function(r4) {
      e3.components[r4].rules && t3[r4].ruler.enableOnly(e3.components[r4].rules), e3.components[r4].rules2 && t3[r4].ruler2.enableOnly(e3.components[r4].rules2);
    }), this;
  }, dt.prototype.enable = function(e3, r3) {
    var t3 = [];
    Array.isArray(e3) || (e3 = [e3]), ["core", "block", "inline"].forEach(function(r4) {
      t3 = t3.concat(this[r4].ruler.enable(e3, true));
    }, this), t3 = t3.concat(this.inline.ruler2.enable(e3, true));
    var n3 = e3.filter(function(e4) {
      return t3.indexOf(e4) < 0;
    });
    if (n3.length && !r3)
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + n3);
    return this;
  }, dt.prototype.disable = function(e3, r3) {
    var t3 = [];
    Array.isArray(e3) || (e3 = [e3]), ["core", "block", "inline"].forEach(function(r4) {
      t3 = t3.concat(this[r4].ruler.disable(e3, true));
    }, this), t3 = t3.concat(this.inline.ruler2.disable(e3, true));
    var n3 = e3.filter(function(e4) {
      return t3.indexOf(e4) < 0;
    });
    if (n3.length && !r3)
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + n3);
    return this;
  }, dt.prototype.use = function(e3) {
    var r3 = [this].concat(Array.prototype.slice.call(arguments, 1));
    return e3.apply(e3, r3), this;
  }, dt.prototype.parse = function(e3, r3) {
    if ("string" != typeof e3)
      throw new Error("Input data should be a String");
    var t3 = new this.core.State(e3, this, r3);
    return this.core.process(t3), t3.tokens;
  }, dt.prototype.render = function(e3, r3) {
    return r3 = r3 || {}, this.renderer.render(this.parse(e3, r3), this.options, r3);
  }, dt.prototype.parseInline = function(e3, r3) {
    var t3 = new this.core.State(e3, this, r3);
    return t3.inlineMode = true, this.core.process(t3), t3.tokens;
  }, dt.prototype.renderInline = function(e3, r3) {
    return r3 = r3 || {}, this.renderer.render(this.parseInline(e3, r3), this.options, r3);
  };
  var mt = dt;
  var markdown_it_min_default = mt;

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/highlight/uni-highlight.min.js
  var e2 = {
    exports: {}
  };
  function n2(e3) {
    return e3 instanceof Map ? e3.clear = e3.delete = e3.set = () => {
      throw Error("map is read-only");
    } : e3 instanceof Set && (e3.add = e3.clear = e3.delete = () => {
      throw Error("set is read-only");
    }), Object.freeze(e3), Object.getOwnPropertyNames(e3).forEach((t3) => {
      var a4 = e3[t3];
      "object" != typeof a4 || Object.isFrozen(a4) || n2(a4);
    }), e3;
  }
  e2.exports = n2, e2.exports.default = n2;
  var t2 = class {
    constructor(e3) {
      void 0 === e3.data && (e3.data = {}), this.data = e3.data, this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  };
  function a2(e3) {
    return e3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(
      /'/g,
      "&#x27;"
    );
  }
  function i2(e3, ...n3) {
    const t3 = /* @__PURE__ */ Object.create(null);
    for (const n4 in e3)
      t3[n4] = e3[n4];
    return n3.forEach((e4) => {
      for (const n4 in e4)
        t3[n4] = e4[n4];
    }), t3;
  }
  var r2 = (e3) => !!e3.scope || e3.sublanguage && e3.language;
  var s2 = class {
    constructor(e3, n3) {
      this.buffer = "", this.classPrefix = n3.classPrefix, e3.walk(this);
    }
    addText(e3) {
      this.buffer += a2(e3);
    }
    openNode(e3) {
      if (!r2(e3))
        return;
      let n3 = "";
      n3 = e3.sublanguage ? "language-" + e3.language : ((e4, {
        prefix: n4
      }) => {
        if (e4.includes(".")) {
          const t3 = e4.split(".");
          return [`${n4}${t3.shift()}`, ...t3.map((e5, n5) => `${e5}${"_".repeat(n5 + 1)}`)].join(" ");
        }
        return `${n4}${e4}`;
      })(e3.scope, {
        prefix: this.classPrefix
      }), this.span(n3);
    }
    closeNode(e3) {
      r2(e3) && (this.buffer += "</span>");
    }
    value() {
      return this.buffer;
    }
    span(e3) {
      this.buffer += `<span class="${e3}">`;
    }
  };
  var o2 = (e3 = {}) => {
    const n3 = {
      children: []
    };
    return Object.assign(n3, e3), n3;
  };
  var l2 = class _l {
    constructor() {
      this.rootNode = o2(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(e3) {
      this.top.children.push(e3);
    }
    openNode(e3) {
      const n3 = o2({
        scope: e3
      });
      this.add(n3), this.stack.push(n3);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); )
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(e3) {
      return this.constructor._walk(e3, this.rootNode);
    }
    static _walk(e3, n3) {
      return "string" == typeof n3 ? e3.addText(n3) : n3.children && (e3.openNode(n3), n3.children.forEach((n4) => this._walk(e3, n4)), e3.closeNode(n3)), e3;
    }
    static _collapse(e3) {
      "string" != typeof e3 && e3.children && (e3.children.every((e4) => "string" == typeof e4) ? e3.children = [
        e3.children.join("")
      ] : e3.children.forEach((e4) => {
        _l._collapse(e4);
      }));
    }
  };
  var c2 = class extends l2 {
    constructor(e3) {
      super(), this.options = e3;
    }
    addKeyword(e3, n3) {
      "" !== e3 && (this.openNode(n3), this.addText(e3), this.closeNode());
    }
    addText(e3) {
      "" !== e3 && this.add(e3);
    }
    addSublanguage(e3, n3) {
      const t3 = e3.root;
      t3.sublanguage = true, t3.language = n3, this.add(t3);
    }
    toHTML() {
      return new s2(this, this.options).value();
    }
    finalize() {
      return true;
    }
  };
  function d2(e3) {
    return e3 ? "string" == typeof e3 ? e3 : e3.source : null;
  }
  function g2(e3) {
    return m2("(?=", e3, ")");
  }
  function u2(e3) {
    return m2("(?:", e3, ")*");
  }
  function b2(e3) {
    return m2("(?:", e3, ")?");
  }
  function m2(...e3) {
    return e3.map((e4) => d2(e4)).join("");
  }
  function p2(...e3) {
    const n3 = ((e4) => {
      const n4 = e4[e4.length - 1];
      return "object" == typeof n4 && n4.constructor === Object ? (e4.splice(e4.length - 1, 1), n4) : {};
    })(e3);
    return "(" + (n3.capture ? "" : "?:") + e3.map((e4) => d2(e4)).join("|") + ")";
  }
  function _2(e3) {
    return RegExp(e3.toString() + "|").exec("").length - 1;
  }
  var h2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function f2(e3, {
    joinWith: n3
  }) {
    let t3 = 0;
    return e3.map((e4) => {
      t3 += 1;
      const n4 = t3;
      let a4 = d2(e4), i4 = "";
      for (; a4.length > 0; ) {
        const e5 = h2.exec(a4);
        if (!e5) {
          i4 += a4;
          break;
        }
        i4 += a4.substring(0, e5.index), a4 = a4.substring(e5.index + e5[0].length), "\\" === e5[0][0] && e5[1] ? i4 += "\\" + (Number(e5[1]) + n4) : (i4 += e5[0], "(" === e5[0] && t3++);
      }
      return i4;
    }).map((e4) => `(${e4})`).join(n3);
  }
  var E2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  var y2 = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  var w2 = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [y2]
  };
  var N2 = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [y2]
  };
  var v2 = (e3, n3, t3 = {}) => {
    const a4 = i2({
      scope: "comment",
      begin: e3,
      end: n3,
      contains: []
    }, t3);
    a4.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: true,
      relevance: 0
    });
    const r3 = p2(
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      /[A-Za-z]+[-][a-z]+/,
      /[A-Za-z][a-z]{2,}/
    );
    return a4.contains.push({
      begin: m2(/[ ]+/, "(", r3, /[.]?[:]?([.][ ]|[ ])/, "){3}")
    }), a4;
  };
  var O2 = v2("//", "$");
  var k2 = v2("/\\*", "\\*/");
  var x2 = v2("#", "$");
  var M2 = Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: /\b\B/,
    IDENT_RE: "[a-zA-Z]\\w*",
    UNDERSCORE_IDENT_RE: "[a-zA-Z_]\\w*",
    NUMBER_RE: "\\b\\d+(\\.\\d+)?",
    C_NUMBER_RE: E2,
    BINARY_NUMBER_RE: "\\b(0b[01]+)",
    RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
    SHEBANG: (e3 = {}) => {
      const n3 = /^#![ ]*\//;
      return e3.binary && (e3.begin = m2(n3, /.*\b/, e3.binary, /\b.*/)), i2({
        scope: "meta",
        begin: n3,
        end: /$/,
        relevance: 0,
        "on:begin": (e4, n4) => {
          0 !== e4.index && n4.ignoreMatch();
        }
      }, e3);
    },
    BACKSLASH_ESCAPE: y2,
    APOS_STRING_MODE: w2,
    QUOTE_STRING_MODE: N2,
    PHRASAL_WORDS_MODE: {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    },
    COMMENT: v2,
    C_LINE_COMMENT_MODE: O2,
    C_BLOCK_COMMENT_MODE: k2,
    HASH_COMMENT_MODE: x2,
    NUMBER_MODE: {
      scope: "number",
      begin: "\\b\\d+(\\.\\d+)?",
      relevance: 0
    },
    C_NUMBER_MODE: {
      scope: "number",
      begin: E2,
      relevance: 0
    },
    BINARY_NUMBER_MODE: {
      scope: "number",
      begin: "\\b(0b[01]+)",
      relevance: 0
    },
    REGEXP_MODE: {
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        scope: "regexp",
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [y2, {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [y2]
        }]
      }]
    },
    TITLE_MODE: {
      scope: "title",
      begin: "[a-zA-Z]\\w*",
      relevance: 0
    },
    UNDERSCORE_TITLE_MODE: {
      scope: "title",
      begin: "[a-zA-Z_]\\w*",
      relevance: 0
    },
    METHOD_GUARD: {
      begin: "\\.\\s*[a-zA-Z_]\\w*",
      relevance: 0
    },
    END_SAME_AS_BEGIN: (e3) => Object.assign(e3, {
      "on:begin": (e4, n3) => {
        n3.data._beginMatch = e4[1];
      },
      "on:end": (e4, n3) => {
        n3.data._beginMatch !== e4[1] && n3.ignoreMatch();
      }
    })
  });
  function S2(e3, n3) {
    "." === e3.input[e3.index - 1] && n3.ignoreMatch();
  }
  function A2(e3, n3) {
    void 0 !== e3.className && (e3.scope = e3.className, delete e3.className);
  }
  function C2(e3, n3) {
    n3 && e3.beginKeywords && (e3.begin = "\\b(" + e3.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e3.__beforeBegin = S2, e3.keywords = e3.keywords || e3.beginKeywords, delete e3.beginKeywords, void 0 === e3.relevance && (e3.relevance = 0));
  }
  function T2(e3, n3) {
    Array.isArray(e3.illegal) && (e3.illegal = p2(...e3.illegal));
  }
  function R2(e3, n3) {
    if (e3.match) {
      if (e3.begin || e3.end)
        throw Error("begin & end are not supported with match");
      e3.begin = e3.match, delete e3.match;
    }
  }
  function D2(e3, n3) {
    void 0 === e3.relevance && (e3.relevance = 1);
  }
  var I2 = (e3, n3) => {
    if (!e3.beforeMatch)
      return;
    if (e3.starts)
      throw Error("beforeMatch cannot be used with starts");
    const t3 = Object.assign({}, e3);
    Object.keys(e3).forEach((n4) => {
      delete e3[n4];
    }), e3.keywords = t3.keywords, e3.begin = m2(t3.beforeMatch, g2(t3.begin)), e3.starts = {
      relevance: 0,
      contains: [Object.assign(t3, {
        endsParent: true
      })]
    }, e3.relevance = 0, delete t3.beforeMatch;
  };
  var L2 = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"];
  function B2(e3, n3, t3 = "keyword") {
    const a4 = /* @__PURE__ */ Object.create(null);
    return "string" == typeof e3 ? i4(t3, e3.split(" ")) : Array.isArray(e3) ? i4(t3, e3) : Object.keys(e3).forEach((t4) => {
      Object.assign(a4, B2(e3[t4], n3, t4));
    }), a4;
    function i4(e4, t4) {
      n3 && (t4 = t4.map((e5) => e5.toLowerCase())), t4.forEach((n4) => {
        const t5 = n4.split("|");
        a4[t5[0]] = [e4, $2(t5[0], t5[1])];
      });
    }
  }
  function $2(e3, n3) {
    return n3 ? Number(n3) : ((e4) => L2.includes(e4.toLowerCase()))(e3) ? 0 : 1;
  }
  var z2 = {};
  var F2 = (e3) => {
    console.error(e3);
  };
  var U2 = (e3, ...n3) => {
    console.log("WARN: " + e3, ...n3);
  };
  var j2 = (e3, n3) => {
    z2[`${e3}/${n3}`] || (console.log(`Deprecated as of ${e3}. ${n3}`), z2[`${e3}/${n3}`] = true);
  };
  var P2 = Error();
  function K2(e3, n3, {
    key: t3
  }) {
    let a4 = 0;
    const i4 = e3[t3], r3 = {}, s3 = {};
    for (let e4 = 1; e4 <= n3.length; e4++)
      s3[e4 + a4] = i4[e4], r3[e4 + a4] = true, a4 += _2(n3[e4 - 1]);
    e3[t3] = s3, e3[t3]._emit = r3, e3[t3]._multi = true;
  }
  function H2(e3) {
    ((e4) => {
      e4.scope && "object" == typeof e4.scope && null !== e4.scope && (e4.beginScope = e4.scope, delete e4.scope);
    })(e3), "string" == typeof e3.beginScope && (e3.beginScope = {
      _wrap: e3.beginScope
    }), "string" == typeof e3.endScope && (e3.endScope = {
      _wrap: e3.endScope
    }), ((e4) => {
      if (Array.isArray(e4.begin)) {
        if (e4.skip || e4.excludeBegin || e4.returnBegin)
          throw F2(
            "skip, excludeBegin, returnBegin not compatible with beginScope: {}"
          ), P2;
        if ("object" != typeof e4.beginScope || null === e4.beginScope)
          throw F2("beginScope must be object"), P2;
        K2(e4, e4.begin, {
          key: "beginScope"
        }), e4.begin = f2(e4.begin, {
          joinWith: ""
        });
      }
    })(e3), ((e4) => {
      if (Array.isArray(e4.end)) {
        if (e4.skip || e4.excludeEnd || e4.returnEnd)
          throw F2(
            "skip, excludeEnd, returnEnd not compatible with endScope: {}"
          ), P2;
        if ("object" != typeof e4.endScope || null === e4.endScope)
          throw F2("endScope must be object"), P2;
        K2(e4, e4.end, {
          key: "endScope"
        }), e4.end = f2(e4.end, {
          joinWith: ""
        });
      }
    })(e3);
  }
  function q2(e3) {
    function n3(n4, t4) {
      return RegExp(d2(n4), "m" + (e3.case_insensitive ? "i" : "") + (e3.unicodeRegex ? "u" : "") + (t4 ? "g" : ""));
    }
    class t3 {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      addRule(e4, n4) {
        n4.position = this.position++, this.matchIndexes[this.matchAt] = n4, this.regexes.push([n4, e4]), this.matchAt += _2(e4) + 1;
      }
      compile() {
        0 === this.regexes.length && (this.exec = () => null);
        const e4 = this.regexes.map((e5) => e5[1]);
        this.matcherRe = n3(f2(e4, {
          joinWith: "|"
        }), true), this.lastIndex = 0;
      }
      exec(e4) {
        this.matcherRe.lastIndex = this.lastIndex;
        const n4 = this.matcherRe.exec(e4);
        if (!n4)
          return null;
        const t4 = n4.findIndex((e5, n5) => n5 > 0 && void 0 !== e5), a5 = this.matchIndexes[t4];
        return n4.splice(0, t4), Object.assign(n4, a5);
      }
    }
    class a4 {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      getMatcher(e4) {
        if (this.multiRegexes[e4])
          return this.multiRegexes[e4];
        const n4 = new t3();
        return this.rules.slice(e4).forEach(([e5, t4]) => n4.addRule(e5, t4)), n4.compile(), this.multiRegexes[e4] = n4, n4;
      }
      resumingScanAtSamePosition() {
        return 0 !== this.regexIndex;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(e4, n4) {
        this.rules.push([e4, n4]), "begin" === n4.type && this.count++;
      }
      exec(e4) {
        const n4 = this.getMatcher(this.regexIndex);
        n4.lastIndex = this.lastIndex;
        let t4 = n4.exec(e4);
        if (this.resumingScanAtSamePosition())
          if (t4 && t4.index === this.lastIndex)
            ;
          else {
            const n5 = this.getMatcher(0);
            n5.lastIndex = this.lastIndex + 1, t4 = n5.exec(e4);
          }
        return t4 && (this.regexIndex += t4.position + 1, this.regexIndex === this.count && this.considerAll()), t4;
      }
    }
    if (e3.compilerExtensions || (e3.compilerExtensions = []), e3.contains && e3.contains.includes("self"))
      throw Error(
        "ERR: contains `self` is not supported at the top-level of a language.  See documentation."
      );
    return e3.classNameAliases = i2(e3.classNameAliases || {}), function t4(r3, s3) {
      const o4 = r3;
      if (r3.isCompiled)
        return o4;
      [A2, R2, H2, I2].forEach((e4) => e4(r3, s3)), e3.compilerExtensions.forEach((e4) => e4(r3, s3)), r3.__beforeBegin = null, [C2, T2, D2].forEach((e4) => e4(r3, s3)), r3.isCompiled = true;
      let l4 = null;
      return "object" == typeof r3.keywords && r3.keywords.$pattern && (r3.keywords = Object.assign({}, r3.keywords), l4 = r3.keywords.$pattern, delete r3.keywords.$pattern), l4 = l4 || /\w+/, r3.keywords && (r3.keywords = B2(r3.keywords, e3.case_insensitive)), o4.keywordPatternRe = n3(l4, true), s3 && (r3.begin || (r3.begin = /\B|\b/), o4.beginRe = n3(o4.begin), r3.end || r3.endsWithParent || (r3.end = /\B|\b/), r3.end && (o4.endRe = n3(o4.end)), o4.terminatorEnd = d2(o4.end) || "", r3.endsWithParent && s3.terminatorEnd && (o4.terminatorEnd += (r3.end ? "|" : "") + s3.terminatorEnd)), r3.illegal && (o4.illegalRe = n3(r3.illegal)), r3.contains || (r3.contains = []), r3.contains = [].concat(...r3.contains.map((e4) => ((e5) => (e5.variants && !e5.cachedVariants && (e5.cachedVariants = e5.variants.map((n4) => i2(e5, {
        variants: null
      }, n4))), e5.cachedVariants ? e5.cachedVariants : Z2(e5) ? i2(e5, {
        starts: e5.starts ? i2(e5.starts) : null
      }) : Object.isFrozen(e5) ? i2(e5) : e5))("self" === e4 ? r3 : e4))), r3.contains.forEach((e4) => {
        t4(e4, o4);
      }), r3.starts && t4(r3.starts, s3), o4.matcher = ((e4) => {
        const n4 = new a4();
        return e4.contains.forEach((e5) => n4.addRule(e5.begin, {
          rule: e5,
          type: "begin"
        })), e4.terminatorEnd && n4.addRule(e4.terminatorEnd, {
          type: "end"
        }), e4.illegal && n4.addRule(e4.illegal, {
          type: "illegal"
        }), n4;
      })(o4), o4;
    }(e3);
  }
  function Z2(e3) {
    return !!e3 && (e3.endsWithParent || Z2(e3.starts));
  }
  var G2 = class extends Error {
    constructor(e3, n3) {
      super(e3), this.name = "HTMLInjectionError", this.html = n3;
    }
  };
  var W2 = a2;
  var Q2 = i2;
  var X2 = Symbol("nomatch");
  var V2 = ((n3) => {
    const a4 = /* @__PURE__ */ Object.create(null), i4 = /* @__PURE__ */ Object.create(null), r3 = [];
    let s3 = true;
    const o4 = "Could not find the language '{}', did you forget to load/include a language module?", l4 = {
      disableAutodetect: true,
      name: "Plain text",
      contains: []
    };
    let d3 = {
      ignoreUnescapedHTML: false,
      throwUnescapedHTML: false,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: c2
    };
    function _4(e3) {
      return d3.noHighlightRe.test(e3);
    }
    function h3(e3, n4, t3) {
      let a5 = "", i5 = "";
      "object" == typeof n4 ? (a5 = e3, t3 = n4.ignoreIllegals, i5 = n4.language) : (j2("10.7.0", "highlight(lang, code, ...args) has been deprecated."), j2(
        "10.7.0",
        "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"
      ), i5 = e3, a5 = n4), void 0 === t3 && (t3 = true);
      const r4 = {
        code: a5,
        language: i5
      };
      x3("before:highlight", r4);
      const s4 = r4.result ? r4.result : f4(r4.language, r4.code, t3);
      return s4.code = r4.code, x3("after:highlight", s4), s4;
    }
    function f4(e3, n4, i5, r4) {
      const l5 = /* @__PURE__ */ Object.create(null);
      function c3() {
        if (!k5.keywords)
          return void M3.addText(S4);
        let e4 = 0;
        k5.keywordPatternRe.lastIndex = 0;
        let n5 = k5.keywordPatternRe.exec(S4), t3 = "";
        for (; n5; ) {
          t3 += S4.substring(e4, n5.index);
          const i6 = w4.case_insensitive ? n5[0].toLowerCase() : n5[0], r5 = (a5 = i6, k5.keywords[a5]);
          if (r5) {
            const [e5, a6] = r5;
            if (M3.addText(t3), t3 = "", l5[i6] = (l5[i6] || 0) + 1, l5[i6] <= 7 && (A4 += a6), e5.startsWith("_"))
              t3 += n5[0];
            else {
              const t4 = w4.classNameAliases[e5] || e5;
              M3.addKeyword(n5[0], t4);
            }
          } else
            t3 += n5[0];
          e4 = k5.keywordPatternRe.lastIndex, n5 = k5.keywordPatternRe.exec(S4);
        }
        var a5;
        t3 += S4.substring(e4), M3.addText(t3);
      }
      function g4() {
        null != k5.subLanguage ? (() => {
          if ("" === S4)
            return;
          let e4 = null;
          if ("string" == typeof k5.subLanguage) {
            if (!a4[k5.subLanguage])
              return void M3.addText(S4);
            e4 = f4(k5.subLanguage, S4, true, x4[k5.subLanguage]), x4[k5.subLanguage] = e4._top;
          } else
            e4 = E4(S4, k5.subLanguage.length ? k5.subLanguage : null);
          k5.relevance > 0 && (A4 += e4.relevance), M3.addSublanguage(e4._emitter, e4.language);
        })() : c3(), S4 = "";
      }
      function u4(e4, n5) {
        let t3 = 1;
        const a5 = n5.length - 1;
        for (; t3 <= a5; ) {
          if (!e4._emit[t3]) {
            t3++;
            continue;
          }
          const a6 = w4.classNameAliases[e4[t3]] || e4[t3], i6 = n5[t3];
          a6 ? M3.addKeyword(i6, a6) : (S4 = i6, c3(), S4 = ""), t3++;
        }
      }
      function b3(e4, n5) {
        return e4.scope && "string" == typeof e4.scope && M3.openNode(w4.classNameAliases[e4.scope] || e4.scope), e4.beginScope && (e4.beginScope._wrap ? (M3.addKeyword(S4, w4.classNameAliases[e4.beginScope._wrap] || e4.beginScope._wrap), S4 = "") : e4.beginScope._multi && (u4(e4.beginScope, n5), S4 = "")), k5 = Object.create(e4, {
          parent: {
            value: k5
          }
        }), k5;
      }
      function m3(e4, n5, a5) {
        let i6 = ((e5, n6) => {
          const t3 = e5 && e5.exec(n6);
          return t3 && 0 === t3.index;
        })(e4.endRe, a5);
        if (i6) {
          if (e4["on:end"]) {
            const a6 = new t2(e4);
            e4["on:end"](n5, a6), a6.isMatchIgnored && (i6 = false);
          }
          if (i6) {
            for (; e4.endsParent && e4.parent; )
              e4 = e4.parent;
            return e4;
          }
        }
        if (e4.endsWithParent)
          return m3(e4.parent, n5, a5);
      }
      function p3(e4) {
        return 0 === k5.matcher.regexIndex ? (S4 += e4[0], 1) : (R3 = true, 0);
      }
      function _5(e4) {
        const t3 = e4[0], a5 = n4.substring(e4.index), i6 = m3(k5, e4, a5);
        if (!i6)
          return X2;
        const r5 = k5;
        k5.endScope && k5.endScope._wrap ? (g4(), M3.addKeyword(t3, k5.endScope._wrap)) : k5.endScope && k5.endScope._multi ? (g4(), u4(k5.endScope, e4)) : r5.skip ? S4 += t3 : (r5.returnEnd || r5.excludeEnd || (S4 += t3), g4(), r5.excludeEnd && (S4 = t3));
        do {
          k5.scope && M3.closeNode(), k5.skip || k5.subLanguage || (A4 += k5.relevance), k5 = k5.parent;
        } while (k5 !== i6.parent);
        return i6.starts && b3(i6.starts, e4), r5.returnEnd ? 0 : t3.length;
      }
      let h4 = {};
      function y4(a5, r5) {
        const o5 = r5 && r5[0];
        if (S4 += a5, null == o5)
          return g4(), 0;
        if ("begin" === h4.type && "end" === r5.type && h4.index === r5.index && "" === o5) {
          if (S4 += n4.slice(r5.index, r5.index + 1), !s3) {
            const n5 = Error(`0 width match regex (${e3})`);
            throw n5.languageName = e3, n5.badRule = h4.rule, n5;
          }
          return 1;
        }
        if (h4 = r5, "begin" === r5.type)
          return ((e4) => {
            const n5 = e4[0], a6 = e4.rule, i6 = new t2(a6), r6 = [a6.__beforeBegin, a6["on:begin"]];
            for (const t3 of r6)
              if (t3 && (t3(e4, i6), i6.isMatchIgnored))
                return p3(n5);
            return a6.skip ? S4 += n5 : (a6.excludeBegin && (S4 += n5), g4(), a6.returnBegin || a6.excludeBegin || (S4 = n5)), b3(a6, e4), a6.returnBegin ? 0 : n5.length;
          })(r5);
        if ("illegal" === r5.type && !i5) {
          const e4 = Error('Illegal lexeme "' + o5 + '" for mode "' + (k5.scope || "<unnamed>") + '"');
          throw e4.mode = k5, e4;
        }
        if ("end" === r5.type) {
          const e4 = _5(r5);
          if (e4 !== X2)
            return e4;
        }
        if ("illegal" === r5.type && "" === o5)
          return 1;
        if (T5 > 1e5 && T5 > 3 * r5.index)
          throw Error("potential infinite loop, way more iterations than matches");
        return S4 += o5, o5.length;
      }
      const w4 = v3(e3);
      if (!w4)
        throw F2(o4.replace("{}", e3)), Error('Unknown language: "' + e3 + '"');
      const N5 = q2(w4);
      let O5 = "", k5 = r4 || N5;
      const x4 = {}, M3 = new d3.__emitter(d3);
      (() => {
        const e4 = [];
        for (let n5 = k5; n5 !== w4; n5 = n5.parent)
          n5.scope && e4.unshift(n5.scope);
        e4.forEach((e5) => M3.openNode(e5));
      })();
      let S4 = "", A4 = 0, C3 = 0, T5 = 0, R3 = false;
      try {
        for (k5.matcher.considerAll(); ; ) {
          T5++, R3 ? R3 = false : k5.matcher.considerAll(), k5.matcher.lastIndex = C3;
          const e4 = k5.matcher.exec(n4);
          if (!e4)
            break;
          const t3 = y4(n4.substring(C3, e4.index), e4);
          C3 = e4.index + t3;
        }
        return y4(n4.substring(C3)), M3.closeAllNodes(), M3.finalize(), O5 = M3.toHTML(), {
          language: e3,
          value: O5,
          relevance: A4,
          illegal: false,
          _emitter: M3,
          _top: k5
        };
      } catch (t3) {
        if (t3.message && t3.message.includes("Illegal"))
          return {
            language: e3,
            value: W2(n4),
            illegal: true,
            relevance: 0,
            _illegalBy: {
              message: t3.message,
              index: C3,
              context: n4.slice(C3 - 100, C3 + 100),
              mode: t3.mode,
              resultSoFar: O5
            },
            _emitter: M3
          };
        if (s3)
          return {
            language: e3,
            value: W2(n4),
            illegal: false,
            relevance: 0,
            errorRaised: t3,
            _emitter: M3,
            _top: k5
          };
        throw t3;
      }
    }
    function E4(e3, n4) {
      n4 = n4 || d3.languages || Object.keys(a4);
      const t3 = ((e4) => {
        const n5 = {
          value: W2(e4),
          illegal: false,
          relevance: 0,
          _top: l4,
          _emitter: new d3.__emitter(d3)
        };
        return n5._emitter.addText(e4), n5;
      })(e3), i5 = n4.filter(v3).filter(k4).map((n5) => f4(n5, e3, false));
      i5.unshift(t3);
      const r4 = i5.sort((e4, n5) => {
        if (e4.relevance !== n5.relevance)
          return n5.relevance - e4.relevance;
        if (e4.language && n5.language) {
          if (v3(e4.language).supersetOf === n5.language)
            return 1;
          if (v3(n5.language).supersetOf === e4.language)
            return -1;
        }
        return 0;
      }), [s4, o5] = r4, c3 = s4;
      return c3.secondBest = o5, c3;
    }
    function y3(e3) {
      let n4 = null;
      const t3 = ((e4) => {
        let n5 = e4.className + " ";
        n5 += e4.parentNode ? e4.parentNode.className : "";
        const t4 = d3.languageDetectRe.exec(n5);
        if (t4) {
          const n6 = v3(t4[1]);
          return n6 || (U2(o4.replace("{}", t4[1])), U2("Falling back to no-highlight mode for this block.", e4)), n6 ? t4[1] : "no-highlight";
        }
        return n5.split(/\s+/).find((e5) => _4(e5) || v3(e5));
      })(e3);
      if (_4(t3))
        return;
      if (x3("before:highlightElement", {
        el: e3,
        language: t3
      }), e3.children.length > 0 && (d3.ignoreUnescapedHTML || (console.warn(
        "One of your code blocks includes unescaped HTML. This is a potentially serious security risk."
      ), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(e3)), d3.throwUnescapedHTML))
        throw new G2("One of your code blocks includes unescaped HTML.", e3.innerHTML);
      n4 = e3;
      const a5 = n4.textContent, r4 = t3 ? h3(a5, {
        language: t3,
        ignoreIllegals: true
      }) : E4(a5);
      e3.innerHTML = r4.value, ((e4, n5, t4) => {
        const a6 = n5 && i4[n5] || t4;
        e4.classList.add("hljs"), e4.classList.add("language-" + a6);
      })(e3, t3, r4.language), e3.result = {
        language: r4.language,
        re: r4.relevance,
        relevance: r4.relevance
      }, r4.secondBest && (e3.secondBest = {
        language: r4.secondBest.language,
        relevance: r4.secondBest.relevance
      }), x3("after:highlightElement", {
        el: e3,
        result: r4,
        text: a5
      });
    }
    let w3 = false;
    function N4() {
      "loading" !== document.readyState ? document.querySelectorAll(d3.cssSelector).forEach(y3) : w3 = true;
    }
    function v3(e3) {
      return e3 = (e3 || "").toLowerCase(), a4[e3] || a4[i4[e3]];
    }
    function O4(e3, {
      languageName: n4
    }) {
      "string" == typeof e3 && (e3 = [e3]), e3.forEach((e4) => {
        i4[e4.toLowerCase()] = n4;
      });
    }
    function k4(e3) {
      const n4 = v3(e3);
      return n4 && !n4.disableAutodetect;
    }
    function x3(e3, n4) {
      const t3 = e3;
      r3.forEach((e4) => {
        e4[t3] && e4[t3](n4);
      });
    }
    "undefined" != typeof window && window.addEventListener && window.addEventListener("DOMContentLoaded", () => {
      w3 && N4();
    }, false), Object.assign(n3, {
      highlight: h3,
      highlightAuto: E4,
      highlightAll: N4,
      highlightElement: y3,
      highlightBlock: (e3) => (j2("10.7.0", "highlightBlock will be removed entirely in v12.0"), j2("10.7.0", "Please use highlightElement now."), y3(e3)),
      configure: (e3) => {
        d3 = Q2(d3, e3);
      },
      initHighlighting: () => {
        N4(), j2("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      },
      initHighlightingOnLoad: () => {
        N4(), j2("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      },
      registerLanguage: (e3, t3) => {
        let i5 = null;
        try {
          i5 = t3(n3);
        } catch (n4) {
          if (F2("Language definition for '{}' could not be registered.".replace("{}", e3)), !s3)
            throw n4;
          F2(n4), i5 = l4;
        }
        i5.name || (i5.name = e3), a4[e3] = i5, i5.rawDefinition = t3.bind(null, n3), i5.aliases && O4(i5.aliases, {
          languageName: e3
        });
      },
      unregisterLanguage: (e3) => {
        delete a4[e3];
        for (const n4 of Object.keys(i4))
          i4[n4] === e3 && delete i4[n4];
      },
      listLanguages: () => Object.keys(a4),
      getLanguage: v3,
      registerAliases: O4,
      autoDetection: k4,
      inherit: Q2,
      addPlugin: (e3) => {
        ((e4) => {
          e4["before:highlightBlock"] && !e4["before:highlightElement"] && (e4["before:highlightElement"] = (n4) => {
            e4["before:highlightBlock"](Object.assign({
              block: n4.el
            }, n4));
          }), e4["after:highlightBlock"] && !e4["after:highlightElement"] && (e4["after:highlightElement"] = (n4) => {
            e4["after:highlightBlock"](Object.assign({
              block: n4.el
            }, n4));
          });
        })(e3), r3.push(e3);
      }
    }), n3.debugMode = () => {
      s3 = false;
    }, n3.safeMode = () => {
      s3 = true;
    }, n3.versionString = "11.7.0", n3.regex = {
      concat: m2,
      lookahead: g2,
      either: p2,
      optional: b2,
      anyNumberOfTimes: u2
    };
    for (const n4 in M2)
      "object" == typeof M2[n4] && e2.exports(M2[n4]);
    return Object.assign(n3, M2), n3;
  })({});
  var J2 = (e3) => ({
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: e3.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: e3.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  });
  var Y2 = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "p",
    "q",
    "quote",
    "samp",
    "section",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video"
  ];
  var ee2 = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ];
  var ne2 = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
  ];
  var te2 = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ];
  var ae2 = [
    "align-content",
    "align-items",
    "align-self",
    "all",
    "animation",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timing-function",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-repeat",
    "background-size",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "direction",
    "display",
    "empty-cells",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-size",
    "font-size-adjust",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-variant",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "gap",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "inline-size",
    "isolation",
    "justify-content",
    "left",
    "letter-spacing",
    "line-break",
    "line-height",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "pointer-events",
    "position",
    "quotes",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "row-gap",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "speak",
    "speak-as",
    "src",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-style",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-transform",
    "text-underline-position",
    "top",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "unicode-bidi",
    "vertical-align",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "z-index"
  ].reverse();
  var ie2 = ne2.concat(te2);
  var re2 = "\\.([0-9](_*[0-9])*)";
  var se2 = "[0-9a-fA-F](_*[0-9a-fA-F])*";
  var oe2 = {
    className: "number",
    variants: [{
      begin: `(\\b([0-9](_*[0-9])*)((${re2})|\\.)?|(${re2}))[eE][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
    }, {
      begin: `\\b([0-9](_*[0-9])*)((${re2})[fFdD]?\\b|\\.([fFdD]\\b)?)`
    }, {
      begin: `(${re2})[fFdD]?\\b`
    }, {
      begin: "\\b([0-9](_*[0-9])*)[fFdD]\\b"
    }, {
      begin: `\\b0[xX]((${se2})\\.?|(${se2})?\\.(${se2}))[pP][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
    }, {
      begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b"
    }, {
      begin: `\\b0[xX](${se2})[lL]?\\b`
    }, {
      begin: "\\b0(_*[0-7])*[lL]?\\b"
    }, {
      begin: "\\b0[bB][01](_*[01])*[lL]?\\b"
    }],
    relevance: 0
  };
  function le2(e3, n3, t3) {
    return -1 === t3 ? "" : e3.replace(n3, (a4) => le2(e3, n3, t3 - 1));
  }
  var ce2 = "[A-Za-z$_][0-9A-Za-z$_]*";
  var de2 = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  var ge2 = ["true", "false", "null", "undefined", "NaN", "Infinity"];
  var ue2 = [
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    "Math",
    "Date",
    "Number",
    "BigInt",
    "String",
    "RegExp",
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    "Reflect",
    "Proxy",
    "Intl",
    "WebAssembly"
  ];
  var be2 = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"];
  var me2 = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  var pe2 = ["arguments", "this", "super", "console", "window", "document", "localStorage", "module", "global"];
  var _e2 = [].concat(me2, ue2, be2);
  function he2(e3) {
    const n3 = e3.regex, t3 = ce2, a4 = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (e4, n4) => {
        const t4 = e4[0].length + e4.index, a5 = e4.input[t4];
        if ("<" === a5 || "," === a5)
          return void n4.ignoreMatch();
        let i5;
        ">" === a5 && (((e5, {
          after: n5
        }) => {
          const t5 = "</" + e5[0].slice(1);
          return -1 !== e5.input.indexOf(t5, n5);
        })(e4, {
          after: t4
        }) || n4.ignoreMatch());
        const r4 = e4.input.substring(t4);
        ((i5 = r4.match(/^\s*=/)) || (i5 = r4.match(/^\s+extends\s+/)) && 0 === i5.index) && n4.ignoreMatch();
      }
    }, i4 = {
      $pattern: ce2,
      keyword: de2,
      literal: ge2,
      built_in: _e2,
      "variable.language": pe2
    }, r3 = "\\.([0-9](_?[0-9])*)", s3 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", o4 = {
      className: "number",
      variants: [{
        begin: `(\\b(${s3})((${r3})|\\.)?|(${r3}))[eE][+-]?([0-9](_?[0-9])*)\\b`
      }, {
        begin: `\\b(${s3})\\b((${r3})\\b|\\.)?|(${r3})\\b`
      }, {
        begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
      }, {
        begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
      }, {
        begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
      }, {
        begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"
      }, {
        begin: "\\b0[0-7]+n?\\b"
      }],
      relevance: 0
    }, l4 = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: i4,
      contains: []
    }, c3 = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [e3.BACKSLASH_ESCAPE, l4],
        subLanguage: "xml"
      }
    }, d3 = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [e3.BACKSLASH_ESCAPE, l4],
        subLanguage: "css"
      }
    }, g4 = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [e3.BACKSLASH_ESCAPE, l4]
    }, u4 = {
      className: "comment",
      variants: [e3.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
        relevance: 0,
        contains: [{
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [{
            className: "doctag",
            begin: "@[A-Za-z]+"
          }, {
            className: "type",
            begin: "\\{",
            end: "\\}",
            excludeEnd: true,
            excludeBegin: true,
            relevance: 0
          }, {
            className: "variable",
            begin: t3 + "(?=\\s*(-)|$)",
            endsParent: true,
            relevance: 0
          }, {
            begin: /(?=[^\n])\s/,
            relevance: 0
          }]
        }]
      }), e3.C_BLOCK_COMMENT_MODE, e3.C_LINE_COMMENT_MODE]
    }, b3 = [e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, c3, d3, g4, {
      match: /\$\d+/
    }, o4];
    l4.contains = b3.concat({
      begin: /\{/,
      end: /\}/,
      keywords: i4,
      contains: ["self"].concat(b3)
    });
    const m3 = [].concat(u4, l4.contains), p3 = m3.concat([{
      begin: /\(/,
      end: /\)/,
      keywords: i4,
      contains: ["self"].concat(m3)
    }]), _4 = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: i4,
      contains: p3
    }, h3 = {
      variants: [{
        match: [/class/, /\s+/, t3, /\s+/, /extends/, /\s+/, n3.concat(t3, "(", n3.concat(/\./, t3), ")*")],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      }, {
        match: [/class/, /\s+/, t3],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }]
    }, f4 = {
      relevance: 0,
      match: n3.either(
        /\bJSON/,
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      ),
      className: "title.class",
      keywords: {
        _: [...ue2, ...be2]
      }
    }, E4 = {
      variants: [{
        match: [/function/, /\s+/, t3, /(?=\s*\()/]
      }, {
        match: [/function/, /\s*(?=\()/]
      }],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [_4],
      illegal: /%/
    }, y3 = {
      match: n3.concat(/\b/, (w3 = [...me2, "super", "import"], n3.concat("(?!", w3.join("|"), ")")), t3, n3.lookahead(/\(/)),
      className: "title.function",
      relevance: 0
    };
    var w3;
    const N4 = {
      begin: n3.concat(/\./, n3.lookahead(n3.concat(t3, /(?![0-9A-Za-z$_(])/))),
      end: t3,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    }, v3 = {
      match: [/get|set/, /\s+/, t3, /(?=\()/],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [{
        begin: /\(\)/
      }, _4]
    }, O4 = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e3.UNDERSCORE_IDENT_RE + ")\\s*=>", k4 = {
      match: [/const|var|let/, /\s+/, t3, /\s*/, /=\s*/, /(async\s*)?/, n3.lookahead(O4)],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [_4]
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: i4,
      exports: {
        PARAMS_CONTAINS: p3,
        CLASS_REFERENCE: f4
      },
      illegal: /#(?![$_A-z])/,
      contains: [e3.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }), {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, c3, d3, g4, u4, {
        match: /\$\d+/
      }, o4, f4, {
        className: "attr",
        begin: t3 + n3.lookahead(":"),
        relevance: 0
      }, k4, {
        begin: "(" + e3.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [u4, e3.REGEXP_MODE, {
          className: "function",
          begin: O4,
          returnBegin: true,
          end: "\\s*=>",
          contains: [{
            className: "params",
            variants: [{
              begin: e3.UNDERSCORE_IDENT_RE,
              relevance: 0
            }, {
              className: null,
              begin: /\(\s*\)/,
              skip: true
            }, {
              begin: /\(/,
              end: /\)/,
              excludeBegin: true,
              excludeEnd: true,
              keywords: i4,
              contains: p3
            }]
          }]
        }, {
          begin: /,/,
          relevance: 0
        }, {
          match: /\s+/,
          relevance: 0
        }, {
          variants: [{
            begin: "<>",
            end: "</>"
          }, {
            match: /<[A-Za-z0-9\\._:-]+\s*\/>/
          }, {
            begin: a4.begin,
            "on:begin": a4.isTrulyOpeningTag,
            end: a4.end
          }],
          subLanguage: "xml",
          contains: [{
            begin: a4.begin,
            end: a4.end,
            skip: true,
            contains: ["self"]
          }]
        }]
      }, E4, {
        beginKeywords: "while if switch catch for"
      }, {
        begin: "\\b(?!function)" + e3.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [_4, e3.inherit(e3.TITLE_MODE, {
          begin: t3,
          className: "title.function"
        })]
      }, {
        match: /\.\.\./,
        relevance: 0
      }, N4, {
        match: "\\$" + t3,
        relevance: 0
      }, {
        match: [/\bconstructor(?=\s*\()/],
        className: {
          1: "title.function"
        },
        contains: [_4]
      }, y3, {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      }, h3, v3, {
        match: /\$[(.]/
      }]
    };
  }
  var fe2 = (e3) => m2(/\b/, e3, /\w$/.test(e3) ? /\b/ : /\B/);
  var Ee2 = ["Protocol", "Type"].map(fe2);
  var ye2 = ["init", "self"].map(fe2);
  var we2 = ["Any", "Self"];
  var Ne2 = [
    "actor",
    "any",
    "associatedtype",
    "async",
    "await",
    /as\?/,
    /as!/,
    "as",
    "break",
    "case",
    "catch",
    "class",
    "continue",
    "convenience",
    "default",
    "defer",
    "deinit",
    "didSet",
    "distributed",
    "do",
    "dynamic",
    "else",
    "enum",
    "extension",
    "fallthrough",
    /fileprivate\(set\)/,
    "fileprivate",
    "final",
    "for",
    "func",
    "get",
    "guard",
    "if",
    "import",
    "indirect",
    "infix",
    /init\?/,
    /init!/,
    "inout",
    /internal\(set\)/,
    "internal",
    "in",
    "is",
    "isolated",
    "nonisolated",
    "lazy",
    "let",
    "mutating",
    "nonmutating",
    /open\(set\)/,
    "open",
    "operator",
    "optional",
    "override",
    "postfix",
    "precedencegroup",
    "prefix",
    /private\(set\)/,
    "private",
    "protocol",
    /public\(set\)/,
    "public",
    "repeat",
    "required",
    "rethrows",
    "return",
    "set",
    "some",
    "static",
    "struct",
    "subscript",
    "super",
    "switch",
    "throws",
    "throw",
    /try\?/,
    /try!/,
    "try",
    "typealias",
    /unowned\(safe\)/,
    /unowned\(unsafe\)/,
    "unowned",
    "var",
    "weak",
    "where",
    "while",
    "willSet"
  ];
  var ve2 = ["false", "nil", "true"];
  var Oe2 = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"];
  var ke2 = [
    "#colorLiteral",
    "#column",
    "#dsohandle",
    "#else",
    "#elseif",
    "#endif",
    "#error",
    "#file",
    "#fileID",
    "#fileLiteral",
    "#filePath",
    "#function",
    "#if",
    "#imageLiteral",
    "#keyPath",
    "#line",
    "#selector",
    "#sourceLocation",
    "#warn_unqualified_access",
    "#warning"
  ];
  var xe2 = [
    "abs",
    "all",
    "any",
    "assert",
    "assertionFailure",
    "debugPrint",
    "dump",
    "fatalError",
    "getVaList",
    "isKnownUniquelyReferenced",
    "max",
    "min",
    "numericCast",
    "pointwiseMax",
    "pointwiseMin",
    "precondition",
    "preconditionFailure",
    "print",
    "readLine",
    "repeatElement",
    "sequence",
    "stride",
    "swap",
    "swift_unboxFromSwiftValueWithType",
    "transcode",
    "type",
    "unsafeBitCast",
    "unsafeDowncast",
    "withExtendedLifetime",
    "withUnsafeMutablePointer",
    "withUnsafePointer",
    "withVaList",
    "withoutActuallyEscaping",
    "zip"
  ];
  var Me2 = p2(
    /[/=\-+!*%<>&|^~?]/,
    /[\u00A1-\u00A7]/,
    /[\u00A9\u00AB]/,
    /[\u00AC\u00AE]/,
    /[\u00B0\u00B1]/,
    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
    /[\u2016-\u2017]/,
    /[\u2020-\u2027]/,
    /[\u2030-\u203E]/,
    /[\u2041-\u2053]/,
    /[\u2055-\u205E]/,
    /[\u2190-\u23FF]/,
    /[\u2500-\u2775]/,
    /[\u2794-\u2BFF]/,
    /[\u2E00-\u2E7F]/,
    /[\u3001-\u3003]/,
    /[\u3008-\u3020]/,
    /[\u3030]/
  );
  var Se2 = p2(Me2, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/);
  var Ae2 = m2(Me2, Se2, "*");
  var Ce2 = p2(
    /[a-zA-Z_]/,
    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
    /[\u1E00-\u1FFF]/,
    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  );
  var Te2 = p2(Ce2, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/);
  var Re2 = m2(Ce2, Te2, "*");
  var De2 = m2(/[A-Z]/, Te2, "*");
  var Ie2 = [
    "autoclosure",
    m2(/convention\(/, p2("swift", "block", "c"), /\)/),
    "discardableResult",
    "dynamicCallable",
    "dynamicMemberLookup",
    "escaping",
    "frozen",
    "GKInspectable",
    "IBAction",
    "IBDesignable",
    "IBInspectable",
    "IBOutlet",
    "IBSegueAction",
    "inlinable",
    "main",
    "nonobjc",
    "NSApplicationMain",
    "NSCopying",
    "NSManaged",
    m2(
      /objc\(/,
      Re2,
      /\)/
    ),
    "objc",
    "objcMembers",
    "propertyWrapper",
    "requires_stored_property_inits",
    "resultBuilder",
    "testable",
    "UIApplicationMain",
    "unknown",
    "usableFromInline"
  ];
  var Le2 = [
    "iOS",
    "iOSApplicationExtension",
    "macOS",
    "macOSApplicationExtension",
    "macCatalyst",
    "macCatalystApplicationExtension",
    "watchOS",
    "watchOSApplicationExtension",
    "tvOS",
    "tvOSApplicationExtension",
    "swift"
  ];
  var Be2 = Object.freeze({
    __proto__: null,
    grmr_bash: (e3) => {
      const n3 = e3.regex, t3 = {}, a4 = {
        begin: /\$\{/,
        end: /\}/,
        contains: ["self", {
          begin: /:-/,
          contains: [t3]
        }]
      };
      Object.assign(t3, {
        className: "variable",
        variants: [{
          begin: n3.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])")
        }, a4]
      });
      const i4 = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [e3.BACKSLASH_ESCAPE]
      }, r3 = {
        begin: /<<-?\s*(?=\w+)/,
        starts: {
          contains: [e3.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })]
        }
      }, s3 = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [e3.BACKSLASH_ESCAPE, t3, i4]
      };
      i4.contains.push(s3);
      const o4 = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [{
          begin: /\d+#[0-9a-f]+/,
          className: "number"
        }, e3.NUMBER_MODE, t3]
      }, l4 = e3.SHEBANG({
        binary: "(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",
        relevance: 10
      }), c3 = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [e3.inherit(e3.TITLE_MODE, {
          begin: /\w[\w\d_]*/
        })],
        relevance: 0
      };
      return {
        name: "Bash",
        aliases: ["sh"],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: [
            "if",
            "then",
            "else",
            "elif",
            "fi",
            "for",
            "while",
            "in",
            "do",
            "done",
            "case",
            "esac",
            "function"
          ],
          literal: ["true", "false"],
          built_in: [
            "break",
            "cd",
            "continue",
            "eval",
            "exec",
            "exit",
            "export",
            "getopts",
            "hash",
            "pwd",
            "readonly",
            "return",
            "shift",
            "test",
            "times",
            "trap",
            "umask",
            "unset",
            "alias",
            "bind",
            "builtin",
            "caller",
            "command",
            "declare",
            "echo",
            "enable",
            "help",
            "let",
            "local",
            "logout",
            "mapfile",
            "printf",
            "read",
            "readarray",
            "source",
            "type",
            "typeset",
            "ulimit",
            "unalias",
            "set",
            "shopt",
            "autoload",
            "bg",
            "bindkey",
            "bye",
            "cap",
            "chdir",
            "clone",
            "comparguments",
            "compcall",
            "compctl",
            "compdescribe",
            "compfiles",
            "compgroups",
            "compquote",
            "comptags",
            "comptry",
            "compvalues",
            "dirs",
            "disable",
            "disown",
            "echotc",
            "echoti",
            "emulate",
            "fc",
            "fg",
            "float",
            "functions",
            "getcap",
            "getln",
            "history",
            "integer",
            "jobs",
            "kill",
            "limit",
            "log",
            "noglob",
            "popd",
            "print",
            "pushd",
            "pushln",
            "rehash",
            "sched",
            "setcap",
            "setopt",
            "stat",
            "suspend",
            "ttyctl",
            "unfunction",
            "unhash",
            "unlimit",
            "unsetopt",
            "vared",
            "wait",
            "whence",
            "where",
            "which",
            "zcompile",
            "zformat",
            "zftp",
            "zle",
            "zmodload",
            "zparseopts",
            "zprof",
            "zpty",
            "zregexparse",
            "zsocket",
            "zstyle",
            "ztcp",
            "chcon",
            "chgrp",
            "chown",
            "chmod",
            "cp",
            "dd",
            "df",
            "dir",
            "dircolors",
            "ln",
            "ls",
            "mkdir",
            "mkfifo",
            "mknod",
            "mktemp",
            "mv",
            "realpath",
            "rm",
            "rmdir",
            "shred",
            "sync",
            "touch",
            "truncate",
            "vdir",
            "b2sum",
            "base32",
            "base64",
            "cat",
            "cksum",
            "comm",
            "csplit",
            "cut",
            "expand",
            "fmt",
            "fold",
            "head",
            "join",
            "md5sum",
            "nl",
            "numfmt",
            "od",
            "paste",
            "ptx",
            "pr",
            "sha1sum",
            "sha224sum",
            "sha256sum",
            "sha384sum",
            "sha512sum",
            "shuf",
            "sort",
            "split",
            "sum",
            "tac",
            "tail",
            "tr",
            "tsort",
            "unexpand",
            "uniq",
            "wc",
            "arch",
            "basename",
            "chroot",
            "date",
            "dirname",
            "du",
            "echo",
            "env",
            "expr",
            "factor",
            "groups",
            "hostid",
            "id",
            "link",
            "logname",
            "nice",
            "nohup",
            "nproc",
            "pathchk",
            "pinky",
            "printenv",
            "printf",
            "pwd",
            "readlink",
            "runcon",
            "seq",
            "sleep",
            "stat",
            "stdbuf",
            "stty",
            "tee",
            "test",
            "timeout",
            "tty",
            "uname",
            "unlink",
            "uptime",
            "users",
            "who",
            "whoami",
            "yes"
          ]
        },
        contains: [l4, e3.SHEBANG(), c3, o4, e3.HASH_COMMENT_MODE, r3, {
          match: /(\/[a-z._-]+)+/
        }, s3, {
          className: "",
          begin: /\\"/
        }, {
          className: "string",
          begin: /'/,
          end: /'/
        }, t3]
      };
    },
    grmr_c: (e3) => {
      const n3 = e3.regex, t3 = e3.COMMENT("//", "$", {
        contains: [{
          begin: /\\\n/
        }]
      }), a4 = "[a-zA-Z_]\\w*::", i4 = "(decltype\\(auto\\)|" + n3.optional(a4) + "[a-zA-Z_]\\w*" + n3.optional("<[^<>]+>") + ")", r3 = {
        className: "type",
        variants: [{
          begin: "\\b[a-z\\d_]*_t\\b"
        }, {
          match: /\batomic_[a-z]{3,6}\b/
        }]
      }, s3 = {
        className: "string",
        variants: [{
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
          end: "'",
          illegal: "."
        }, e3.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })]
      }, o4 = {
        className: "number",
        variants: [{
          begin: "\\b(0b[01']+)"
        }, {
          begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
        }, {
          begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
        }],
        relevance: 0
      }, l4 = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
        },
        contains: [{
          begin: /\\\n/,
          relevance: 0
        }, e3.inherit(s3, {
          className: "string"
        }), {
          className: "string",
          begin: /<.*?>/
        }, t3, e3.C_BLOCK_COMMENT_MODE]
      }, c3 = {
        className: "title",
        begin: n3.optional(a4) + e3.IDENT_RE,
        relevance: 0
      }, d3 = n3.optional(a4) + e3.IDENT_RE + "\\s*\\(", g4 = {
        keyword: [
          "asm",
          "auto",
          "break",
          "case",
          "continue",
          "default",
          "do",
          "else",
          "enum",
          "extern",
          "for",
          "fortran",
          "goto",
          "if",
          "inline",
          "register",
          "restrict",
          "return",
          "sizeof",
          "struct",
          "switch",
          "typedef",
          "union",
          "volatile",
          "while",
          "_Alignas",
          "_Alignof",
          "_Atomic",
          "_Generic",
          "_Noreturn",
          "_Static_assert",
          "_Thread_local",
          "alignas",
          "alignof",
          "noreturn",
          "static_assert",
          "thread_local",
          "_Pragma"
        ],
        type: [
          "float",
          "double",
          "signed",
          "unsigned",
          "int",
          "short",
          "long",
          "char",
          "void",
          "_Bool",
          "_Complex",
          "_Imaginary",
          "_Decimal32",
          "_Decimal64",
          "_Decimal128",
          "const",
          "static",
          "complex",
          "bool",
          "imaginary"
        ],
        literal: "true false NULL",
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      }, u4 = [l4, r3, t3, e3.C_BLOCK_COMMENT_MODE, o4, s3], b3 = {
        variants: [{
          begin: /=/,
          end: /;/
        }, {
          begin: /\(/,
          end: /\)/
        }, {
          beginKeywords: "new throw return else",
          end: /;/
        }],
        keywords: g4,
        contains: u4.concat([{
          begin: /\(/,
          end: /\)/,
          keywords: g4,
          contains: u4.concat(["self"]),
          relevance: 0
        }]),
        relevance: 0
      }, m3 = {
        begin: "(" + i4 + "[\\*&\\s]+)+" + d3,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: g4,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [{
          begin: "decltype\\(auto\\)",
          keywords: g4,
          relevance: 0
        }, {
          begin: d3,
          returnBegin: true,
          contains: [e3.inherit(c3, {
            className: "title.function"
          })],
          relevance: 0
        }, {
          relevance: 0,
          match: /,/
        }, {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: g4,
          relevance: 0,
          contains: [t3, e3.C_BLOCK_COMMENT_MODE, s3, o4, r3, {
            begin: /\(/,
            end: /\)/,
            keywords: g4,
            relevance: 0,
            contains: ["self", t3, e3.C_BLOCK_COMMENT_MODE, s3, o4, r3]
          }]
        }, r3, t3, e3.C_BLOCK_COMMENT_MODE, l4]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: g4,
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(b3, m3, u4, [l4, {
          begin: e3.IDENT_RE + "::",
          keywords: g4
        }, {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [{
            beginKeywords: "final class struct"
          }, e3.TITLE_MODE]
        }]),
        exports: {
          preprocessor: l4,
          strings: s3,
          keywords: g4
        }
      };
    },
    grmr_cpp: (e3) => {
      const n3 = e3.regex, t3 = e3.COMMENT("//", "$", {
        contains: [{
          begin: /\\\n/
        }]
      }), a4 = "[a-zA-Z_]\\w*::", i4 = "(?!struct)(decltype\\(auto\\)|" + n3.optional(a4) + "[a-zA-Z_]\\w*" + n3.optional("<[^<>]+>") + ")", r3 = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, s3 = {
        className: "string",
        variants: [{
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
          end: "'",
          illegal: "."
        }, e3.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })]
      }, o4 = {
        className: "number",
        variants: [{
          begin: "\\b(0b[01']+)"
        }, {
          begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
        }, {
          begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
        }],
        relevance: 0
      }, l4 = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
        },
        contains: [{
          begin: /\\\n/,
          relevance: 0
        }, e3.inherit(s3, {
          className: "string"
        }), {
          className: "string",
          begin: /<.*?>/
        }, t3, e3.C_BLOCK_COMMENT_MODE]
      }, c3 = {
        className: "title",
        begin: n3.optional(a4) + e3.IDENT_RE,
        relevance: 0
      }, d3 = n3.optional(a4) + e3.IDENT_RE + "\\s*\\(", g4 = {
        type: [
          "bool",
          "char",
          "char16_t",
          "char32_t",
          "char8_t",
          "double",
          "float",
          "int",
          "long",
          "short",
          "void",
          "wchar_t",
          "unsigned",
          "signed",
          "const",
          "static"
        ],
        keyword: [
          "alignas",
          "alignof",
          "and",
          "and_eq",
          "asm",
          "atomic_cancel",
          "atomic_commit",
          "atomic_noexcept",
          "auto",
          "bitand",
          "bitor",
          "break",
          "case",
          "catch",
          "class",
          "co_await",
          "co_return",
          "co_yield",
          "compl",
          "concept",
          "const_cast|10",
          "consteval",
          "constexpr",
          "constinit",
          "continue",
          "decltype",
          "default",
          "delete",
          "do",
          "dynamic_cast|10",
          "else",
          "enum",
          "explicit",
          "export",
          "extern",
          "false",
          "final",
          "for",
          "friend",
          "goto",
          "if",
          "import",
          "inline",
          "module",
          "mutable",
          "namespace",
          "new",
          "noexcept",
          "not",
          "not_eq",
          "nullptr",
          "operator",
          "or",
          "or_eq",
          "override",
          "private",
          "protected",
          "public",
          "reflexpr",
          "register",
          "reinterpret_cast|10",
          "requires",
          "return",
          "sizeof",
          "static_assert",
          "static_cast|10",
          "struct",
          "switch",
          "synchronized",
          "template",
          "this",
          "thread_local",
          "throw",
          "transaction_safe",
          "transaction_safe_dynamic",
          "true",
          "try",
          "typedef",
          "typeid",
          "typename",
          "union",
          "using",
          "virtual",
          "volatile",
          "while",
          "xor",
          "xor_eq"
        ],
        literal: ["NULL", "false", "nullopt", "nullptr", "true"],
        built_in: ["_Pragma"],
        _type_hints: [
          "any",
          "auto_ptr",
          "barrier",
          "binary_semaphore",
          "bitset",
          "complex",
          "condition_variable",
          "condition_variable_any",
          "counting_semaphore",
          "deque",
          "false_type",
          "future",
          "imaginary",
          "initializer_list",
          "istringstream",
          "jthread",
          "latch",
          "lock_guard",
          "multimap",
          "multiset",
          "mutex",
          "optional",
          "ostringstream",
          "packaged_task",
          "pair",
          "promise",
          "priority_queue",
          "queue",
          "recursive_mutex",
          "recursive_timed_mutex",
          "scoped_lock",
          "set",
          "shared_future",
          "shared_lock",
          "shared_mutex",
          "shared_timed_mutex",
          "shared_ptr",
          "stack",
          "string_view",
          "stringstream",
          "timed_mutex",
          "thread",
          "true_type",
          "tuple",
          "unique_lock",
          "unique_ptr",
          "unordered_map",
          "unordered_multimap",
          "unordered_multiset",
          "unordered_set",
          "variant",
          "vector",
          "weak_ptr",
          "wstring",
          "wstring_view"
        ]
      }, u4 = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          _hint: [
            "abort",
            "abs",
            "acos",
            "apply",
            "as_const",
            "asin",
            "atan",
            "atan2",
            "calloc",
            "ceil",
            "cerr",
            "cin",
            "clog",
            "cos",
            "cosh",
            "cout",
            "declval",
            "endl",
            "exchange",
            "exit",
            "exp",
            "fabs",
            "floor",
            "fmod",
            "forward",
            "fprintf",
            "fputs",
            "free",
            "frexp",
            "fscanf",
            "future",
            "invoke",
            "isalnum",
            "isalpha",
            "iscntrl",
            "isdigit",
            "isgraph",
            "islower",
            "isprint",
            "ispunct",
            "isspace",
            "isupper",
            "isxdigit",
            "labs",
            "launder",
            "ldexp",
            "log",
            "log10",
            "make_pair",
            "make_shared",
            "make_shared_for_overwrite",
            "make_tuple",
            "make_unique",
            "malloc",
            "memchr",
            "memcmp",
            "memcpy",
            "memset",
            "modf",
            "move",
            "pow",
            "printf",
            "putchar",
            "puts",
            "realloc",
            "scanf",
            "sin",
            "sinh",
            "snprintf",
            "sprintf",
            "sqrt",
            "sscanf",
            "std",
            "stderr",
            "stdin",
            "stdout",
            "strcat",
            "strchr",
            "strcmp",
            "strcpy",
            "strcspn",
            "strlen",
            "strncat",
            "strncmp",
            "strncpy",
            "strpbrk",
            "strrchr",
            "strspn",
            "strstr",
            "swap",
            "tan",
            "tanh",
            "terminate",
            "to_underlying",
            "tolower",
            "toupper",
            "vfprintf",
            "visit",
            "vprintf",
            "vsprintf"
          ]
        },
        begin: n3.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, e3.IDENT_RE, n3.lookahead(/(<[^<>]+>|)\s*\(/))
      }, b3 = [u4, l4, r3, t3, e3.C_BLOCK_COMMENT_MODE, o4, s3], m3 = {
        variants: [{
          begin: /=/,
          end: /;/
        }, {
          begin: /\(/,
          end: /\)/
        }, {
          beginKeywords: "new throw return else",
          end: /;/
        }],
        keywords: g4,
        contains: b3.concat([{
          begin: /\(/,
          end: /\)/,
          keywords: g4,
          contains: b3.concat(["self"]),
          relevance: 0
        }]),
        relevance: 0
      }, p3 = {
        className: "function",
        begin: "(" + i4 + "[\\*&\\s]+)+" + d3,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: g4,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [{
          begin: "decltype\\(auto\\)",
          keywords: g4,
          relevance: 0
        }, {
          begin: d3,
          returnBegin: true,
          contains: [c3],
          relevance: 0
        }, {
          begin: /::/,
          relevance: 0
        }, {
          begin: /:/,
          endsWithParent: true,
          contains: [s3, o4]
        }, {
          relevance: 0,
          match: /,/
        }, {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: g4,
          relevance: 0,
          contains: [t3, e3.C_BLOCK_COMMENT_MODE, s3, o4, r3, {
            begin: /\(/,
            end: /\)/,
            keywords: g4,
            relevance: 0,
            contains: ["self", t3, e3.C_BLOCK_COMMENT_MODE, s3, o4, r3]
          }]
        }, r3, t3, e3.C_BLOCK_COMMENT_MODE, l4]
      };
      return {
        name: "C++",
        aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
        keywords: g4,
        illegal: "</",
        classNameAliases: {
          "function.dispatch": "built_in"
        },
        contains: [].concat(m3, p3, u4, b3, [l4, {
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: g4,
          contains: ["self", r3]
        }, {
          begin: e3.IDENT_RE + "::",
          keywords: g4
        }, {
          match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }])
      };
    },
    grmr_csharp: (e3) => {
      const n3 = {
        keyword: [
          "abstract",
          "as",
          "base",
          "break",
          "case",
          "catch",
          "class",
          "const",
          "continue",
          "do",
          "else",
          "event",
          "explicit",
          "extern",
          "finally",
          "fixed",
          "for",
          "foreach",
          "goto",
          "if",
          "implicit",
          "in",
          "interface",
          "internal",
          "is",
          "lock",
          "namespace",
          "new",
          "operator",
          "out",
          "override",
          "params",
          "private",
          "protected",
          "public",
          "readonly",
          "record",
          "ref",
          "return",
          "scoped",
          "sealed",
          "sizeof",
          "stackalloc",
          "static",
          "struct",
          "switch",
          "this",
          "throw",
          "try",
          "typeof",
          "unchecked",
          "unsafe",
          "using",
          "virtual",
          "void",
          "volatile",
          "while"
        ].concat([
          "add",
          "alias",
          "and",
          "ascending",
          "async",
          "await",
          "by",
          "descending",
          "equals",
          "from",
          "get",
          "global",
          "group",
          "init",
          "into",
          "join",
          "let",
          "nameof",
          "not",
          "notnull",
          "on",
          "or",
          "orderby",
          "partial",
          "remove",
          "select",
          "set",
          "unmanaged",
          "value|0",
          "var",
          "when",
          "where",
          "with",
          "yield"
        ]),
        built_in: [
          "bool",
          "byte",
          "char",
          "decimal",
          "delegate",
          "double",
          "dynamic",
          "enum",
          "float",
          "int",
          "long",
          "nint",
          "nuint",
          "object",
          "sbyte",
          "short",
          "string",
          "ulong",
          "uint",
          "ushort"
        ],
        literal: ["default", "false", "null", "true"]
      }, t3 = e3.inherit(e3.TITLE_MODE, {
        begin: "[a-zA-Z](\\.?\\w)*"
      }), a4 = {
        className: "number",
        variants: [{
          begin: "\\b(0b[01']+)"
        }, {
          begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
        }, {
          begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
        }],
        relevance: 0
      }, i4 = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{
          begin: '""'
        }]
      }, r3 = e3.inherit(i4, {
        illegal: /\n/
      }), s3 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: n3
      }, o4 = e3.inherit(s3, {
        illegal: /\n/
      }), l4 = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [{
          begin: /\{\{/
        }, {
          begin: /\}\}/
        }, e3.BACKSLASH_ESCAPE, o4]
      }, c3 = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [{
          begin: /\{\{/
        }, {
          begin: /\}\}/
        }, {
          begin: '""'
        }, s3]
      }, d3 = e3.inherit(c3, {
        illegal: /\n/,
        contains: [{
          begin: /\{\{/
        }, {
          begin: /\}\}/
        }, {
          begin: '""'
        }, o4]
      });
      s3.contains = [c3, l4, i4, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, a4, e3.C_BLOCK_COMMENT_MODE], o4.contains = [d3, l4, r3, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, a4, e3.inherit(e3.C_BLOCK_COMMENT_MODE, {
        illegal: /\n/
      })];
      const g4 = {
        variants: [c3, l4, i4, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE]
      }, u4 = {
        begin: "<",
        end: ">",
        contains: [{
          beginKeywords: "in out"
        }, t3]
      }, b3 = e3.IDENT_RE + "(<" + e3.IDENT_RE + "(\\s*,\\s*" + e3.IDENT_RE + ")*>)?(\\[\\])?", m3 = {
        begin: "@" + e3.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: ["cs", "c#"],
        keywords: n3,
        illegal: /::/,
        contains: [e3.COMMENT("///", "$", {
          returnBegin: true,
          contains: [{
            className: "doctag",
            variants: [{
              begin: "///",
              relevance: 0
            }, {
              begin: "<!--|-->"
            }, {
              begin: "</?",
              end: ">"
            }]
          }]
        }), e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, {
          className: "meta",
          begin: "#",
          end: "$",
          keywords: {
            keyword: "if else elif endif define undef warning error line region endregion pragma checksum"
          }
        }, g4, a4, {
          beginKeywords: "class interface",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:,]/,
          contains: [{
            beginKeywords: "where class"
          }, t3, u4, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, {
          beginKeywords: "namespace",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [t3, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, {
          beginKeywords: "record",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [t3, u4, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, {
          className: "meta",
          begin: "^\\s*\\[(?=[\\w])",
          excludeBegin: true,
          end: "\\]",
          excludeEnd: true,
          contains: [{
            className: "string",
            begin: /"/,
            end: /"/
          }]
        }, {
          beginKeywords: "new return throw await else",
          relevance: 0
        }, {
          className: "function",
          begin: "(" + b3 + "\\s+)+" + e3.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
          returnBegin: true,
          end: /\s*[{;=]/,
          excludeEnd: true,
          keywords: n3,
          contains: [{
            beginKeywords: "public private protected static internal protected abstract async extern override unsafe virtual new sealed partial",
            relevance: 0
          }, {
            begin: e3.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            contains: [e3.TITLE_MODE, u4],
            relevance: 0
          }, {
            match: /\(\)/
          }, {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: n3,
            relevance: 0,
            contains: [g4, a4, e3.C_BLOCK_COMMENT_MODE]
          }, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, m3]
      };
    },
    grmr_css: (e3) => {
      const n3 = e3.regex, t3 = J2(e3), a4 = [e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: {
          keyframePosition: "from to"
        },
        classNameAliases: {
          keyframePosition: "selector-tag"
        },
        contains: [t3.BLOCK_COMMENT, {
          begin: /-(webkit|moz|ms|o)-(?=[a-z])/
        }, t3.CSS_NUMBER_MODE, {
          className: "selector-id",
          begin: /#[A-Za-z0-9_-]+/,
          relevance: 0
        }, {
          className: "selector-class",
          begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
          relevance: 0
        }, t3.ATTRIBUTE_SELECTOR_MODE, {
          className: "selector-pseudo",
          variants: [{
            begin: ":(" + ne2.join("|") + ")"
          }, {
            begin: ":(:)?(" + te2.join("|") + ")"
          }]
        }, t3.CSS_VARIABLE, {
          className: "attribute",
          begin: "\\b(" + ae2.join("|") + ")\\b"
        }, {
          begin: /:/,
          end: /[;}{]/,
          contains: [t3.BLOCK_COMMENT, t3.HEXCOLOR, t3.IMPORTANT, t3.CSS_NUMBER_MODE, ...a4, {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: {
              built_in: "url data-uri"
            },
            contains: [...a4, {
              className: "string",
              begin: /[^)]/,
              endsWithParent: true,
              excludeEnd: true
            }]
          }, t3.FUNCTION_DISPATCH]
        }, {
          begin: n3.lookahead(/@/),
          end: "[{;]",
          relevance: 0,
          illegal: /:/,
          contains: [{
            className: "keyword",
            begin: /@-?\w[\w]*(-\w+)*/
          }, {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: "and or not only",
              attribute: ee2.join(" ")
            },
            contains: [{
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            }, ...a4, t3.CSS_NUMBER_MODE]
          }]
        }, {
          className: "selector-tag",
          begin: "\\b(" + Y2.join("|") + ")\\b"
        }]
      };
    },
    grmr_diff: (e3) => {
      const n3 = e3.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [{
          className: "meta",
          relevance: 10,
          match: n3.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/)
        }, {
          className: "comment",
          variants: [{
            begin: n3.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
            end: /$/
          }, {
            match: /^\*{15}$/
          }]
        }, {
          className: "addition",
          begin: /^\+/,
          end: /$/
        }, {
          className: "deletion",
          begin: /^-/,
          end: /$/
        }, {
          className: "addition",
          begin: /^!/,
          end: /$/
        }]
      };
    },
    grmr_go: (e3) => {
      const n3 = {
        keyword: [
          "break",
          "case",
          "chan",
          "const",
          "continue",
          "default",
          "defer",
          "else",
          "fallthrough",
          "for",
          "func",
          "go",
          "goto",
          "if",
          "import",
          "interface",
          "map",
          "package",
          "range",
          "return",
          "select",
          "struct",
          "switch",
          "type",
          "var"
        ],
        type: [
          "bool",
          "byte",
          "complex64",
          "complex128",
          "error",
          "float32",
          "float64",
          "int8",
          "int16",
          "int32",
          "int64",
          "string",
          "uint8",
          "uint16",
          "uint32",
          "uint64",
          "int",
          "uint",
          "uintptr",
          "rune"
        ],
        literal: ["true", "false", "iota", "nil"],
        built_in: [
          "append",
          "cap",
          "close",
          "complex",
          "copy",
          "imag",
          "len",
          "make",
          "new",
          "panic",
          "print",
          "println",
          "real",
          "recover",
          "delete"
        ]
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: n3,
        illegal: "</",
        contains: [e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, {
          className: "string",
          variants: [e3.QUOTE_STRING_MODE, e3.APOS_STRING_MODE, {
            begin: "`",
            end: "`"
          }]
        }, {
          className: "number",
          variants: [{
            begin: e3.C_NUMBER_RE + "[i]",
            relevance: 1
          }, e3.C_NUMBER_MODE]
        }, {
          begin: /:=/
        }, {
          className: "function",
          beginKeywords: "func",
          end: "\\s*(\\{|$)",
          excludeEnd: true,
          contains: [e3.TITLE_MODE, {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: true,
            keywords: n3,
            illegal: /["']/
          }]
        }]
      };
    },
    grmr_graphql: (e3) => {
      const n3 = e3.regex;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: ["true", "false", "null"]
        },
        contains: [e3.HASH_COMMENT_MODE, e3.QUOTE_STRING_MODE, e3.NUMBER_MODE, {
          scope: "punctuation",
          match: /[.]{3}/,
          relevance: 0
        }, {
          scope: "punctuation",
          begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
          relevance: 0
        }, {
          scope: "variable",
          begin: /\$/,
          end: /\W/,
          excludeEnd: true,
          relevance: 0
        }, {
          scope: "meta",
          match: /@\w+/,
          excludeEnd: true
        }, {
          scope: "symbol",
          begin: n3.concat(/[_A-Za-z][_0-9A-Za-z]*/, n3.lookahead(/\s*:/)),
          relevance: 0
        }],
        illegal: [/[;<']/, /BEGIN/]
      };
    },
    grmr_ini: (e3) => {
      const n3 = e3.regex, t3 = {
        className: "number",
        relevance: 0,
        variants: [{
          begin: /([+-]+)?[\d]+_[\d_]+/
        }, {
          begin: e3.NUMBER_RE
        }]
      }, a4 = e3.COMMENT();
      a4.variants = [{
        begin: /;/,
        end: /$/
      }, {
        begin: /#/,
        end: /$/
      }];
      const i4 = {
        className: "variable",
        variants: [{
          begin: /\$[\w\d"][\w\d_]*/
        }, {
          begin: /\$\{(.*?)\}/
        }]
      }, r3 = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      }, s3 = {
        className: "string",
        contains: [e3.BACKSLASH_ESCAPE],
        variants: [{
          begin: "'''",
          end: "'''",
          relevance: 10
        }, {
          begin: '"""',
          end: '"""',
          relevance: 10
        }, {
          begin: '"',
          end: '"'
        }, {
          begin: "'",
          end: "'"
        }]
      }, o4 = {
        begin: /\[/,
        end: /\]/,
        contains: [a4, r3, i4, s3, t3, "self"],
        relevance: 0
      }, l4 = n3.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [a4, {
          className: "section",
          begin: /\[+/,
          end: /\]+/
        }, {
          begin: n3.concat(l4, "(\\s*\\.\\s*", l4, ")*", n3.lookahead(/\s*=\s*[^#\s]/)),
          className: "attr",
          starts: {
            end: /$/,
            contains: [a4, o4, r3, i4, s3, t3]
          }
        }]
      };
    },
    grmr_java: (e3) => {
      const n3 = e3.regex, t3 = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*", a4 = t3 + le2("(?:<" + t3 + "~~~(?:\\s*,\\s*" + t3 + "~~~)*>)?", /~~~/g, 2), i4 = {
        keyword: [
          "synchronized",
          "abstract",
          "private",
          "var",
          "static",
          "if",
          "const ",
          "for",
          "while",
          "strictfp",
          "finally",
          "protected",
          "import",
          "native",
          "final",
          "void",
          "enum",
          "else",
          "break",
          "transient",
          "catch",
          "instanceof",
          "volatile",
          "case",
          "assert",
          "package",
          "default",
          "public",
          "try",
          "switch",
          "continue",
          "throws",
          "protected",
          "public",
          "private",
          "module",
          "requires",
          "exports",
          "do",
          "sealed",
          "yield",
          "permits"
        ],
        literal: ["false", "true", "null"],
        type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
        built_in: ["super", "this"]
      }, r3 = {
        className: "meta",
        begin: "@" + t3,
        contains: [{
          begin: /\(/,
          end: /\)/,
          contains: ["self"]
        }]
      }, s3 = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: i4,
        relevance: 0,
        contains: [e3.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: i4,
        illegal: /<\/|#/,
        contains: [e3.COMMENT("/\\*\\*", "\\*/", {
          relevance: 0,
          contains: [{
            begin: /\w+@/,
            relevance: 0
          }, {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }]
        }), {
          begin: /import java\.[a-z]+\./,
          keywords: "import",
          relevance: 2
        }, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, {
          begin: /"""/,
          end: /"""/,
          className: "string",
          contains: [e3.BACKSLASH_ESCAPE]
        }, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, {
          match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, t3],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }, {
          match: /non-sealed/,
          scope: "keyword"
        }, {
          begin: [n3.concat(/(?!else)/, t3), /\s+/, t3, /\s+/, /=(?!=)/],
          className: {
            1: "type",
            3: "variable",
            5: "operator"
          }
        }, {
          begin: [/record/, /\s+/, t3],
          className: {
            1: "keyword",
            3: "title.class"
          },
          contains: [s3, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, {
          beginKeywords: "new throw return else",
          relevance: 0
        }, {
          begin: ["(?:" + a4 + "\\s+)", e3.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
          className: {
            2: "title.function"
          },
          keywords: i4,
          contains: [{
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: i4,
            relevance: 0,
            contains: [r3, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, oe2, e3.C_BLOCK_COMMENT_MODE]
          }, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
        }, oe2, r3]
      };
    },
    grmr_javascript: he2,
    grmr_json: (e3) => {
      const n3 = ["true", "false", "null"], t3 = {
        scope: "literal",
        beginKeywords: n3.join(" ")
      };
      return {
        name: "JSON",
        keywords: {
          literal: n3
        },
        contains: [{
          className: "attr",
          begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
          relevance: 1.01
        }, {
          match: /[{}[\],:]/,
          className: "punctuation",
          relevance: 0
        }, e3.QUOTE_STRING_MODE, t3, e3.C_NUMBER_MODE, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE],
        illegal: "\\S"
      };
    },
    grmr_kotlin: (e3) => {
      const n3 = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      }, t3 = {
        className: "symbol",
        begin: e3.UNDERSCORE_IDENT_RE + "@"
      }, a4 = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [e3.C_NUMBER_MODE]
      }, i4 = {
        className: "variable",
        begin: "\\$" + e3.UNDERSCORE_IDENT_RE
      }, r3 = {
        className: "string",
        variants: [{
          begin: '"""',
          end: '"""(?=[^"])',
          contains: [i4, a4]
        }, {
          begin: "'",
          end: "'",
          illegal: /\n/,
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: '"',
          end: '"',
          illegal: /\n/,
          contains: [e3.BACKSLASH_ESCAPE, i4, a4]
        }]
      };
      a4.contains.push(r3);
      const s3 = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e3.UNDERSCORE_IDENT_RE + ")?"
      }, o4 = {
        className: "meta",
        begin: "@" + e3.UNDERSCORE_IDENT_RE,
        contains: [{
          begin: /\(/,
          end: /\)/,
          contains: [e3.inherit(r3, {
            className: "string"
          }), "self"]
        }]
      }, l4 = oe2, c3 = e3.COMMENT("/\\*", "\\*/", {
        contains: [e3.C_BLOCK_COMMENT_MODE]
      }), d3 = {
        variants: [{
          className: "type",
          begin: e3.UNDERSCORE_IDENT_RE
        }, {
          begin: /\(/,
          end: /\)/,
          contains: []
        }]
      }, g4 = d3;
      return g4.variants[1].contains = [d3], d3.variants[1].contains = [g4], {
        name: "Kotlin",
        aliases: ["kt", "kts"],
        keywords: n3,
        contains: [e3.COMMENT("/\\*\\*", "\\*/", {
          relevance: 0,
          contains: [{
            className: "doctag",
            begin: "@[A-Za-z]+"
          }]
        }), e3.C_LINE_COMMENT_MODE, c3, {
          className: "keyword",
          begin: /\b(break|continue|return|this)\b/,
          starts: {
            contains: [{
              className: "symbol",
              begin: /@\w+/
            }]
          }
        }, t3, s3, o4, {
          className: "function",
          beginKeywords: "fun",
          end: "[(]|$",
          returnBegin: true,
          excludeEnd: true,
          keywords: n3,
          relevance: 5,
          contains: [{
            begin: e3.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: true,
            relevance: 0,
            contains: [e3.UNDERSCORE_TITLE_MODE]
          }, {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          }, {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: true,
            keywords: n3,
            relevance: 0,
            contains: [{
              begin: /:/,
              end: /[=,\/]/,
              endsWithParent: true,
              contains: [d3, e3.C_LINE_COMMENT_MODE, c3],
              relevance: 0
            }, e3.C_LINE_COMMENT_MODE, c3, s3, o4, r3, e3.C_NUMBER_MODE]
          }, c3]
        }, {
          begin: [/class|interface|trait/, /\s+/, e3.UNDERSCORE_IDENT_RE],
          beginScope: {
            3: "title.class"
          },
          keywords: "class interface trait",
          end: /[:\{(]|$/,
          excludeEnd: true,
          illegal: "extends implements",
          contains: [{
            beginKeywords: "public protected internal private constructor"
          }, e3.UNDERSCORE_TITLE_MODE, {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0
          }, {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: true,
            returnEnd: true
          }, s3, o4]
        }, r3, {
          className: "meta",
          begin: "^#!/usr/bin/env",
          end: "$",
          illegal: "\n"
        }, l4]
      };
    },
    grmr_less: (e3) => {
      const n3 = J2(e3), t3 = ie2, a4 = "([\\w-]+|@\\{[\\w-]+\\})", i4 = [], r3 = [], s3 = (e4) => ({
        className: "string",
        begin: "~?" + e4 + ".*?" + e4
      }), o4 = (e4, n4, t4) => ({
        className: e4,
        begin: n4,
        relevance: t4
      }), l4 = {
        $pattern: /[a-z-]+/,
        keyword: "and or not only",
        attribute: ee2.join(" ")
      }, c3 = {
        begin: "\\(",
        end: "\\)",
        contains: r3,
        keywords: l4,
        relevance: 0
      };
      r3.push(e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, s3("'"), s3('"'), n3.CSS_NUMBER_MODE, {
        begin: "(url|data-uri)\\(",
        starts: {
          className: "string",
          end: "[\\)\\n]",
          excludeEnd: true
        }
      }, n3.HEXCOLOR, c3, o4("variable", "@@?[\\w-]+", 10), o4("variable", "@\\{[\\w-]+\\}"), o4(
        "built_in",
        "~?`[^`]*?`"
      ), {
        className: "attribute",
        begin: "[\\w-]+\\s*:",
        end: ":",
        returnBegin: true,
        excludeEnd: true
      }, n3.IMPORTANT, {
        beginKeywords: "and not"
      }, n3.FUNCTION_DISPATCH);
      const d3 = r3.concat({
        begin: /\{/,
        end: /\}/,
        contains: i4
      }), g4 = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{
          beginKeywords: "and not"
        }].concat(r3)
      }, u4 = {
        begin: a4 + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [{
          begin: /-(webkit|moz|ms|o)-/
        }, n3.CSS_VARIABLE, {
          className: "attribute",
          begin: "\\b(" + ae2.join("|") + ")\\b",
          end: /(?=:)/,
          starts: {
            endsWithParent: true,
            illegal: "[<=$]",
            relevance: 0,
            contains: r3
          }
        }]
      }, b3 = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: l4,
          returnEnd: true,
          contains: r3,
          relevance: 0
        }
      }, m3 = {
        className: "variable",
        variants: [{
          begin: "@[\\w-]+\\s*:",
          relevance: 15
        }, {
          begin: "@[\\w-]+"
        }],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: d3
        }
      }, p3 = {
        variants: [{
          begin: "[\\.#:&\\[>]",
          end: "[;{}]"
        }, {
          begin: a4,
          end: /\{/
        }],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, g4, o4("keyword", "all\\b"), o4(
          "variable",
          "@\\{[\\w-]+\\}"
        ), {
          begin: "\\b(" + Y2.join("|") + ")\\b",
          className: "selector-tag"
        }, n3.CSS_NUMBER_MODE, o4("selector-tag", a4, 0), o4("selector-id", "#" + a4), o4("selector-class", "\\." + a4, 0), o4("selector-tag", "&", 0), n3.ATTRIBUTE_SELECTOR_MODE, {
          className: "selector-pseudo",
          begin: ":(" + ne2.join("|") + ")"
        }, {
          className: "selector-pseudo",
          begin: ":(:)?(" + te2.join("|") + ")"
        }, {
          begin: /\(/,
          end: /\)/,
          relevance: 0,
          contains: d3
        }, {
          begin: "!important"
        }, n3.FUNCTION_DISPATCH]
      }, _4 = {
        begin: `[\\w-]+:(:)?(${t3.join("|")})`,
        returnBegin: true,
        contains: [p3]
      };
      return i4.push(e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, b3, m3, _4, u4, p3, g4, n3.FUNCTION_DISPATCH), {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: i4
      };
    },
    grmr_lua: (e3) => {
      const n3 = "\\[=*\\[", t3 = "\\]=*\\]", a4 = {
        begin: n3,
        end: t3,
        contains: ["self"]
      }, i4 = [e3.COMMENT("--(?!\\[=*\\[)", "$"), e3.COMMENT("--\\[=*\\[", t3, {
        contains: [a4],
        relevance: 10
      })];
      return {
        name: "Lua",
        keywords: {
          $pattern: e3.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
        },
        contains: i4.concat([{
          className: "function",
          beginKeywords: "function",
          end: "\\)",
          contains: [e3.inherit(e3.TITLE_MODE, {
            begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*"
          }), {
            className: "params",
            begin: "\\(",
            endsWithParent: true,
            contains: i4
          }].concat(i4)
        }, e3.C_NUMBER_MODE, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE, {
          className: "string",
          begin: n3,
          end: t3,
          contains: [a4],
          relevance: 5
        }])
      };
    },
    grmr_makefile: (e3) => {
      const n3 = {
        className: "variable",
        variants: [{
          begin: "\\$\\(" + e3.UNDERSCORE_IDENT_RE + "\\)",
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: /\$[@%<?\^\+\*]/
        }]
      }, t3 = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [e3.BACKSLASH_ESCAPE, n3]
      }, a4 = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: {
          built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"
        },
        contains: [n3]
      }, i4 = {
        begin: "^" + e3.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)"
      }, r3 = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [n3]
      };
      return {
        name: "Makefile",
        aliases: ["mk", "mak", "make"],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [e3.HASH_COMMENT_MODE, n3, t3, a4, i4, {
          className: "meta",
          begin: /^\.PHONY:/,
          end: /$/,
          keywords: {
            $pattern: /[\.\w]+/,
            keyword: ".PHONY"
          }
        }, r3]
      };
    },
    grmr_xml: (e3) => {
      const n3 = e3.regex, t3 = n3.concat(
        /(?:[A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/,
        n3.optional(
          /(?:[\x2D\.0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*:/
        ),
        /(?:[\x2D\.0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*/
      ), a4 = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      }, i4 = {
        begin: /\s/,
        contains: [{
          className: "keyword",
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }]
      }, r3 = e3.inherit(i4, {
        begin: /\(/,
        end: /\)/
      }), s3 = e3.inherit(e3.APOS_STRING_MODE, {
        className: "string"
      }), o4 = e3.inherit(e3.QUOTE_STRING_MODE, {
        className: "string"
      }), l4 = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [{
          className: "attr",
          begin: /(?:[\x2D\.0-:A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])+/,
          relevance: 0
        }, {
          begin: /=\s*/,
          relevance: 0,
          contains: [{
            className: "string",
            endsParent: true,
            variants: [{
              begin: /"/,
              end: /"/,
              contains: [a4]
            }, {
              begin: /'/,
              end: /'/,
              contains: [a4]
            }, {
              begin: /[^\s"'=<>`]+/
            }]
          }]
        }]
      };
      return {
        name: "HTML, XML",
        aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [{
          className: "meta",
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [i4, o4, s3, r3, {
            begin: /\[/,
            end: /\]/,
            contains: [{
              className: "meta",
              begin: /<![a-z]/,
              end: />/,
              contains: [i4, r3, o4, s3]
            }]
          }]
        }, e3.COMMENT(/<!--/, /-->/, {
          relevance: 10
        }), {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        }, a4, {
          className: "meta",
          end: /\?>/,
          variants: [{
            begin: /<\?xml/,
            relevance: 10,
            contains: [o4]
          }, {
            begin: /<\?[a-z][a-z0-9]+/
          }]
        }, {
          className: "tag",
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: {
            name: "style"
          },
          contains: [l4],
          starts: {
            end: /<\/style>/,
            returnEnd: true,
            subLanguage: ["css", "xml"]
          }
        }, {
          className: "tag",
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: {
            name: "script"
          },
          contains: [l4],
          starts: {
            end: /<\/script>/,
            returnEnd: true,
            subLanguage: ["javascript", "handlebars", "xml"]
          }
        }, {
          className: "tag",
          begin: /<>|<\/>/
        }, {
          className: "tag",
          begin: n3.concat(/</, n3.lookahead(n3.concat(t3, n3.either(/\/>/, />/, /\s/)))),
          end: /\/?>/,
          contains: [{
            className: "name",
            begin: t3,
            relevance: 0,
            starts: l4
          }]
        }, {
          className: "tag",
          begin: n3.concat(/<\//, n3.lookahead(n3.concat(t3, />/))),
          contains: [{
            className: "name",
            begin: t3,
            relevance: 0
          }, {
            begin: />/,
            relevance: 0,
            endsParent: true
          }]
        }]
      };
    },
    grmr_markdown: (e3) => {
      const n3 = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      }, t3 = {
        variants: [{
          begin: /\[.+?\]\[.*?\]/,
          relevance: 0
        }, {
          begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
          relevance: 2
        }, {
          begin: e3.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
          relevance: 2
        }, {
          begin: /\[.+?\]\([./?&#].*?\)/,
          relevance: 1
        }, {
          begin: /\[.*?\]\(.*?\)/,
          relevance: 0
        }],
        returnBegin: true,
        contains: [{
          match: /\[(?=\])/
        }, {
          className: "string",
          relevance: 0,
          begin: "\\[",
          end: "\\]",
          excludeBegin: true,
          returnEnd: true
        }, {
          className: "link",
          relevance: 0,
          begin: "\\]\\(",
          end: "\\)",
          excludeBegin: true,
          excludeEnd: true
        }, {
          className: "symbol",
          relevance: 0,
          begin: "\\]\\[",
          end: "\\]",
          excludeBegin: true,
          excludeEnd: true
        }]
      }, a4 = {
        className: "strong",
        contains: [],
        variants: [{
          begin: /_{2}(?!\s)/,
          end: /_{2}/
        }, {
          begin: /\*{2}(?!\s)/,
          end: /\*{2}/
        }]
      }, i4 = {
        className: "emphasis",
        contains: [],
        variants: [{
          begin: /\*(?![*\s])/,
          end: /\*/
        }, {
          begin: /_(?![_\s])/,
          end: /_/,
          relevance: 0
        }]
      }, r3 = e3.inherit(a4, {
        contains: []
      }), s3 = e3.inherit(i4, {
        contains: []
      });
      a4.contains.push(s3), i4.contains.push(r3);
      let o4 = [n3, t3];
      return [a4, i4, r3, s3].forEach((e4) => {
        e4.contains = e4.contains.concat(o4);
      }), o4 = o4.concat(a4, i4), {
        name: "Markdown",
        aliases: ["md", "mkdown", "mkd"],
        contains: [{
          className: "section",
          variants: [{
            begin: "^#{1,6}",
            end: "$",
            contains: o4
          }, {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [{
              begin: "^[=-]*$"
            }, {
              begin: "^",
              end: "\\n",
              contains: o4
            }]
          }]
        }, n3, {
          className: "bullet",
          begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
          end: "\\s+",
          excludeEnd: true
        }, a4, i4, {
          className: "quote",
          begin: "^>\\s+",
          contains: o4,
          end: "$"
        }, {
          className: "code",
          variants: [{
            begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*"
          }, {
            begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*"
          }, {
            begin: "```",
            end: "```+[ ]*$"
          }, {
            begin: "~~~",
            end: "~~~+[ ]*$"
          }, {
            begin: "`.+?`"
          }, {
            begin: "(?=^( {4}|\\t))",
            contains: [{
              begin: "^( {4}|\\t)",
              end: "(\\n)$"
            }],
            relevance: 0
          }]
        }, {
          begin: "^[-\\*]{3,}",
          end: "$"
        }, t3, {
          begin: /^\[[^\n]+\]:/,
          returnBegin: true,
          contains: [{
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          }, {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }]
        }]
      };
    },
    grmr_objectivec: (e3) => {
      const n3 = /[a-zA-Z@][a-zA-Z0-9_]*/, t3 = {
        $pattern: n3,
        keyword: ["@interface", "@class", "@protocol", "@implementation"]
      };
      return {
        name: "Objective-C",
        aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
        keywords: {
          "variable.language": ["this", "super"],
          $pattern: n3,
          keyword: [
            "while",
            "export",
            "sizeof",
            "typedef",
            "const",
            "struct",
            "for",
            "union",
            "volatile",
            "static",
            "mutable",
            "if",
            "do",
            "return",
            "goto",
            "enum",
            "else",
            "break",
            "extern",
            "asm",
            "case",
            "default",
            "register",
            "explicit",
            "typename",
            "switch",
            "continue",
            "inline",
            "readonly",
            "assign",
            "readwrite",
            "self",
            "@synchronized",
            "id",
            "typeof",
            "nonatomic",
            "IBOutlet",
            "IBAction",
            "strong",
            "weak",
            "copy",
            "in",
            "out",
            "inout",
            "bycopy",
            "byref",
            "oneway",
            "__strong",
            "__weak",
            "__block",
            "__autoreleasing",
            "@private",
            "@protected",
            "@public",
            "@try",
            "@property",
            "@end",
            "@throw",
            "@catch",
            "@finally",
            "@autoreleasepool",
            "@synthesize",
            "@dynamic",
            "@selector",
            "@optional",
            "@required",
            "@encode",
            "@package",
            "@import",
            "@defs",
            "@compatibility_alias",
            "__bridge",
            "__bridge_transfer",
            "__bridge_retained",
            "__bridge_retain",
            "__covariant",
            "__contravariant",
            "__kindof",
            "_Nonnull",
            "_Nullable",
            "_Null_unspecified",
            "__FUNCTION__",
            "__PRETTY_FUNCTION__",
            "__attribute__",
            "getter",
            "setter",
            "retain",
            "unsafe_unretained",
            "nonnull",
            "nullable",
            "null_unspecified",
            "null_resettable",
            "class",
            "instancetype",
            "NS_DESIGNATED_INITIALIZER",
            "NS_UNAVAILABLE",
            "NS_REQUIRES_SUPER",
            "NS_RETURNS_INNER_POINTER",
            "NS_INLINE",
            "NS_AVAILABLE",
            "NS_DEPRECATED",
            "NS_ENUM",
            "NS_OPTIONS",
            "NS_SWIFT_UNAVAILABLE",
            "NS_ASSUME_NONNULL_BEGIN",
            "NS_ASSUME_NONNULL_END",
            "NS_REFINED_FOR_SWIFT",
            "NS_SWIFT_NAME",
            "NS_SWIFT_NOTHROW",
            "NS_DURING",
            "NS_HANDLER",
            "NS_ENDHANDLER",
            "NS_VALUERETURN",
            "NS_VOIDRETURN"
          ],
          literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
          built_in: ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"],
          type: [
            "int",
            "float",
            "char",
            "unsigned",
            "signed",
            "short",
            "long",
            "double",
            "wchar_t",
            "unichar",
            "void",
            "bool",
            "BOOL",
            "id|0",
            "_Bool"
          ]
        },
        illegal: "</",
        contains: [
          {
            className: "built_in",
            begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
          },
          e3.C_LINE_COMMENT_MODE,
          e3.C_BLOCK_COMMENT_MODE,
          e3.C_NUMBER_MODE,
          e3.QUOTE_STRING_MODE,
          e3.APOS_STRING_MODE,
          {
            className: "string",
            variants: [{
              begin: '@"',
              end: '"',
              illegal: "\\n",
              contains: [e3.BACKSLASH_ESCAPE]
            }]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
              keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include"
            },
            contains: [{
              begin: /\\\n/,
              relevance: 0
            }, e3.inherit(e3.QUOTE_STRING_MODE, {
              className: "string"
            }), {
              className: "string",
              begin: /<.*?>/,
              end: /$/,
              illegal: "\\n"
            }, e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE]
          },
          {
            className: "class",
            begin: "(" + t3.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: t3,
            contains: [e3.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + e3.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    },
    grmr_perl: (e3) => {
      const n3 = e3.regex, t3 = /[dualxmsipngr]{0,12}/, a4 = {
        $pattern: /[\w.]+/,
        keyword: "abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir connect continue cos crypt dbmclose dbmopen defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eval exec exists exit exp fcntl fileno flock for foreach fork format formline getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst length link listen local localtime log lstat lt ma map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q|0 qq quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x|0 xor y|0"
      }, i4 = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: a4
      }, r3 = {
        begin: /->\{/,
        end: /\}/
      }, s3 = {
        variants: [{
          begin: /\$\d/
        }, {
          begin: n3.concat(/[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, "(?![A-Za-z])(?![@$%])")
        }, {
          begin: /[$%@][^\s\w{]/,
          relevance: 0
        }]
      }, o4 = [e3.BACKSLASH_ESCAPE, i4, s3], l4 = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/], c3 = (e4, a5, i5 = "\\1") => {
        const r4 = "\\1" === i5 ? i5 : n3.concat(i5, a5);
        return n3.concat(n3.concat("(?:", e4, ")"), a5, /(?:\\.|[^\\\/])*?/, r4, /(?:\\.|[^\\\/])*?/, i5, t3);
      }, d3 = (e4, a5, i5) => n3.concat(n3.concat("(?:", e4, ")"), a5, /(?:\\.|[^\\\/])*?/, i5, t3), g4 = [s3, e3.HASH_COMMENT_MODE, e3.COMMENT(/^=\w/, /=cut/, {
        endsWithParent: true
      }), r3, {
        className: "string",
        contains: o4,
        variants: [{
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        }, {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        }, {
          begin: "'",
          end: "'",
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: '"',
          end: '"'
        }, {
          begin: "`",
          end: "`",
          contains: [e3.BACKSLASH_ESCAPE]
        }, {
          begin: /\{\w+\}/,
          relevance: 0
        }, {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }]
      }, {
        className: "number",
        begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
        relevance: 0
      }, {
        begin: "(\\/\\/|" + e3.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
        keywords: "split return print reverse grep",
        relevance: 0,
        contains: [e3.HASH_COMMENT_MODE, {
          className: "regexp",
          variants: [{
            begin: c3("s|tr|y", n3.either(...l4, {
              capture: true
            }))
          }, {
            begin: c3("s|tr|y", "\\(", "\\)")
          }, {
            begin: c3("s|tr|y", "\\[", "\\]")
          }, {
            begin: c3("s|tr|y", "\\{", "\\}")
          }],
          relevance: 2
        }, {
          className: "regexp",
          variants: [{
            begin: /(m|qr)\/\//,
            relevance: 0
          }, {
            begin: d3("(?:m|qr)?", /\//, /\//)
          }, {
            begin: d3("m|qr", n3.either(...l4, {
              capture: true
            }), /\1/)
          }, {
            begin: d3("m|qr", /\(/, /\)/)
          }, {
            begin: d3("m|qr", /\[/, /\]/)
          }, {
            begin: d3("m|qr", /\{/, /\}/)
          }]
        }]
      }, {
        className: "function",
        beginKeywords: "sub",
        end: "(\\s*\\(.*?\\))?[;{]",
        excludeEnd: true,
        relevance: 5,
        contains: [e3.TITLE_MODE]
      }, {
        begin: "-\\w\\b",
        relevance: 0
      }, {
        begin: "^__DATA__$",
        end: "^__END__$",
        subLanguage: "mojolicious",
        contains: [{
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }]
      }];
      return i4.contains = g4, r3.contains = g4, {
        name: "Perl",
        aliases: ["pl", "pm"],
        keywords: a4,
        contains: g4
      };
    },
    grmr_php: (e3) => {
      const n3 = e3.regex, t3 = /(?![A-Za-z0-9])(?![$])/, a4 = n3.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, t3), i4 = n3.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, t3), r3 = {
        scope: "variable",
        match: "\\$+" + a4
      }, s3 = {
        scope: "subst",
        variants: [{
          begin: /\$\w+/
        }, {
          begin: /\{\$/,
          end: /\}/
        }]
      }, o4 = e3.inherit(e3.APOS_STRING_MODE, {
        illegal: null
      }), l4 = "[ 	\n]", c3 = {
        scope: "string",
        variants: [e3.inherit(e3.QUOTE_STRING_MODE, {
          illegal: null,
          contains: e3.QUOTE_STRING_MODE.contains.concat(s3)
        }), o4, e3.END_SAME_AS_BEGIN({
          begin: /<<<[ \t]*(\w+)\n/,
          end: /[ \t]*(\w+)\b/,
          contains: e3.QUOTE_STRING_MODE.contains.concat(s3)
        })]
      }, d3 = {
        scope: "number",
        variants: [{
          begin: "\\b0[bB][01]+(?:_[01]+)*\\b"
        }, {
          begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b"
        }, {
          begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b"
        }, {
          begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?"
        }],
        relevance: 0
      }, g4 = ["false", "null", "true"], u4 = [
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ], b3 = [
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ], m3 = {
        keyword: u4,
        literal: ((e4) => {
          const n4 = [];
          return e4.forEach((e5) => {
            n4.push(e5), e5.toLowerCase() === e5 ? n4.push(e5.toUpperCase()) : n4.push(e5.toLowerCase());
          }), n4;
        })(g4),
        built_in: b3
      }, p3 = (e4) => e4.map((e5) => e5.replace(/\|\d+$/, "")), _4 = {
        variants: [{
          match: [/new/, n3.concat(l4, "+"), n3.concat("(?!", p3(b3).join("\\b|"), "\\b)"), i4],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }]
      }, h3 = n3.concat(a4, "\\b(?!\\()"), f4 = {
        variants: [{
          match: [n3.concat(/::/, n3.lookahead(/(?!class\b)/)), h3],
          scope: {
            2: "variable.constant"
          }
        }, {
          match: [/::/, /class/],
          scope: {
            2: "variable.language"
          }
        }, {
          match: [i4, n3.concat(/::/, n3.lookahead(/(?!class\b)/)), h3],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        }, {
          match: [i4, n3.concat("::", n3.lookahead(/(?!class\b)/))],
          scope: {
            1: "title.class"
          }
        }, {
          match: [i4, /::/, /class/],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }]
      }, E4 = {
        scope: "attr",
        match: n3.concat(a4, n3.lookahead(":"), n3.lookahead(/(?!::)/))
      }, y3 = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: m3,
        contains: [E4, r3, f4, e3.C_BLOCK_COMMENT_MODE, c3, d3, _4]
      }, w3 = {
        relevance: 0,
        match: [
          /\b/,
          n3.concat("(?!fn\\b|function\\b|", p3(u4).join("\\b|"), "|", p3(b3).join("\\b|"), "\\b)"),
          a4,
          n3.concat(l4, "*"),
          n3.lookahead(/(?=\()/)
        ],
        scope: {
          3: "title.function.invoke"
        },
        contains: [y3]
      };
      y3.contains.push(w3);
      const N4 = [E4, f4, e3.C_BLOCK_COMMENT_MODE, c3, d3, _4];
      return {
        case_insensitive: false,
        keywords: m3,
        contains: [{
          begin: n3.concat(/#\[\s*/, i4),
          beginScope: "meta",
          end: /]/,
          endScope: "meta",
          keywords: {
            literal: g4,
            keyword: ["new", "array"]
          },
          contains: [{
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: g4,
              keyword: ["new", "array"]
            },
            contains: ["self", ...N4]
          }, ...N4, {
            scope: "meta",
            match: i4
          }]
        }, e3.HASH_COMMENT_MODE, e3.COMMENT("//", "$"), e3.COMMENT("/\\*", "\\*/", {
          contains: [{
            scope: "doctag",
            match: "@[A-Za-z]+"
          }]
        }), {
          match: /__halt_compiler\(\);/,
          keywords: "__halt_compiler",
          starts: {
            scope: "comment",
            end: e3.MATCH_NOTHING_RE,
            contains: [{
              match: /\?>/,
              scope: "meta",
              endsParent: true
            }]
          }
        }, {
          scope: "meta",
          variants: [{
            begin: /<\?php/,
            relevance: 10
          }, {
            begin: /<\?=/
          }, {
            begin: /<\?/,
            relevance: 0.1
          }, {
            begin: /\?>/
          }]
        }, {
          scope: "variable.language",
          match: /\$this\b/
        }, r3, w3, f4, {
          match: [/const/, /\s/, a4],
          scope: {
            1: "keyword",
            3: "variable.constant"
          }
        }, _4, {
          scope: "function",
          relevance: 0,
          beginKeywords: "fn function",
          end: /[;{]/,
          excludeEnd: true,
          illegal: "[$%\\[]",
          contains: [{
            beginKeywords: "use"
          }, e3.UNDERSCORE_TITLE_MODE, {
            begin: "=>",
            endsParent: true
          }, {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: m3,
            contains: ["self", r3, f4, e3.C_BLOCK_COMMENT_MODE, c3, d3]
          }]
        }, {
          scope: "class",
          variants: [{
            beginKeywords: "enum",
            illegal: /[($"]/
          }, {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }],
          relevance: 0,
          end: /\{/,
          excludeEnd: true,
          contains: [{
            beginKeywords: "extends implements"
          }, e3.UNDERSCORE_TITLE_MODE]
        }, {
          beginKeywords: "namespace",
          relevance: 0,
          end: ";",
          illegal: /[.']/,
          contains: [e3.inherit(e3.UNDERSCORE_TITLE_MODE, {
            scope: "title.class"
          })]
        }, {
          beginKeywords: "use",
          relevance: 0,
          end: ";",
          contains: [{
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          }, e3.UNDERSCORE_TITLE_MODE]
        }, c3, d3]
      };
    },
    grmr_php_template: (e3) => ({
      name: "PHP template",
      subLanguage: "xml",
      contains: [{
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [{
          begin: "/\\*",
          end: "\\*/",
          skip: true
        }, {
          begin: 'b"',
          end: '"',
          skip: true
        }, {
          begin: "b'",
          end: "'",
          skip: true
        }, e3.inherit(e3.APOS_STRING_MODE, {
          illegal: null,
          className: null,
          contains: null,
          skip: true
        }), e3.inherit(e3.QUOTE_STRING_MODE, {
          illegal: null,
          className: null,
          contains: null,
          skip: true
        })]
      }]
    }),
    grmr_plaintext: (e3) => ({
      name: "Plain text",
      aliases: ["text", "txt"],
      disableAutodetect: true
    }),
    grmr_python: (e3) => {
      const n3 = e3.regex, t3 = /(?:[A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFC5D\uFC64-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDF9\uFE71\uFE73\uFE77\uFE79\uFE7B\uFE7D\uFE7F-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037B-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0898-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFC5D\uFC64-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDF9\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE71\uFE73\uFE77\uFE79\uFE7B\uFE7D\uFE7F-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEFD-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF59\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF])*/, a4 = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ], i4 = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: a4,
        built_in: [
          "__import__",
          "abs",
          "all",
          "any",
          "ascii",
          "bin",
          "bool",
          "breakpoint",
          "bytearray",
          "bytes",
          "callable",
          "chr",
          "classmethod",
          "compile",
          "complex",
          "delattr",
          "dict",
          "dir",
          "divmod",
          "enumerate",
          "eval",
          "exec",
          "filter",
          "float",
          "format",
          "frozenset",
          "getattr",
          "globals",
          "hasattr",
          "hash",
          "help",
          "hex",
          "id",
          "input",
          "int",
          "isinstance",
          "issubclass",
          "iter",
          "len",
          "list",
          "locals",
          "map",
          "max",
          "memoryview",
          "min",
          "next",
          "object",
          "oct",
          "open",
          "ord",
          "pow",
          "print",
          "property",
          "range",
          "repr",
          "reversed",
          "round",
          "set",
          "setattr",
          "slice",
          "sorted",
          "staticmethod",
          "str",
          "sum",
          "super",
          "tuple",
          "type",
          "vars",
          "zip"
        ],
        literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
        type: [
          "Any",
          "Callable",
          "Coroutine",
          "Dict",
          "List",
          "Literal",
          "Generic",
          "Optional",
          "Sequence",
          "Set",
          "Tuple",
          "Type",
          "Union"
        ]
      }, r3 = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      }, s3 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: i4,
        illegal: /#/
      }, o4 = {
        begin: /\{\{/,
        relevance: 0
      }, l4 = {
        className: "string",
        contains: [e3.BACKSLASH_ESCAPE],
        variants: [{
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
          end: /'''/,
          contains: [e3.BACKSLASH_ESCAPE, r3],
          relevance: 10
        }, {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
          end: /"""/,
          contains: [e3.BACKSLASH_ESCAPE, r3],
          relevance: 10
        }, {
          begin: /([fF][rR]|[rR][fF]|[fF])'''/,
          end: /'''/,
          contains: [e3.BACKSLASH_ESCAPE, r3, o4, s3]
        }, {
          begin: /([fF][rR]|[rR][fF]|[fF])"""/,
          end: /"""/,
          contains: [e3.BACKSLASH_ESCAPE, r3, o4, s3]
        }, {
          begin: /([uU]|[rR])'/,
          end: /'/,
          relevance: 10
        }, {
          begin: /([uU]|[rR])"/,
          end: /"/,
          relevance: 10
        }, {
          begin: /([bB]|[bB][rR]|[rR][bB])'/,
          end: /'/
        }, {
          begin: /([bB]|[bB][rR]|[rR][bB])"/,
          end: /"/
        }, {
          begin: /([fF][rR]|[rR][fF]|[fF])'/,
          end: /'/,
          contains: [e3.BACKSLASH_ESCAPE, o4, s3]
        }, {
          begin: /([fF][rR]|[rR][fF]|[fF])"/,
          end: /"/,
          contains: [e3.BACKSLASH_ESCAPE, o4, s3]
        }, e3.APOS_STRING_MODE, e3.QUOTE_STRING_MODE]
      }, c3 = "[0-9](_?[0-9])*", d3 = `(\\b(${c3}))?\\.(${c3})|\\b(${c3})\\.`, g4 = "\\b|" + a4.join("|"), u4 = {
        className: "number",
        relevance: 0,
        variants: [{
          begin: `(\\b(${c3})|(${d3}))[eE][+-]?(${c3})[jJ]?(?=${g4})`
        }, {
          begin: `(${d3})[jJ]?`
        }, {
          begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${g4})`
        }, {
          begin: `\\b0[bB](_?[01])+[lL]?(?=${g4})`
        }, {
          begin: `\\b0[oO](_?[0-7])+[lL]?(?=${g4})`
        }, {
          begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${g4})`
        }, {
          begin: `\\b(${c3})[jJ](?=${g4})`
        }]
      }, b3 = {
        className: "comment",
        begin: n3.lookahead(/# type:/),
        end: /$/,
        keywords: i4,
        contains: [{
          begin: /# type:/
        }, {
          begin: /#/,
          end: /\b\B/,
          endsWithParent: true
        }]
      }, m3 = {
        className: "params",
        variants: [{
          className: "",
          begin: /\(\s*\)/,
          skip: true
        }, {
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: i4,
          contains: ["self", r3, u4, l4, e3.HASH_COMMENT_MODE]
        }]
      };
      return s3.contains = [l4, u4, r3], {
        name: "Python",
        aliases: ["py", "gyp", "ipython"],
        unicodeRegex: true,
        keywords: i4,
        illegal: /(<\/|->|\?)|=>/,
        contains: [r3, u4, {
          begin: /\bself\b/
        }, {
          beginKeywords: "if",
          relevance: 0
        }, l4, b3, e3.HASH_COMMENT_MODE, {
          match: [/\bdef/, /\s+/, t3],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [m3]
        }, {
          variants: [{
            match: [/\bclass/, /\s+/, t3, /\s*/, /\(\s*/, t3, /\s*\)/]
          }, {
            match: [/\bclass/, /\s+/, t3]
          }],
          scope: {
            1: "keyword",
            3: "title.class",
            6: "title.class.inherited"
          }
        }, {
          className: "meta",
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [u4, m3, l4]
        }]
      };
    },
    grmr_python_repl: (e3) => ({
      aliases: ["pycon"],
      contains: [{
        className: "meta.prompt",
        starts: {
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [{
          begin: /^>>>(?=[ ]|$)/
        }, {
          begin: /^\.\.\.(?=[ ]|$)/
        }]
      }]
    }),
    grmr_r: (e3) => {
      const n3 = e3.regex, t3 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, a4 = n3.either(
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ), i4 = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, r3 = n3.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
      return {
        name: "R",
        keywords: {
          $pattern: t3,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
        },
        contains: [e3.COMMENT(/#'/, /$/, {
          contains: [{
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: n3.lookahead(n3.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
              endsParent: true
            }
          }, {
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [{
              scope: "variable",
              variants: [{
                match: t3
              }, {
                match: /`(?:\\.|[^`\\])+`/
              }],
              endsParent: true
            }]
          }, {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          }, {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }]
        }), e3.HASH_COMMENT_MODE, {
          scope: "string",
          contains: [e3.BACKSLASH_ESCAPE],
          variants: [e3.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }), e3.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }), e3.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }), e3.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }), e3.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }), e3.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }), {
            begin: '"',
            end: '"',
            relevance: 0
          }, {
            begin: "'",
            end: "'",
            relevance: 0
          }]
        }, {
          relevance: 0,
          variants: [{
            scope: {
              1: "operator",
              2: "number"
            },
            match: [i4, a4]
          }, {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [/%[^%]*%/, a4]
          }, {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [r3, a4]
          }, {
            scope: {
              2: "number"
            },
            match: [/[^a-zA-Z0-9._]|^/, a4]
          }]
        }, {
          scope: {
            3: "operator"
          },
          match: [t3, /\s+/, /<-/, /\s+/]
        }, {
          scope: "operator",
          relevance: 0,
          variants: [{
            match: i4
          }, {
            match: /%[^%]*%/
          }]
        }, {
          scope: "punctuation",
          relevance: 0,
          match: r3
        }, {
          begin: "`",
          end: "`",
          contains: [{
            begin: /\\./
          }]
        }]
      };
    },
    grmr_ruby: (e3) => {
      const n3 = e3.regex, t3 = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", a4 = n3.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/), i4 = n3.concat(a4, /(::\w+)*/), r3 = {
        "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
        "variable.language": ["self", "super"],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          "include",
          "extend",
          "prepend",
          "public",
          "private",
          "protected",
          "raise",
          "throw"
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: ["true", "false", "nil"]
      }, s3 = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      }, o4 = {
        begin: "#<",
        end: ">"
      }, l4 = [e3.COMMENT("#", "$", {
        contains: [s3]
      }), e3.COMMENT("^=begin", "^=end", {
        contains: [s3],
        relevance: 10
      }), e3.COMMENT("^__END__", e3.MATCH_NOTHING_RE)], c3 = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: r3
      }, d3 = {
        className: "string",
        contains: [e3.BACKSLASH_ESCAPE, c3],
        variants: [{
          begin: /'/,
          end: /'/
        }, {
          begin: /"/,
          end: /"/
        }, {
          begin: /`/,
          end: /`/
        }, {
          begin: /%[qQwWx]?\(/,
          end: /\)/
        }, {
          begin: /%[qQwWx]?\[/,
          end: /\]/
        }, {
          begin: /%[qQwWx]?\{/,
          end: /\}/
        }, {
          begin: /%[qQwWx]?</,
          end: />/
        }, {
          begin: /%[qQwWx]?\//,
          end: /\//
        }, {
          begin: /%[qQwWx]?%/,
          end: /%/
        }, {
          begin: /%[qQwWx]?-/,
          end: /-/
        }, {
          begin: /%[qQwWx]?\|/,
          end: /\|/
        }, {
          begin: /\B\?(\\\d{1,3})/
        }, {
          begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
        }, {
          begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
        }, {
          begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
        }, {
          begin: /\B\?\\(c|C-)[\x20-\x7e]/
        }, {
          begin: /\B\?\\?\S/
        }, {
          begin: n3.concat(/<<[-~]?'?/, n3.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
          contains: [e3.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [e3.BACKSLASH_ESCAPE, c3]
          })]
        }]
      }, g4 = "[0-9](_?[0-9])*", u4 = {
        className: "number",
        relevance: 0,
        variants: [{
          begin: `\\b([1-9](_?[0-9])*|0)(\\.(${g4}))?([eE][+-]?(${g4})|r)?i?\\b`
        }, {
          begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
        }, {
          begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
        }, {
          begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b"
        }, {
          begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
        }, {
          begin: "\\b0(_?[0-7])+r?i?\\b"
        }]
      }, b3 = {
        variants: [{
          match: /\(\)/
        }, {
          className: "params",
          begin: /\(/,
          end: /(?=\))/,
          excludeBegin: true,
          endsParent: true,
          keywords: r3
        }]
      }, m3 = [d3, {
        variants: [{
          match: [/class\s+/, i4, /\s+<\s+/, i4]
        }, {
          match: [/\b(class|module)\s+/, i4]
        }],
        scope: {
          2: "title.class",
          4: "title.class.inherited"
        },
        keywords: r3
      }, {
        match: [/(include|extend)\s+/, i4],
        scope: {
          2: "title.class"
        },
        keywords: r3
      }, {
        relevance: 0,
        match: [i4, /\.new[. (]/],
        scope: {
          1: "title.class"
        }
      }, {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      }, {
        relevance: 0,
        match: a4,
        scope: "title.class"
      }, {
        match: [/def/, /\s+/, t3],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [b3]
      }, {
        begin: e3.IDENT_RE + "::"
      }, {
        className: "symbol",
        begin: e3.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
        relevance: 0
      }, {
        className: "symbol",
        begin: ":(?!\\s)",
        contains: [d3, {
          begin: t3
        }],
        relevance: 0
      }, u4, {
        className: "variable",
        begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
      }, {
        className: "params",
        begin: /\|/,
        end: /\|/,
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0,
        keywords: r3
      }, {
        begin: "(" + e3.RE_STARTERS_RE + "|unless)\\s*",
        keywords: "unless",
        contains: [{
          className: "regexp",
          contains: [e3.BACKSLASH_ESCAPE, c3],
          illegal: /\n/,
          variants: [{
            begin: "/",
            end: "/[a-z]*"
          }, {
            begin: /%r\{/,
            end: /\}[a-z]*/
          }, {
            begin: "%r\\(",
            end: "\\)[a-z]*"
          }, {
            begin: "%r!",
            end: "![a-z]*"
          }, {
            begin: "%r\\[",
            end: "\\][a-z]*"
          }]
        }].concat(o4, l4),
        relevance: 0
      }].concat(o4, l4);
      c3.contains = m3, b3.contains = m3;
      const p3 = [{
        begin: /^\s*=>/,
        starts: {
          end: "$",
          contains: m3
        }
      }, {
        className: "meta.prompt",
        begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
        starts: {
          end: "$",
          keywords: r3,
          contains: m3
        }
      }];
      return l4.unshift(o4), {
        name: "Ruby",
        aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
        keywords: r3,
        illegal: /\/\*/,
        contains: [e3.SHEBANG({
          binary: "ruby"
        })].concat(p3).concat(l4).concat(m3)
      };
    },
    grmr_rust: (e3) => {
      const n3 = e3.regex, t3 = {
        className: "title.function.invoke",
        relevance: 0,
        begin: n3.concat(/\b/, /(?!let\b)/, e3.IDENT_RE, n3.lookahead(/\s*\(/))
      }, a4 = "([ui](8|16|32|64|128|size)|f(32|64))?", i4 = [
        "drop ",
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ], r3 = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: e3.IDENT_RE + "!?",
          type: r3,
          keyword: [
            "abstract",
            "as",
            "async",
            "await",
            "become",
            "box",
            "break",
            "const",
            "continue",
            "crate",
            "do",
            "dyn",
            "else",
            "enum",
            "extern",
            "false",
            "final",
            "fn",
            "for",
            "if",
            "impl",
            "in",
            "let",
            "loop",
            "macro",
            "match",
            "mod",
            "move",
            "mut",
            "override",
            "priv",
            "pub",
            "ref",
            "return",
            "self",
            "Self",
            "static",
            "struct",
            "super",
            "trait",
            "true",
            "try",
            "type",
            "typeof",
            "unsafe",
            "unsized",
            "use",
            "virtual",
            "where",
            "while",
            "yield"
          ],
          literal: ["true", "false", "Some", "None", "Ok", "Err"],
          built_in: i4
        },
        illegal: "</",
        contains: [e3.C_LINE_COMMENT_MODE, e3.COMMENT("/\\*", "\\*/", {
          contains: ["self"]
        }), e3.inherit(e3.QUOTE_STRING_MODE, {
          begin: /b?"/,
          illegal: null
        }), {
          className: "string",
          variants: [{
            begin: /b?r(#*)"(.|\n)*?"\1(?!#)/
          }, {
            begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/
          }]
        }, {
          className: "symbol",
          begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
        }, {
          className: "number",
          variants: [{
            begin: "\\b0b([01_]+)" + a4
          }, {
            begin: "\\b0o([0-7_]+)" + a4
          }, {
            begin: "\\b0x([A-Fa-f0-9_]+)" + a4
          }, {
            begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + a4
          }],
          relevance: 0
        }, {
          begin: [/fn/, /\s+/, e3.UNDERSCORE_IDENT_RE],
          className: {
            1: "keyword",
            3: "title.function"
          }
        }, {
          className: "meta",
          begin: "#!?\\[",
          end: "\\]",
          contains: [{
            className: "string",
            begin: /"/,
            end: /"/
          }]
        }, {
          begin: [/let/, /\s+/, /(?:mut\s+)?/, e3.UNDERSCORE_IDENT_RE],
          className: {
            1: "keyword",
            3: "keyword",
            4: "variable"
          }
        }, {
          begin: [/for/, /\s+/, e3.UNDERSCORE_IDENT_RE, /\s+/, /in/],
          className: {
            1: "keyword",
            3: "variable",
            5: "keyword"
          }
        }, {
          begin: [/type/, /\s+/, e3.UNDERSCORE_IDENT_RE],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }, {
          begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, e3.UNDERSCORE_IDENT_RE],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }, {
          begin: e3.IDENT_RE + "::",
          keywords: {
            keyword: "Self",
            built_in: i4,
            type: r3
          }
        }, {
          className: "punctuation",
          begin: "->"
        }, t3]
      };
    },
    grmr_scss: (e3) => {
      const n3 = J2(e3), t3 = te2, a4 = ne2, i4 = "@[a-z-]+", r3 = {
        className: "variable",
        begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [e3.C_LINE_COMMENT_MODE, e3.C_BLOCK_COMMENT_MODE, n3.CSS_NUMBER_MODE, {
          className: "selector-id",
          begin: "#[A-Za-z0-9_-]+",
          relevance: 0
        }, {
          className: "selector-class",
          begin: "\\.[A-Za-z0-9_-]+",
          relevance: 0
        }, n3.ATTRIBUTE_SELECTOR_MODE, {
          className: "selector-tag",
          begin: "\\b(" + Y2.join("|") + ")\\b",
          relevance: 0
        }, {
          className: "selector-pseudo",
          begin: ":(" + a4.join("|") + ")"
        }, {
          className: "selector-pseudo",
          begin: ":(:)?(" + t3.join("|") + ")"
        }, r3, {
          begin: /\(/,
          end: /\)/,
          contains: [n3.CSS_NUMBER_MODE]
        }, n3.CSS_VARIABLE, {
          className: "attribute",
          begin: "\\b(" + ae2.join("|") + ")\\b"
        }, {
          begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
        }, {
          begin: /:/,
          end: /[;}{]/,
          relevance: 0,
          contains: [
            n3.BLOCK_COMMENT,
            r3,
            n3.HEXCOLOR,
            n3.CSS_NUMBER_MODE,
            e3.QUOTE_STRING_MODE,
            e3.APOS_STRING_MODE,
            n3.IMPORTANT,
            n3.FUNCTION_DISPATCH
          ]
        }, {
          begin: "@(page|font-face)",
          keywords: {
            $pattern: i4,
            keyword: "@page @font-face"
          }
        }, {
          begin: "@",
          end: "[{;]",
          returnBegin: true,
          keywords: {
            $pattern: /[a-z-]+/,
            keyword: "and or not only",
            attribute: ee2.join(" ")
          },
          contains: [{
            begin: i4,
            className: "keyword"
          }, {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          }, r3, e3.QUOTE_STRING_MODE, e3.APOS_STRING_MODE, n3.HEXCOLOR, n3.CSS_NUMBER_MODE]
        }, n3.FUNCTION_DISPATCH]
      };
    },
    grmr_shell: (e3) => ({
      name: "Shell Session",
      aliases: ["console", "shellsession"],
      contains: [{
        className: "meta.prompt",
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }]
    }),
    grmr_sql: (e3) => {
      const n3 = e3.regex, t3 = e3.COMMENT("--", "$"), a4 = ["true", "false", "unknown"], i4 = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        "varbinary"
      ], r3 = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ], s3 = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ], o4 = r3, l4 = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year",
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ].filter((e4) => !r3.includes(e4)), c3 = {
        begin: n3.concat(/\b/, n3.either(...o4), /\s*\(/),
        relevance: 0,
        keywords: {
          built_in: o4
        }
      };
      return {
        name: "SQL",
        case_insensitive: true,
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: ((e4, {
            exceptions: n4,
            when: t4
          } = {}) => {
            const a5 = t4;
            return n4 = n4 || [], e4.map((e5) => e5.match(/\|\d+$/) || n4.includes(e5) ? e5 : a5(e5) ? e5 + "|0" : e5);
          })(l4, {
            when: (e4) => e4.length < 3
          }),
          literal: a4,
          type: i4,
          built_in: [
            "current_catalog",
            "current_date",
            "current_default_transform_group",
            "current_path",
            "current_role",
            "current_schema",
            "current_transform_group_for_type",
            "current_user",
            "session_user",
            "system_time",
            "system_user",
            "current_time",
            "localtime",
            "current_timestamp",
            "localtimestamp"
          ]
        },
        contains: [{
          begin: n3.either(...s3),
          relevance: 0,
          keywords: {
            $pattern: /[\w\.]+/,
            keyword: l4.concat(s3),
            literal: a4,
            type: i4
          }
        }, {
          className: "type",
          begin: n3.either("double precision", "large object", "with timezone", "without timezone")
        }, c3, {
          className: "variable",
          begin: /@[a-z0-9]+/
        }, {
          className: "string",
          variants: [{
            begin: /'/,
            end: /'/,
            contains: [{
              begin: /''/
            }]
          }]
        }, {
          begin: /"/,
          end: /"/,
          contains: [{
            begin: /""/
          }]
        }, e3.C_NUMBER_MODE, e3.C_BLOCK_COMMENT_MODE, t3, {
          className: "operator",
          begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
          relevance: 0
        }]
      };
    },
    grmr_swift: (e3) => {
      const n3 = {
        match: /\s+/,
        relevance: 0
      }, t3 = e3.COMMENT("/\\*", "\\*/", {
        contains: ["self"]
      }), a4 = [e3.C_LINE_COMMENT_MODE, t3], i4 = {
        match: [/\./, p2(...Ee2, ...ye2)],
        className: {
          2: "keyword"
        }
      }, r3 = {
        match: m2(/\./, p2(...Ne2)),
        relevance: 0
      }, s3 = Ne2.filter((e4) => "string" == typeof e4).concat(["_|0"]), o4 = {
        variants: [{
          className: "keyword",
          match: p2(...Ne2.filter((e4) => "string" != typeof e4).concat(we2).map(fe2), ...ye2)
        }]
      }, l4 = {
        $pattern: p2(/\b\w+/, /#\w+/),
        keyword: s3.concat(ke2),
        literal: ve2
      }, c3 = [i4, r3, o4], d3 = [{
        match: m2(/\./, p2(...xe2)),
        relevance: 0
      }, {
        className: "built_in",
        match: m2(/\b/, p2(...xe2), /(?=\()/)
      }], u4 = {
        match: /->/,
        relevance: 0
      }, b3 = [u4, {
        className: "operator",
        relevance: 0,
        variants: [{
          match: Ae2
        }, {
          match: `\\.(\\.|${Se2})+`
        }]
      }], _4 = "([0-9a-fA-F]_*)+", h3 = {
        className: "number",
        relevance: 0,
        variants: [{
          match: "\\b(([0-9]_*)+)(\\.(([0-9]_*)+))?([eE][+-]?(([0-9]_*)+))?\\b"
        }, {
          match: `\\b0x(${_4})(\\.(${_4}))?([pP][+-]?(([0-9]_*)+))?\\b`
        }, {
          match: /\b0o([0-7]_*)+\b/
        }, {
          match: /\b0b([01]_*)+\b/
        }]
      }, f4 = (e4 = "") => ({
        className: "subst",
        variants: [{
          match: m2(/\\/, e4, /[0\\tnr"']/)
        }, {
          match: m2(/\\/, e4, /u\{[0-9a-fA-F]{1,8}\}/)
        }]
      }), E4 = (e4 = "") => ({
        className: "subst",
        match: m2(/\\/, e4, /[\t ]*(?:[\r\n]|\r\n)/)
      }), y3 = (e4 = "") => ({
        className: "subst",
        label: "interpol",
        begin: m2(/\\/, e4, /\(/),
        end: /\)/
      }), w3 = (e4 = "") => ({
        begin: m2(e4, /"""/),
        end: m2(/"""/, e4),
        contains: [f4(e4), E4(e4), y3(e4)]
      }), N4 = (e4 = "") => ({
        begin: m2(e4, /"/),
        end: m2(/"/, e4),
        contains: [f4(e4), y3(e4)]
      }), v3 = {
        className: "string",
        variants: [w3(), w3("#"), w3("##"), w3("###"), N4(), N4("#"), N4("##"), N4("###")]
      }, O4 = {
        match: m2(/`/, Re2, /`/)
      }, k4 = [O4, {
        className: "variable",
        match: /\$\d+/
      }, {
        className: "variable",
        match: `\\$${Te2}+`
      }], x3 = [{
        match: /(@|#(un)?)available/,
        className: "keyword",
        starts: {
          contains: [{
            begin: /\(/,
            end: /\)/,
            keywords: Le2,
            contains: [...b3, h3, v3]
          }]
        }
      }, {
        className: "keyword",
        match: m2(/@/, p2(...Ie2))
      }, {
        className: "meta",
        match: m2(/@/, Re2)
      }], M3 = {
        match: g2(/\b[A-Z]/),
        relevance: 0,
        contains: [{
          className: "type",
          match: m2(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Te2, "+")
        }, {
          className: "type",
          match: De2,
          relevance: 0
        }, {
          match: /[?!]+/,
          relevance: 0
        }, {
          match: /\.\.\./,
          relevance: 0
        }, {
          match: m2(/\s+&\s+/, g2(De2)),
          relevance: 0
        }]
      }, S4 = {
        begin: /</,
        end: />/,
        keywords: l4,
        contains: [...a4, ...c3, ...x3, u4, M3]
      };
      M3.contains.push(S4);
      const A4 = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: l4,
        contains: ["self", {
          match: m2(Re2, /\s*:/),
          keywords: "_|0",
          relevance: 0
        }, ...a4, ...c3, ...d3, ...b3, h3, v3, ...k4, ...x3, M3]
      }, C3 = {
        begin: /</,
        end: />/,
        contains: [...a4, M3]
      }, T5 = {
        begin: /\(/,
        end: /\)/,
        keywords: l4,
        contains: [{
          begin: p2(g2(m2(Re2, /\s*:/)), g2(m2(Re2, /\s+/, Re2, /\s*:/))),
          end: /:/,
          relevance: 0,
          contains: [{
            className: "keyword",
            match: /\b_\b/
          }, {
            className: "params",
            match: Re2
          }]
        }, ...a4, ...c3, ...b3, h3, v3, ...x3, M3, A4],
        endsParent: true,
        illegal: /["']/
      }, R3 = {
        match: [/func/, /\s+/, p2(O4.match, Re2, Ae2)],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [C3, T5, n3],
        illegal: [/\[/, /%/]
      }, D4 = {
        match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
        className: {
          1: "keyword"
        },
        contains: [C3, T5, n3],
        illegal: /\[|%/
      }, I4 = {
        match: [/operator/, /\s+/, Ae2],
        className: {
          1: "keyword",
          3: "title"
        }
      }, L4 = {
        begin: [/precedencegroup/, /\s+/, De2],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [M3],
        keywords: [...Oe2, ...ve2],
        end: /}/
      };
      for (const e4 of v3.variants) {
        const n4 = e4.contains.find((e5) => "interpol" === e5.label);
        n4.keywords = l4;
        const t4 = [...c3, ...d3, ...b3, h3, v3, ...k4];
        n4.contains = [...t4, {
          begin: /\(/,
          end: /\)/,
          contains: ["self", ...t4]
        }];
      }
      return {
        name: "Swift",
        keywords: l4,
        contains: [...a4, R3, D4, {
          beginKeywords: "struct protocol class extension enum actor",
          end: "\\{",
          excludeEnd: true,
          keywords: l4,
          contains: [e3.inherit(e3.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }), ...c3]
        }, I4, L4, {
          beginKeywords: "import",
          end: /$/,
          contains: [...a4],
          relevance: 0
        }, ...c3, ...d3, ...b3, h3, v3, ...k4, ...x3, M3, A4]
      };
    },
    grmr_typescript: (e3) => {
      const n3 = he2(e3), t3 = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"], a4 = {
        beginKeywords: "namespace",
        end: /\{/,
        excludeEnd: true,
        contains: [n3.exports.CLASS_REFERENCE]
      }, i4 = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: t3
        },
        contains: [n3.exports.CLASS_REFERENCE]
      }, r3 = {
        $pattern: ce2,
        keyword: de2.concat([
          "type",
          "namespace",
          "interface",
          "public",
          "private",
          "protected",
          "implements",
          "declare",
          "abstract",
          "readonly",
          "enum",
          "override"
        ]),
        literal: ge2,
        built_in: _e2.concat(t3),
        "variable.language": pe2
      }, s3 = {
        className: "meta",
        begin: "@[A-Za-z$_][0-9A-Za-z$_]*"
      }, o4 = (e4, n4, t4) => {
        const a5 = e4.contains.findIndex((e5) => e5.label === n4);
        if (-1 === a5)
          throw Error("can not find mode to replace");
        e4.contains.splice(a5, 1, t4);
      };
      return Object.assign(n3.keywords, r3), n3.exports.PARAMS_CONTAINS.push(s3), n3.contains = n3.contains.concat([s3, a4, i4]), o4(n3, "shebang", e3.SHEBANG()), o4(n3, "use_strict", {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      }), n3.contains.find((e4) => "func.def" === e4.label).relevance = 0, Object.assign(n3, {
        name: "TypeScript",
        aliases: ["ts", "tsx"]
      }), n3;
    },
    grmr_vbnet: (e3) => {
      const n3 = e3.regex, t3 = /\d{1,2}\/\d{1,2}\/\d{4}/, a4 = /\d{4}-\d{1,2}-\d{1,2}/, i4 = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, r3 = /\d{1,2}(:\d{1,2}){1,2}/, s3 = {
        className: "literal",
        variants: [{
          begin: n3.concat(/# */, n3.either(a4, t3), / *#/)
        }, {
          begin: n3.concat(/# */, r3, / *#/)
        }, {
          begin: n3.concat(/# */, i4, / *#/)
        }, {
          begin: n3.concat(/# */, n3.either(a4, t3), / +/, n3.either(i4, r3), / *#/)
        }]
      }, o4 = e3.COMMENT(/'''/, /$/, {
        contains: [{
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }]
      }), l4 = e3.COMMENT(null, /$/, {
        variants: [{
          begin: /'/
        }, {
          begin: /([\t ]|^)REM(?=\s)/
        }]
      });
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: {
          label: "symbol"
        },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
          type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [{
          className: "string",
          begin: /"(""|[^/n])"C\b/
        }, {
          className: "string",
          begin: /"/,
          end: /"/,
          illegal: /\n/,
          contains: [{
            begin: /""/
          }]
        }, s3, {
          className: "number",
          relevance: 0,
          variants: [{
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          }, {
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          }, {
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          }, {
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          }, {
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }]
        }, {
          className: "label",
          begin: /^\w+:/
        }, o4, l4, {
          className: "meta",
          begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
          end: /$/,
          keywords: {
            keyword: "const disable else elseif enable end externalsource if region then"
          },
          contains: [l4]
        }]
      };
    },
    grmr_wasm: (e3) => {
      e3.regex;
      const n3 = e3.COMMENT(/\(;/, /;\)/);
      return n3.contains.push("self"), {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: [
            "anyfunc",
            "block",
            "br",
            "br_if",
            "br_table",
            "call",
            "call_indirect",
            "data",
            "drop",
            "elem",
            "else",
            "end",
            "export",
            "func",
            "global.get",
            "global.set",
            "local.get",
            "local.set",
            "local.tee",
            "get_global",
            "get_local",
            "global",
            "if",
            "import",
            "local",
            "loop",
            "memory",
            "memory.grow",
            "memory.size",
            "module",
            "mut",
            "nop",
            "offset",
            "param",
            "result",
            "return",
            "select",
            "set_global",
            "set_local",
            "start",
            "table",
            "tee_local",
            "then",
            "type",
            "unreachable"
          ]
        },
        contains: [e3.COMMENT(/;;/, /$/), n3, {
          match: [/(?:offset|align)/, /\s*/, /=/],
          className: {
            1: "keyword",
            3: "operator"
          }
        }, {
          className: "variable",
          begin: /\$[\w_]+/
        }, {
          match: /(\((?!;)|\))+/,
          className: "punctuation",
          relevance: 0
        }, {
          begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
          className: {
            1: "keyword",
            3: "title.function"
          }
        }, e3.QUOTE_STRING_MODE, {
          match: /(i32|i64|f32|f64)(?!\.)/,
          className: "type"
        }, {
          className: "keyword",
          match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
        }, {
          className: "number",
          relevance: 0,
          match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
        }]
      };
    },
    grmr_yaml: (e3) => {
      const n3 = "true false yes no null", t3 = "[\\w#;/?:@&=+$,.~*'()[\\]]+", a4 = {
        className: "string",
        relevance: 0,
        variants: [{
          begin: /'/,
          end: /'/
        }, {
          begin: /"/,
          end: /"/
        }, {
          begin: /\S+/
        }],
        contains: [e3.BACKSLASH_ESCAPE, {
          className: "template-variable",
          variants: [{
            begin: /\{\{/,
            end: /\}\}/
          }, {
            begin: /%\{/,
            end: /\}/
          }]
        }]
      }, i4 = e3.inherit(a4, {
        variants: [{
          begin: /'/,
          end: /'/
        }, {
          begin: /"/,
          end: /"/
        }, {
          begin: /[^\s,{}[\]]+/
        }]
      }), r3 = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: n3,
        relevance: 0
      }, s3 = {
        begin: /\{/,
        end: /\}/,
        contains: [r3],
        illegal: "\\n",
        relevance: 0
      }, o4 = {
        begin: "\\[",
        end: "\\]",
        contains: [r3],
        illegal: "\\n",
        relevance: 0
      }, l4 = [{
        className: "attr",
        variants: [{
          begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)"
        }, {
          begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
        }, {
          begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
        }]
      }, {
        className: "meta",
        begin: "^---\\s*$",
        relevance: 10
      }, {
        className: "string",
        begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
      }, {
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0
      }, {
        className: "type",
        begin: "!\\w+!" + t3
      }, {
        className: "type",
        begin: "!<" + t3 + ">"
      }, {
        className: "type",
        begin: "!" + t3
      }, {
        className: "type",
        begin: "!!" + t3
      }, {
        className: "meta",
        begin: "&" + e3.UNDERSCORE_IDENT_RE + "$"
      }, {
        className: "meta",
        begin: "\\*" + e3.UNDERSCORE_IDENT_RE + "$"
      }, {
        className: "bullet",
        begin: "-(?=[ ]|$)",
        relevance: 0
      }, e3.HASH_COMMENT_MODE, {
        beginKeywords: n3,
        keywords: {
          literal: n3
        }
      }, {
        className: "number",
        begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
      }, {
        className: "number",
        begin: e3.C_NUMBER_RE + "\\b",
        relevance: 0
      }, s3, o4, a4], c3 = [...l4];
      return c3.pop(), c3.push(i4), r3.contains = c3, {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: l4
      };
    }
  });
  var $e2 = V2;
  for (const e3 of Object.keys(Be2)) {
    const n3 = e3.replace("grmr_", "").replace("_", "-");
    $e2.registerLanguage(n3, Be2[e3]);
  }

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/katex/katex.mjs
  var SourceLocation = class _SourceLocation {
    // The + prefix indicates that these fields aren't writeable
    // Lexer holding the input string.
    // Start offset, zero-based inclusive.
    // End offset, zero-based exclusive.
    constructor(lexer, start, end) {
      this.lexer = void 0;
      this.start = void 0;
      this.end = void 0;
      this.lexer = lexer;
      this.start = start;
      this.end = end;
    }
    /**
     * Merges two `SourceLocation`s from location providers, given they are
     * provided in order of appearance.
     * - Returns the first one's location if only the first is provided.
     * - Returns a merged range of the first and the last if both are provided
     *   and their lexers match.
     * - Otherwise, returns null.
     */
    static range(first, second) {
      if (!second) {
        return first && first.loc;
      } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
        return null;
      } else {
        return new _SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
      }
    }
  };
  var Token = class _Token {
    // don't expand the token
    // used in \noexpand
    constructor(text2, loc) {
      this.text = void 0;
      this.loc = void 0;
      this.noexpand = void 0;
      this.treatAsRelax = void 0;
      this.text = text2;
      this.loc = loc;
    }
    /**
     * Given a pair of tokens (this and endToken), compute a `Token` encompassing
     * the whole input range enclosed by these two.
     */
    range(endToken, text2) {
      return new _Token(text2, SourceLocation.range(this, endToken));
    }
  };
  var ParseError = class _ParseError {
    // Error start position based on passed-in Token or ParseNode.
    // Length of affected text based on passed-in Token or ParseNode.
    // The underlying error message without any context added.
    constructor(message, token) {
      this.name = void 0;
      this.position = void 0;
      this.length = void 0;
      this.rawMessage = void 0;
      var error = "KaTeX parse error: " + message;
      var start;
      var end;
      var loc = token && token.loc;
      if (loc && loc.start <= loc.end) {
        var input = loc.lexer.input;
        start = loc.start;
        end = loc.end;
        if (start === input.length) {
          error += " at end of input: ";
        } else {
          error += " at position " + (start + 1) + ": ";
        }
        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
        var left;
        if (start > 15) {
          left = "\u2026" + input.slice(start - 15, start);
        } else {
          left = input.slice(0, start);
        }
        var right;
        if (end + 15 < input.length) {
          right = input.slice(end, end + 15) + "\u2026";
        } else {
          right = input.slice(end);
        }
        error += left + underlined + right;
      }
      var self2 = new Error(error);
      self2.name = "ParseError";
      self2.__proto__ = _ParseError.prototype;
      self2.position = start;
      if (start != null && end != null) {
        self2.length = end - start;
      }
      self2.rawMessage = message;
      return self2;
    }
  };
  ParseError.prototype.__proto__ = Error.prototype;
  var contains = function contains2(list, elem) {
    return list.indexOf(elem) !== -1;
  };
  var deflt = function deflt2(setting, defaultIfUndefined) {
    return setting === void 0 ? defaultIfUndefined : setting;
  };
  var uppercase = /([A-Z])/g;
  var hyphenate = function hyphenate2(str) {
    return str.replace(uppercase, "-$1").toLowerCase();
  };
  var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    '"': "&quot;",
    "'": "&#x27;"
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escape(text2) {
    return String(text2).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
  }
  var getBaseElem = function getBaseElem2(group) {
    if (group.type === "ordgroup") {
      if (group.body.length === 1) {
        return getBaseElem2(group.body[0]);
      } else {
        return group;
      }
    } else if (group.type === "color") {
      if (group.body.length === 1) {
        return getBaseElem2(group.body[0]);
      } else {
        return group;
      }
    } else if (group.type === "font") {
      return getBaseElem2(group.body);
    } else {
      return group;
    }
  };
  var isCharacterBox = function isCharacterBox2(group) {
    var baseElem = getBaseElem(group);
    return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
  };
  var assert = function assert2(value) {
    if (!value) {
      throw new Error("Expected non-null, but got " + String(value));
    }
    return value;
  };
  var protocolFromUrl = function protocolFromUrl2(url) {
    var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
    if (!protocol) {
      return "_relative";
    }
    if (protocol[2] !== ":") {
      return null;
    }
    if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
      return null;
    }
    return protocol[1].toLowerCase();
  };
  var utils = {
    contains,
    deflt,
    escape,
    hyphenate,
    getBaseElem,
    isCharacterBox,
    protocolFromUrl
  };
  var SETTINGS_SCHEMA = {
    displayMode: {
      type: "boolean",
      description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
      cli: "-d, --display-mode"
    },
    output: {
      type: {
        enum: ["htmlAndMathml", "html", "mathml"]
      },
      description: "Determines the markup language of the output.",
      cli: "-F, --format <type>"
    },
    leqno: {
      type: "boolean",
      description: "Render display math in leqno style (left-justified tags)."
    },
    fleqn: {
      type: "boolean",
      description: "Render display math flush left."
    },
    throwOnError: {
      type: "boolean",
      default: true,
      cli: "-t, --no-throw-on-error",
      cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
    },
    errorColor: {
      type: "string",
      default: "#cc0000",
      cli: "-c, --error-color <color>",
      cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
      cliProcessor: (color) => "#" + color
    },
    macros: {
      type: "object",
      cli: "-m, --macro <def>",
      cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
      cliDefault: [],
      cliProcessor: (def, defs) => {
        defs.push(def);
        return defs;
      }
    },
    minRuleThickness: {
      type: "number",
      description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
      processor: (t3) => Math.max(0, t3),
      cli: "--min-rule-thickness <size>",
      cliProcessor: parseFloat
    },
    colorIsTextColor: {
      type: "boolean",
      description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
      cli: "-b, --color-is-text-color"
    },
    strict: {
      type: [{
        enum: ["warn", "ignore", "error"]
      }, "boolean", "function"],
      description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
      cli: "-S, --strict",
      cliDefault: false
    },
    trust: {
      type: ["boolean", "function"],
      description: "Trust the input, enabling all HTML features such as \\url.",
      cli: "-T, --trust"
    },
    maxSize: {
      type: "number",
      default: Infinity,
      description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
      processor: (s3) => Math.max(0, s3),
      cli: "-s, --max-size <n>",
      cliProcessor: parseInt
    },
    maxExpand: {
      type: "number",
      default: 1e3,
      description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
      processor: (n3) => Math.max(0, n3),
      cli: "-e, --max-expand <n>",
      cliProcessor: (n3) => n3 === "Infinity" ? Infinity : parseInt(n3)
    },
    globalGroup: {
      type: "boolean",
      cli: false
    }
  };
  function getDefaultValue(schema) {
    if (schema.default) {
      return schema.default;
    }
    var type = schema.type;
    var defaultType = Array.isArray(type) ? type[0] : type;
    if (typeof defaultType !== "string") {
      return defaultType.enum[0];
    }
    switch (defaultType) {
      case "boolean":
        return false;
      case "string":
        return "";
      case "number":
        return 0;
      case "object":
        return {};
    }
  }
  var Settings = class {
    constructor(options) {
      this.displayMode = void 0;
      this.output = void 0;
      this.leqno = void 0;
      this.fleqn = void 0;
      this.throwOnError = void 0;
      this.errorColor = void 0;
      this.macros = void 0;
      this.minRuleThickness = void 0;
      this.colorIsTextColor = void 0;
      this.strict = void 0;
      this.trust = void 0;
      this.maxSize = void 0;
      this.maxExpand = void 0;
      this.globalGroup = void 0;
      options = options || {};
      for (var prop in SETTINGS_SCHEMA) {
        if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
          var schema = SETTINGS_SCHEMA[prop];
          this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
        }
      }
    }
    /**
     * Report nonstrict (non-LaTeX-compatible) input.
     * Can safely not be called if `this.strict` is false in JavaScript.
     */
    reportNonstrict(errorCode, errorMsg, token) {
      var strict = this.strict;
      if (typeof strict === "function") {
        strict = strict(errorCode, errorMsg, token);
      }
      if (!strict || strict === "ignore") {
        return;
      } else if (strict === true || strict === "error") {
        throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
      } else if (strict === "warn") {
        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      } else {
        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      }
    }
    /**
     * Check whether to apply strict (LaTeX-adhering) behavior for unusual
     * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
     * instead, "error" translates to a return value of `true`, while "ignore"
     * translates to a return value of `false`.  May still print a warning:
     * "warn" prints a warning and returns `false`.
     * This is for the second category of `errorCode`s listed in the README.
     */
    useStrictBehavior(errorCode, errorMsg, token) {
      var strict = this.strict;
      if (typeof strict === "function") {
        try {
          strict = strict(errorCode, errorMsg, token);
        } catch (error) {
          strict = "error";
        }
      }
      if (!strict || strict === "ignore") {
        return false;
      } else if (strict === true || strict === "error") {
        return true;
      } else if (strict === "warn") {
        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
        return false;
      } else {
        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
        return false;
      }
    }
    /**
     * Check whether to test potentially dangerous input, and return
     * `true` (trusted) or `false` (untrusted).  The sole argument `context`
     * should be an object with `command` field specifying the relevant LaTeX
     * command (as a string starting with `\`), and any other arguments, etc.
     * If `context` has a `url` field, a `protocol` field will automatically
     * get added by this function (changing the specified object).
     */
    isTrusted(context) {
      if (context.url && !context.protocol) {
        var protocol = utils.protocolFromUrl(context.url);
        if (protocol == null) {
          return false;
        }
        context.protocol = protocol;
      }
      var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
      return Boolean(trust);
    }
  };
  var Style = class {
    constructor(id, size, cramped) {
      this.id = void 0;
      this.size = void 0;
      this.cramped = void 0;
      this.id = id;
      this.size = size;
      this.cramped = cramped;
    }
    /**
     * Get the style of a superscript given a base in the current style.
     */
    sup() {
      return styles[sup[this.id]];
    }
    /**
     * Get the style of a subscript given a base in the current style.
     */
    sub() {
      return styles[sub[this.id]];
    }
    /**
     * Get the style of a fraction numerator given the fraction in the current
     * style.
     */
    fracNum() {
      return styles[fracNum[this.id]];
    }
    /**
     * Get the style of a fraction denominator given the fraction in the current
     * style.
     */
    fracDen() {
      return styles[fracDen[this.id]];
    }
    /**
     * Get the cramped version of a style (in particular, cramping a cramped style
     * doesn't change the style).
     */
    cramp() {
      return styles[cramp[this.id]];
    }
    /**
     * Get a text or display version of this style.
     */
    text() {
      return styles[text$1[this.id]];
    }
    /**
     * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
     */
    isTight() {
      return this.size >= 2;
    }
  };
  var D3 = 0;
  var Dc = 1;
  var T3 = 2;
  var Tc = 3;
  var S3 = 4;
  var Sc = 5;
  var SS = 6;
  var SSc = 7;
  var styles = [new Style(D3, 0, false), new Style(Dc, 0, true), new Style(T3, 1, false), new Style(Tc, 1, true), new Style(S3, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
  var sup = [S3, Sc, S3, Sc, SS, SSc, SS, SSc];
  var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
  var fracNum = [T3, Tc, S3, Sc, SS, SSc, SS, SSc];
  var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
  var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
  var text$1 = [D3, Dc, T3, Tc, T3, Tc, T3, Tc];
  var Style$1 = {
    DISPLAY: styles[D3],
    TEXT: styles[T3],
    SCRIPT: styles[S3],
    SCRIPTSCRIPT: styles[SS]
  };
  var scriptData = [{
    // Latin characters beyond the Latin-1 characters we have metrics for.
    // Needed for Czech, Hungarian and Turkish text, for example.
    name: "latin",
    blocks: [
      [256, 591],
      // Latin Extended-A and Latin Extended-B
      [768, 879]
      // Combining Diacritical marks
    ]
  }, {
    // The Cyrillic script used by Russian and related languages.
    // A Cyrillic subset used to be supported as explicitly defined
    // symbols in symbols.js
    name: "cyrillic",
    blocks: [[1024, 1279]]
  }, {
    // Armenian
    name: "armenian",
    blocks: [[1328, 1423]]
  }, {
    // The Brahmic scripts of South and Southeast Asia
    // Devanagari (0900097F)
    // Bengali (098009FF)
    // Gurmukhi (0A000A7F)
    // Gujarati (0A800AFF)
    // Oriya (0B000B7F)
    // Tamil (0B800BFF)
    // Telugu (0C000C7F)
    // Kannada (0C800CFF)
    // Malayalam (0D000D7F)
    // Sinhala (0D800DFF)
    // Thai (0E000E7F)
    // Lao (0E800EFF)
    // Tibetan (0F000FFF)
    // Myanmar (1000109F)
    name: "brahmic",
    blocks: [[2304, 4255]]
  }, {
    name: "georgian",
    blocks: [[4256, 4351]]
  }, {
    // Chinese and Japanese.
    // The "k" in cjk is for Korean, but we've separated Korean out
    name: "cjk",
    blocks: [
      [12288, 12543],
      // CJK symbols and punctuation, Hiragana, Katakana
      [19968, 40879],
      // CJK ideograms
      [65280, 65376]
      // Fullwidth punctuation
      // TODO: add halfwidth Katakana and Romanji glyphs
    ]
  }, {
    // Korean
    name: "hangul",
    blocks: [[44032, 55215]]
  }];
  function scriptFromCodepoint(codepoint) {
    for (var i4 = 0; i4 < scriptData.length; i4++) {
      var script = scriptData[i4];
      for (var _i = 0; _i < script.blocks.length; _i++) {
        var block = script.blocks[_i];
        if (codepoint >= block[0] && codepoint <= block[1]) {
          return script.name;
        }
      }
    }
    return null;
  }
  var allBlocks = [];
  scriptData.forEach((s3) => s3.blocks.forEach((b3) => allBlocks.push(...b3)));
  function supportedCodepoint(codepoint) {
    for (var i4 = 0; i4 < allBlocks.length; i4 += 2) {
      if (codepoint >= allBlocks[i4] && codepoint <= allBlocks[i4 + 1]) {
        return true;
      }
    }
    return false;
  }
  var hLinePad = 80;
  var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
    return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
  };
  var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
    return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
  };
  var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
    return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
  };
  var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
    return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
  };
  var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
    return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
  };
  var phasePath = function phasePath2(y3) {
    var x3 = y3 / 2;
    return "M400000 " + y3 + " H0 L" + x3 + " 0 l65 45 L145 " + (y3 - 80) + " H400000z";
  };
  var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
    var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
    return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
  };
  var sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
    extraVinculum = 1e3 * extraVinculum;
    var path2 = "";
    switch (size) {
      case "sqrtMain":
        path2 = sqrtMain(extraVinculum, hLinePad);
        break;
      case "sqrtSize1":
        path2 = sqrtSize1(extraVinculum, hLinePad);
        break;
      case "sqrtSize2":
        path2 = sqrtSize2(extraVinculum, hLinePad);
        break;
      case "sqrtSize3":
        path2 = sqrtSize3(extraVinculum, hLinePad);
        break;
      case "sqrtSize4":
        path2 = sqrtSize4(extraVinculum, hLinePad);
        break;
      case "sqrtTall":
        path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
    }
    return path2;
  };
  var innerPath = function innerPath2(name, height) {
    switch (name) {
      case "\u239C":
        return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
      case "\u2223":
        return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
      case "\u2225":
        return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
      case "\u239F":
        return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
      case "\u23A2":
        return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
      case "\u23A5":
        return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
      case "\u23AA":
        return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
      case "\u23D0":
        return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
      case "\u2016":
        return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
      default:
        return "";
    }
  };
  var path = {
    // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
    doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
    // doublerightarrow is from glyph U+21D2 in font KaTeX Main
    doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
    // leftarrow is from glyph U+2190 in font KaTeX Main
    leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
    // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
    leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
    leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
    // overgroup is from the MnSymbol package (public domain)
    leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
    leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
    // Harpoons are from glyph U+21BD in font KaTeX Main
    leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
    leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
    leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
    leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
    // hook is from glyph U+21A9 in font KaTeX Main
    lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
    leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
    leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
    // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
    leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
    longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
    midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
    midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
    oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
    oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
    oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
    oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
    rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
    rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
    rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
    rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
    rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
    rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
    rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
    rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
    rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
    righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
    rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
    rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
    // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
    twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
    twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
    // tilde1 is a modified version of a glyph from the MnSymbol package
    tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
    // ditto tilde2, tilde3, & tilde4
    tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
    tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
    tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
    // vec is from glyph U+20D7 in font KaTeX Main
    vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
    // widehat1 is a modified version of a glyph from the MnSymbol package
    widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
    // ditto widehat2, widehat3, & widehat4
    widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    // widecheck paths are all inverted versions of widehat
    widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
    widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    // The next ten paths support reaction arrows from the mhchem package.
    // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
    // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
    baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
    // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
    rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
    // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
    // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
    baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
    rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
    shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
    shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
  };
  var tallDelim = function tallDelim2(label, midHeight) {
    switch (label) {
      case "lbrack":
        return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
      case "rbrack":
        return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
      case "vert":
        return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
      case "doublevert":
        return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
      case "lfloor":
        return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
      case "rfloor":
        return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
      case "lceil":
        return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
      case "rceil":
        return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
      case "lparen":
        return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
      case "rparen":
        return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
      default:
        throw new Error("Unknown stretchy delimiter.");
    }
  };
  var DocumentFragment2 = class {
    // HtmlDomNode
    // Never used; needed for satisfying interface.
    constructor(children) {
      this.children = void 0;
      this.classes = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.maxFontSize = void 0;
      this.style = void 0;
      this.children = children;
      this.classes = [];
      this.height = 0;
      this.depth = 0;
      this.maxFontSize = 0;
      this.style = {};
    }
    hasClass(className) {
      return utils.contains(this.classes, className);
    }
    /** Convert the fragment into a node. */
    toNode() {
      var frag = document.createDocumentFragment();
      for (var i4 = 0; i4 < this.children.length; i4++) {
        frag.appendChild(this.children[i4].toNode());
      }
      return frag;
    }
    /** Convert the fragment into HTML markup. */
    toMarkup() {
      var markup = "";
      for (var i4 = 0; i4 < this.children.length; i4++) {
        markup += this.children[i4].toMarkup();
      }
      return markup;
    }
    /**
     * Converts the math node into a string, similar to innerText. Applies to
     * MathDomNode's only.
     */
    toText() {
      var toText = (child) => child.toText();
      return this.children.map(toText).join("");
    }
  };
  var fontMetricsData = {
    "AMS-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "65": [0, 0.68889, 0, 0, 0.72222],
      "66": [0, 0.68889, 0, 0, 0.66667],
      "67": [0, 0.68889, 0, 0, 0.72222],
      "68": [0, 0.68889, 0, 0, 0.72222],
      "69": [0, 0.68889, 0, 0, 0.66667],
      "70": [0, 0.68889, 0, 0, 0.61111],
      "71": [0, 0.68889, 0, 0, 0.77778],
      "72": [0, 0.68889, 0, 0, 0.77778],
      "73": [0, 0.68889, 0, 0, 0.38889],
      "74": [0.16667, 0.68889, 0, 0, 0.5],
      "75": [0, 0.68889, 0, 0, 0.77778],
      "76": [0, 0.68889, 0, 0, 0.66667],
      "77": [0, 0.68889, 0, 0, 0.94445],
      "78": [0, 0.68889, 0, 0, 0.72222],
      "79": [0.16667, 0.68889, 0, 0, 0.77778],
      "80": [0, 0.68889, 0, 0, 0.61111],
      "81": [0.16667, 0.68889, 0, 0, 0.77778],
      "82": [0, 0.68889, 0, 0, 0.72222],
      "83": [0, 0.68889, 0, 0, 0.55556],
      "84": [0, 0.68889, 0, 0, 0.66667],
      "85": [0, 0.68889, 0, 0, 0.72222],
      "86": [0, 0.68889, 0, 0, 0.72222],
      "87": [0, 0.68889, 0, 0, 1],
      "88": [0, 0.68889, 0, 0, 0.72222],
      "89": [0, 0.68889, 0, 0, 0.72222],
      "90": [0, 0.68889, 0, 0, 0.66667],
      "107": [0, 0.68889, 0, 0, 0.55556],
      "160": [0, 0, 0, 0, 0.25],
      "165": [0, 0.675, 0.025, 0, 0.75],
      "174": [0.15559, 0.69224, 0, 0, 0.94666],
      "240": [0, 0.68889, 0, 0, 0.55556],
      "295": [0, 0.68889, 0, 0, 0.54028],
      "710": [0, 0.825, 0, 0, 2.33334],
      "732": [0, 0.9, 0, 0, 2.33334],
      "770": [0, 0.825, 0, 0, 2.33334],
      "771": [0, 0.9, 0, 0, 2.33334],
      "989": [0.08167, 0.58167, 0, 0, 0.77778],
      "1008": [0, 0.43056, 0.04028, 0, 0.66667],
      "8245": [0, 0.54986, 0, 0, 0.275],
      "8463": [0, 0.68889, 0, 0, 0.54028],
      "8487": [0, 0.68889, 0, 0, 0.72222],
      "8498": [0, 0.68889, 0, 0, 0.55556],
      "8502": [0, 0.68889, 0, 0, 0.66667],
      "8503": [0, 0.68889, 0, 0, 0.44445],
      "8504": [0, 0.68889, 0, 0, 0.66667],
      "8513": [0, 0.68889, 0, 0, 0.63889],
      "8592": [-0.03598, 0.46402, 0, 0, 0.5],
      "8594": [-0.03598, 0.46402, 0, 0, 0.5],
      "8602": [-0.13313, 0.36687, 0, 0, 1],
      "8603": [-0.13313, 0.36687, 0, 0, 1],
      "8606": [0.01354, 0.52239, 0, 0, 1],
      "8608": [0.01354, 0.52239, 0, 0, 1],
      "8610": [0.01354, 0.52239, 0, 0, 1.11111],
      "8611": [0.01354, 0.52239, 0, 0, 1.11111],
      "8619": [0, 0.54986, 0, 0, 1],
      "8620": [0, 0.54986, 0, 0, 1],
      "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
      "8622": [-0.13313, 0.36687, 0, 0, 1],
      "8624": [0, 0.69224, 0, 0, 0.5],
      "8625": [0, 0.69224, 0, 0, 0.5],
      "8630": [0, 0.43056, 0, 0, 1],
      "8631": [0, 0.43056, 0, 0, 1],
      "8634": [0.08198, 0.58198, 0, 0, 0.77778],
      "8635": [0.08198, 0.58198, 0, 0, 0.77778],
      "8638": [0.19444, 0.69224, 0, 0, 0.41667],
      "8639": [0.19444, 0.69224, 0, 0, 0.41667],
      "8642": [0.19444, 0.69224, 0, 0, 0.41667],
      "8643": [0.19444, 0.69224, 0, 0, 0.41667],
      "8644": [0.1808, 0.675, 0, 0, 1],
      "8646": [0.1808, 0.675, 0, 0, 1],
      "8647": [0.1808, 0.675, 0, 0, 1],
      "8648": [0.19444, 0.69224, 0, 0, 0.83334],
      "8649": [0.1808, 0.675, 0, 0, 1],
      "8650": [0.19444, 0.69224, 0, 0, 0.83334],
      "8651": [0.01354, 0.52239, 0, 0, 1],
      "8652": [0.01354, 0.52239, 0, 0, 1],
      "8653": [-0.13313, 0.36687, 0, 0, 1],
      "8654": [-0.13313, 0.36687, 0, 0, 1],
      "8655": [-0.13313, 0.36687, 0, 0, 1],
      "8666": [0.13667, 0.63667, 0, 0, 1],
      "8667": [0.13667, 0.63667, 0, 0, 1],
      "8669": [-0.13313, 0.37788, 0, 0, 1],
      "8672": [-0.064, 0.437, 0, 0, 1.334],
      "8674": [-0.064, 0.437, 0, 0, 1.334],
      "8705": [0, 0.825, 0, 0, 0.5],
      "8708": [0, 0.68889, 0, 0, 0.55556],
      "8709": [0.08167, 0.58167, 0, 0, 0.77778],
      "8717": [0, 0.43056, 0, 0, 0.42917],
      "8722": [-0.03598, 0.46402, 0, 0, 0.5],
      "8724": [0.08198, 0.69224, 0, 0, 0.77778],
      "8726": [0.08167, 0.58167, 0, 0, 0.77778],
      "8733": [0, 0.69224, 0, 0, 0.77778],
      "8736": [0, 0.69224, 0, 0, 0.72222],
      "8737": [0, 0.69224, 0, 0, 0.72222],
      "8738": [0.03517, 0.52239, 0, 0, 0.72222],
      "8739": [0.08167, 0.58167, 0, 0, 0.22222],
      "8740": [0.25142, 0.74111, 0, 0, 0.27778],
      "8741": [0.08167, 0.58167, 0, 0, 0.38889],
      "8742": [0.25142, 0.74111, 0, 0, 0.5],
      "8756": [0, 0.69224, 0, 0, 0.66667],
      "8757": [0, 0.69224, 0, 0, 0.66667],
      "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
      "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
      "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
      "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
      "8774": [0.30274, 0.79383, 0, 0, 0.77778],
      "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
      "8778": [0.08167, 0.58167, 0, 0, 0.77778],
      "8782": [0.06062, 0.54986, 0, 0, 0.77778],
      "8783": [0.06062, 0.54986, 0, 0, 0.77778],
      "8785": [0.08198, 0.58198, 0, 0, 0.77778],
      "8786": [0.08198, 0.58198, 0, 0, 0.77778],
      "8787": [0.08198, 0.58198, 0, 0, 0.77778],
      "8790": [0, 0.69224, 0, 0, 0.77778],
      "8791": [0.22958, 0.72958, 0, 0, 0.77778],
      "8796": [0.08198, 0.91667, 0, 0, 0.77778],
      "8806": [0.25583, 0.75583, 0, 0, 0.77778],
      "8807": [0.25583, 0.75583, 0, 0, 0.77778],
      "8808": [0.25142, 0.75726, 0, 0, 0.77778],
      "8809": [0.25142, 0.75726, 0, 0, 0.77778],
      "8812": [0.25583, 0.75583, 0, 0, 0.5],
      "8814": [0.20576, 0.70576, 0, 0, 0.77778],
      "8815": [0.20576, 0.70576, 0, 0, 0.77778],
      "8816": [0.30274, 0.79383, 0, 0, 0.77778],
      "8817": [0.30274, 0.79383, 0, 0, 0.77778],
      "8818": [0.22958, 0.72958, 0, 0, 0.77778],
      "8819": [0.22958, 0.72958, 0, 0, 0.77778],
      "8822": [0.1808, 0.675, 0, 0, 0.77778],
      "8823": [0.1808, 0.675, 0, 0, 0.77778],
      "8828": [0.13667, 0.63667, 0, 0, 0.77778],
      "8829": [0.13667, 0.63667, 0, 0, 0.77778],
      "8830": [0.22958, 0.72958, 0, 0, 0.77778],
      "8831": [0.22958, 0.72958, 0, 0, 0.77778],
      "8832": [0.20576, 0.70576, 0, 0, 0.77778],
      "8833": [0.20576, 0.70576, 0, 0, 0.77778],
      "8840": [0.30274, 0.79383, 0, 0, 0.77778],
      "8841": [0.30274, 0.79383, 0, 0, 0.77778],
      "8842": [0.13597, 0.63597, 0, 0, 0.77778],
      "8843": [0.13597, 0.63597, 0, 0, 0.77778],
      "8847": [0.03517, 0.54986, 0, 0, 0.77778],
      "8848": [0.03517, 0.54986, 0, 0, 0.77778],
      "8858": [0.08198, 0.58198, 0, 0, 0.77778],
      "8859": [0.08198, 0.58198, 0, 0, 0.77778],
      "8861": [0.08198, 0.58198, 0, 0, 0.77778],
      "8862": [0, 0.675, 0, 0, 0.77778],
      "8863": [0, 0.675, 0, 0, 0.77778],
      "8864": [0, 0.675, 0, 0, 0.77778],
      "8865": [0, 0.675, 0, 0, 0.77778],
      "8872": [0, 0.69224, 0, 0, 0.61111],
      "8873": [0, 0.69224, 0, 0, 0.72222],
      "8874": [0, 0.69224, 0, 0, 0.88889],
      "8876": [0, 0.68889, 0, 0, 0.61111],
      "8877": [0, 0.68889, 0, 0, 0.61111],
      "8878": [0, 0.68889, 0, 0, 0.72222],
      "8879": [0, 0.68889, 0, 0, 0.72222],
      "8882": [0.03517, 0.54986, 0, 0, 0.77778],
      "8883": [0.03517, 0.54986, 0, 0, 0.77778],
      "8884": [0.13667, 0.63667, 0, 0, 0.77778],
      "8885": [0.13667, 0.63667, 0, 0, 0.77778],
      "8888": [0, 0.54986, 0, 0, 1.11111],
      "8890": [0.19444, 0.43056, 0, 0, 0.55556],
      "8891": [0.19444, 0.69224, 0, 0, 0.61111],
      "8892": [0.19444, 0.69224, 0, 0, 0.61111],
      "8901": [0, 0.54986, 0, 0, 0.27778],
      "8903": [0.08167, 0.58167, 0, 0, 0.77778],
      "8905": [0.08167, 0.58167, 0, 0, 0.77778],
      "8906": [0.08167, 0.58167, 0, 0, 0.77778],
      "8907": [0, 0.69224, 0, 0, 0.77778],
      "8908": [0, 0.69224, 0, 0, 0.77778],
      "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
      "8910": [0, 0.54986, 0, 0, 0.76042],
      "8911": [0, 0.54986, 0, 0, 0.76042],
      "8912": [0.03517, 0.54986, 0, 0, 0.77778],
      "8913": [0.03517, 0.54986, 0, 0, 0.77778],
      "8914": [0, 0.54986, 0, 0, 0.66667],
      "8915": [0, 0.54986, 0, 0, 0.66667],
      "8916": [0, 0.69224, 0, 0, 0.66667],
      "8918": [0.0391, 0.5391, 0, 0, 0.77778],
      "8919": [0.0391, 0.5391, 0, 0, 0.77778],
      "8920": [0.03517, 0.54986, 0, 0, 1.33334],
      "8921": [0.03517, 0.54986, 0, 0, 1.33334],
      "8922": [0.38569, 0.88569, 0, 0, 0.77778],
      "8923": [0.38569, 0.88569, 0, 0, 0.77778],
      "8926": [0.13667, 0.63667, 0, 0, 0.77778],
      "8927": [0.13667, 0.63667, 0, 0, 0.77778],
      "8928": [0.30274, 0.79383, 0, 0, 0.77778],
      "8929": [0.30274, 0.79383, 0, 0, 0.77778],
      "8934": [0.23222, 0.74111, 0, 0, 0.77778],
      "8935": [0.23222, 0.74111, 0, 0, 0.77778],
      "8936": [0.23222, 0.74111, 0, 0, 0.77778],
      "8937": [0.23222, 0.74111, 0, 0, 0.77778],
      "8938": [0.20576, 0.70576, 0, 0, 0.77778],
      "8939": [0.20576, 0.70576, 0, 0, 0.77778],
      "8940": [0.30274, 0.79383, 0, 0, 0.77778],
      "8941": [0.30274, 0.79383, 0, 0, 0.77778],
      "8994": [0.19444, 0.69224, 0, 0, 0.77778],
      "8995": [0.19444, 0.69224, 0, 0, 0.77778],
      "9416": [0.15559, 0.69224, 0, 0, 0.90222],
      "9484": [0, 0.69224, 0, 0, 0.5],
      "9488": [0, 0.69224, 0, 0, 0.5],
      "9492": [0, 0.37788, 0, 0, 0.5],
      "9496": [0, 0.37788, 0, 0, 0.5],
      "9585": [0.19444, 0.68889, 0, 0, 0.88889],
      "9586": [0.19444, 0.74111, 0, 0, 0.88889],
      "9632": [0, 0.675, 0, 0, 0.77778],
      "9633": [0, 0.675, 0, 0, 0.77778],
      "9650": [0, 0.54986, 0, 0, 0.72222],
      "9651": [0, 0.54986, 0, 0, 0.72222],
      "9654": [0.03517, 0.54986, 0, 0, 0.77778],
      "9660": [0, 0.54986, 0, 0, 0.72222],
      "9661": [0, 0.54986, 0, 0, 0.72222],
      "9664": [0.03517, 0.54986, 0, 0, 0.77778],
      "9674": [0.11111, 0.69224, 0, 0, 0.66667],
      "9733": [0.19444, 0.69224, 0, 0, 0.94445],
      "10003": [0, 0.69224, 0, 0, 0.83334],
      "10016": [0, 0.69224, 0, 0, 0.83334],
      "10731": [0.11111, 0.69224, 0, 0, 0.66667],
      "10846": [0.19444, 0.75583, 0, 0, 0.61111],
      "10877": [0.13667, 0.63667, 0, 0, 0.77778],
      "10878": [0.13667, 0.63667, 0, 0, 0.77778],
      "10885": [0.25583, 0.75583, 0, 0, 0.77778],
      "10886": [0.25583, 0.75583, 0, 0, 0.77778],
      "10887": [0.13597, 0.63597, 0, 0, 0.77778],
      "10888": [0.13597, 0.63597, 0, 0, 0.77778],
      "10889": [0.26167, 0.75726, 0, 0, 0.77778],
      "10890": [0.26167, 0.75726, 0, 0, 0.77778],
      "10891": [0.48256, 0.98256, 0, 0, 0.77778],
      "10892": [0.48256, 0.98256, 0, 0, 0.77778],
      "10901": [0.13667, 0.63667, 0, 0, 0.77778],
      "10902": [0.13667, 0.63667, 0, 0, 0.77778],
      "10933": [0.25142, 0.75726, 0, 0, 0.77778],
      "10934": [0.25142, 0.75726, 0, 0, 0.77778],
      "10935": [0.26167, 0.75726, 0, 0, 0.77778],
      "10936": [0.26167, 0.75726, 0, 0, 0.77778],
      "10937": [0.26167, 0.75726, 0, 0, 0.77778],
      "10938": [0.26167, 0.75726, 0, 0, 0.77778],
      "10949": [0.25583, 0.75583, 0, 0, 0.77778],
      "10950": [0.25583, 0.75583, 0, 0, 0.77778],
      "10955": [0.28481, 0.79383, 0, 0, 0.77778],
      "10956": [0.28481, 0.79383, 0, 0, 0.77778],
      "57350": [0.08167, 0.58167, 0, 0, 0.22222],
      "57351": [0.08167, 0.58167, 0, 0, 0.38889],
      "57352": [0.08167, 0.58167, 0, 0, 0.77778],
      "57353": [0, 0.43056, 0.04028, 0, 0.66667],
      "57356": [0.25142, 0.75726, 0, 0, 0.77778],
      "57357": [0.25142, 0.75726, 0, 0, 0.77778],
      "57358": [0.41951, 0.91951, 0, 0, 0.77778],
      "57359": [0.30274, 0.79383, 0, 0, 0.77778],
      "57360": [0.30274, 0.79383, 0, 0, 0.77778],
      "57361": [0.41951, 0.91951, 0, 0, 0.77778],
      "57366": [0.25142, 0.75726, 0, 0, 0.77778],
      "57367": [0.25142, 0.75726, 0, 0, 0.77778],
      "57368": [0.25142, 0.75726, 0, 0, 0.77778],
      "57369": [0.25142, 0.75726, 0, 0, 0.77778],
      "57370": [0.13597, 0.63597, 0, 0, 0.77778],
      "57371": [0.13597, 0.63597, 0, 0, 0.77778]
    },
    "Caligraphic-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "65": [0, 0.68333, 0, 0.19445, 0.79847],
      "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
      "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
      "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
      "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
      "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
      "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
      "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
      "73": [0, 0.68333, 0.07382, 0, 0.54452],
      "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
      "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
      "76": [0, 0.68333, 0, 0.13889, 0.68972],
      "77": [0, 0.68333, 0, 0.13889, 1.2009],
      "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
      "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
      "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
      "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
      "82": [0, 0.68333, 0, 0.08334, 0.8475],
      "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
      "84": [0, 0.68333, 0.25417, 0, 0.54464],
      "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
      "86": [0, 0.68333, 0.08222, 0, 0.61278],
      "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
      "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
      "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
      "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
      "160": [0, 0, 0, 0, 0.25]
    },
    "Fraktur-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69141, 0, 0, 0.29574],
      "34": [0, 0.69141, 0, 0, 0.21471],
      "38": [0, 0.69141, 0, 0, 0.73786],
      "39": [0, 0.69141, 0, 0, 0.21201],
      "40": [0.24982, 0.74947, 0, 0, 0.38865],
      "41": [0.24982, 0.74947, 0, 0, 0.38865],
      "42": [0, 0.62119, 0, 0, 0.27764],
      "43": [0.08319, 0.58283, 0, 0, 0.75623],
      "44": [0, 0.10803, 0, 0, 0.27764],
      "45": [0.08319, 0.58283, 0, 0, 0.75623],
      "46": [0, 0.10803, 0, 0, 0.27764],
      "47": [0.24982, 0.74947, 0, 0, 0.50181],
      "48": [0, 0.47534, 0, 0, 0.50181],
      "49": [0, 0.47534, 0, 0, 0.50181],
      "50": [0, 0.47534, 0, 0, 0.50181],
      "51": [0.18906, 0.47534, 0, 0, 0.50181],
      "52": [0.18906, 0.47534, 0, 0, 0.50181],
      "53": [0.18906, 0.47534, 0, 0, 0.50181],
      "54": [0, 0.69141, 0, 0, 0.50181],
      "55": [0.18906, 0.47534, 0, 0, 0.50181],
      "56": [0, 0.69141, 0, 0, 0.50181],
      "57": [0.18906, 0.47534, 0, 0, 0.50181],
      "58": [0, 0.47534, 0, 0, 0.21606],
      "59": [0.12604, 0.47534, 0, 0, 0.21606],
      "61": [-0.13099, 0.36866, 0, 0, 0.75623],
      "63": [0, 0.69141, 0, 0, 0.36245],
      "65": [0, 0.69141, 0, 0, 0.7176],
      "66": [0, 0.69141, 0, 0, 0.88397],
      "67": [0, 0.69141, 0, 0, 0.61254],
      "68": [0, 0.69141, 0, 0, 0.83158],
      "69": [0, 0.69141, 0, 0, 0.66278],
      "70": [0.12604, 0.69141, 0, 0, 0.61119],
      "71": [0, 0.69141, 0, 0, 0.78539],
      "72": [0.06302, 0.69141, 0, 0, 0.7203],
      "73": [0, 0.69141, 0, 0, 0.55448],
      "74": [0.12604, 0.69141, 0, 0, 0.55231],
      "75": [0, 0.69141, 0, 0, 0.66845],
      "76": [0, 0.69141, 0, 0, 0.66602],
      "77": [0, 0.69141, 0, 0, 1.04953],
      "78": [0, 0.69141, 0, 0, 0.83212],
      "79": [0, 0.69141, 0, 0, 0.82699],
      "80": [0.18906, 0.69141, 0, 0, 0.82753],
      "81": [0.03781, 0.69141, 0, 0, 0.82699],
      "82": [0, 0.69141, 0, 0, 0.82807],
      "83": [0, 0.69141, 0, 0, 0.82861],
      "84": [0, 0.69141, 0, 0, 0.66899],
      "85": [0, 0.69141, 0, 0, 0.64576],
      "86": [0, 0.69141, 0, 0, 0.83131],
      "87": [0, 0.69141, 0, 0, 1.04602],
      "88": [0, 0.69141, 0, 0, 0.71922],
      "89": [0.18906, 0.69141, 0, 0, 0.83293],
      "90": [0.12604, 0.69141, 0, 0, 0.60201],
      "91": [0.24982, 0.74947, 0, 0, 0.27764],
      "93": [0.24982, 0.74947, 0, 0, 0.27764],
      "94": [0, 0.69141, 0, 0, 0.49965],
      "97": [0, 0.47534, 0, 0, 0.50046],
      "98": [0, 0.69141, 0, 0, 0.51315],
      "99": [0, 0.47534, 0, 0, 0.38946],
      "100": [0, 0.62119, 0, 0, 0.49857],
      "101": [0, 0.47534, 0, 0, 0.40053],
      "102": [0.18906, 0.69141, 0, 0, 0.32626],
      "103": [0.18906, 0.47534, 0, 0, 0.5037],
      "104": [0.18906, 0.69141, 0, 0, 0.52126],
      "105": [0, 0.69141, 0, 0, 0.27899],
      "106": [0, 0.69141, 0, 0, 0.28088],
      "107": [0, 0.69141, 0, 0, 0.38946],
      "108": [0, 0.69141, 0, 0, 0.27953],
      "109": [0, 0.47534, 0, 0, 0.76676],
      "110": [0, 0.47534, 0, 0, 0.52666],
      "111": [0, 0.47534, 0, 0, 0.48885],
      "112": [0.18906, 0.52396, 0, 0, 0.50046],
      "113": [0.18906, 0.47534, 0, 0, 0.48912],
      "114": [0, 0.47534, 0, 0, 0.38919],
      "115": [0, 0.47534, 0, 0, 0.44266],
      "116": [0, 0.62119, 0, 0, 0.33301],
      "117": [0, 0.47534, 0, 0, 0.5172],
      "118": [0, 0.52396, 0, 0, 0.5118],
      "119": [0, 0.52396, 0, 0, 0.77351],
      "120": [0.18906, 0.47534, 0, 0, 0.38865],
      "121": [0.18906, 0.47534, 0, 0, 0.49884],
      "122": [0.18906, 0.47534, 0, 0, 0.39054],
      "160": [0, 0, 0, 0, 0.25],
      "8216": [0, 0.69141, 0, 0, 0.21471],
      "8217": [0, 0.69141, 0, 0, 0.21471],
      "58112": [0, 0.62119, 0, 0, 0.49749],
      "58113": [0, 0.62119, 0, 0, 0.4983],
      "58114": [0.18906, 0.69141, 0, 0, 0.33328],
      "58115": [0.18906, 0.69141, 0, 0, 0.32923],
      "58116": [0.18906, 0.47534, 0, 0, 0.50343],
      "58117": [0, 0.69141, 0, 0, 0.33301],
      "58118": [0, 0.62119, 0, 0, 0.33409],
      "58119": [0, 0.47534, 0, 0, 0.50073]
    },
    "Main-Bold": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0, 0, 0.35],
      "34": [0, 0.69444, 0, 0, 0.60278],
      "35": [0.19444, 0.69444, 0, 0, 0.95833],
      "36": [0.05556, 0.75, 0, 0, 0.575],
      "37": [0.05556, 0.75, 0, 0, 0.95833],
      "38": [0, 0.69444, 0, 0, 0.89444],
      "39": [0, 0.69444, 0, 0, 0.31944],
      "40": [0.25, 0.75, 0, 0, 0.44722],
      "41": [0.25, 0.75, 0, 0, 0.44722],
      "42": [0, 0.75, 0, 0, 0.575],
      "43": [0.13333, 0.63333, 0, 0, 0.89444],
      "44": [0.19444, 0.15556, 0, 0, 0.31944],
      "45": [0, 0.44444, 0, 0, 0.38333],
      "46": [0, 0.15556, 0, 0, 0.31944],
      "47": [0.25, 0.75, 0, 0, 0.575],
      "48": [0, 0.64444, 0, 0, 0.575],
      "49": [0, 0.64444, 0, 0, 0.575],
      "50": [0, 0.64444, 0, 0, 0.575],
      "51": [0, 0.64444, 0, 0, 0.575],
      "52": [0, 0.64444, 0, 0, 0.575],
      "53": [0, 0.64444, 0, 0, 0.575],
      "54": [0, 0.64444, 0, 0, 0.575],
      "55": [0, 0.64444, 0, 0, 0.575],
      "56": [0, 0.64444, 0, 0, 0.575],
      "57": [0, 0.64444, 0, 0, 0.575],
      "58": [0, 0.44444, 0, 0, 0.31944],
      "59": [0.19444, 0.44444, 0, 0, 0.31944],
      "60": [0.08556, 0.58556, 0, 0, 0.89444],
      "61": [-0.10889, 0.39111, 0, 0, 0.89444],
      "62": [0.08556, 0.58556, 0, 0, 0.89444],
      "63": [0, 0.69444, 0, 0, 0.54305],
      "64": [0, 0.69444, 0, 0, 0.89444],
      "65": [0, 0.68611, 0, 0, 0.86944],
      "66": [0, 0.68611, 0, 0, 0.81805],
      "67": [0, 0.68611, 0, 0, 0.83055],
      "68": [0, 0.68611, 0, 0, 0.88194],
      "69": [0, 0.68611, 0, 0, 0.75555],
      "70": [0, 0.68611, 0, 0, 0.72361],
      "71": [0, 0.68611, 0, 0, 0.90416],
      "72": [0, 0.68611, 0, 0, 0.9],
      "73": [0, 0.68611, 0, 0, 0.43611],
      "74": [0, 0.68611, 0, 0, 0.59444],
      "75": [0, 0.68611, 0, 0, 0.90138],
      "76": [0, 0.68611, 0, 0, 0.69166],
      "77": [0, 0.68611, 0, 0, 1.09166],
      "78": [0, 0.68611, 0, 0, 0.9],
      "79": [0, 0.68611, 0, 0, 0.86388],
      "80": [0, 0.68611, 0, 0, 0.78611],
      "81": [0.19444, 0.68611, 0, 0, 0.86388],
      "82": [0, 0.68611, 0, 0, 0.8625],
      "83": [0, 0.68611, 0, 0, 0.63889],
      "84": [0, 0.68611, 0, 0, 0.8],
      "85": [0, 0.68611, 0, 0, 0.88472],
      "86": [0, 0.68611, 0.01597, 0, 0.86944],
      "87": [0, 0.68611, 0.01597, 0, 1.18888],
      "88": [0, 0.68611, 0, 0, 0.86944],
      "89": [0, 0.68611, 0.02875, 0, 0.86944],
      "90": [0, 0.68611, 0, 0, 0.70277],
      "91": [0.25, 0.75, 0, 0, 0.31944],
      "92": [0.25, 0.75, 0, 0, 0.575],
      "93": [0.25, 0.75, 0, 0, 0.31944],
      "94": [0, 0.69444, 0, 0, 0.575],
      "95": [0.31, 0.13444, 0.03194, 0, 0.575],
      "97": [0, 0.44444, 0, 0, 0.55902],
      "98": [0, 0.69444, 0, 0, 0.63889],
      "99": [0, 0.44444, 0, 0, 0.51111],
      "100": [0, 0.69444, 0, 0, 0.63889],
      "101": [0, 0.44444, 0, 0, 0.52708],
      "102": [0, 0.69444, 0.10903, 0, 0.35139],
      "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
      "104": [0, 0.69444, 0, 0, 0.63889],
      "105": [0, 0.69444, 0, 0, 0.31944],
      "106": [0.19444, 0.69444, 0, 0, 0.35139],
      "107": [0, 0.69444, 0, 0, 0.60694],
      "108": [0, 0.69444, 0, 0, 0.31944],
      "109": [0, 0.44444, 0, 0, 0.95833],
      "110": [0, 0.44444, 0, 0, 0.63889],
      "111": [0, 0.44444, 0, 0, 0.575],
      "112": [0.19444, 0.44444, 0, 0, 0.63889],
      "113": [0.19444, 0.44444, 0, 0, 0.60694],
      "114": [0, 0.44444, 0, 0, 0.47361],
      "115": [0, 0.44444, 0, 0, 0.45361],
      "116": [0, 0.63492, 0, 0, 0.44722],
      "117": [0, 0.44444, 0, 0, 0.63889],
      "118": [0, 0.44444, 0.01597, 0, 0.60694],
      "119": [0, 0.44444, 0.01597, 0, 0.83055],
      "120": [0, 0.44444, 0, 0, 0.60694],
      "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
      "122": [0, 0.44444, 0, 0, 0.51111],
      "123": [0.25, 0.75, 0, 0, 0.575],
      "124": [0.25, 0.75, 0, 0, 0.31944],
      "125": [0.25, 0.75, 0, 0, 0.575],
      "126": [0.35, 0.34444, 0, 0, 0.575],
      "160": [0, 0, 0, 0, 0.25],
      "163": [0, 0.69444, 0, 0, 0.86853],
      "168": [0, 0.69444, 0, 0, 0.575],
      "172": [0, 0.44444, 0, 0, 0.76666],
      "176": [0, 0.69444, 0, 0, 0.86944],
      "177": [0.13333, 0.63333, 0, 0, 0.89444],
      "184": [0.17014, 0, 0, 0, 0.51111],
      "198": [0, 0.68611, 0, 0, 1.04166],
      "215": [0.13333, 0.63333, 0, 0, 0.89444],
      "216": [0.04861, 0.73472, 0, 0, 0.89444],
      "223": [0, 0.69444, 0, 0, 0.59722],
      "230": [0, 0.44444, 0, 0, 0.83055],
      "247": [0.13333, 0.63333, 0, 0, 0.89444],
      "248": [0.09722, 0.54167, 0, 0, 0.575],
      "305": [0, 0.44444, 0, 0, 0.31944],
      "338": [0, 0.68611, 0, 0, 1.16944],
      "339": [0, 0.44444, 0, 0, 0.89444],
      "567": [0.19444, 0.44444, 0, 0, 0.35139],
      "710": [0, 0.69444, 0, 0, 0.575],
      "711": [0, 0.63194, 0, 0, 0.575],
      "713": [0, 0.59611, 0, 0, 0.575],
      "714": [0, 0.69444, 0, 0, 0.575],
      "715": [0, 0.69444, 0, 0, 0.575],
      "728": [0, 0.69444, 0, 0, 0.575],
      "729": [0, 0.69444, 0, 0, 0.31944],
      "730": [0, 0.69444, 0, 0, 0.86944],
      "732": [0, 0.69444, 0, 0, 0.575],
      "733": [0, 0.69444, 0, 0, 0.575],
      "915": [0, 0.68611, 0, 0, 0.69166],
      "916": [0, 0.68611, 0, 0, 0.95833],
      "920": [0, 0.68611, 0, 0, 0.89444],
      "923": [0, 0.68611, 0, 0, 0.80555],
      "926": [0, 0.68611, 0, 0, 0.76666],
      "928": [0, 0.68611, 0, 0, 0.9],
      "931": [0, 0.68611, 0, 0, 0.83055],
      "933": [0, 0.68611, 0, 0, 0.89444],
      "934": [0, 0.68611, 0, 0, 0.83055],
      "936": [0, 0.68611, 0, 0, 0.89444],
      "937": [0, 0.68611, 0, 0, 0.83055],
      "8211": [0, 0.44444, 0.03194, 0, 0.575],
      "8212": [0, 0.44444, 0.03194, 0, 1.14999],
      "8216": [0, 0.69444, 0, 0, 0.31944],
      "8217": [0, 0.69444, 0, 0, 0.31944],
      "8220": [0, 0.69444, 0, 0, 0.60278],
      "8221": [0, 0.69444, 0, 0, 0.60278],
      "8224": [0.19444, 0.69444, 0, 0, 0.51111],
      "8225": [0.19444, 0.69444, 0, 0, 0.51111],
      "8242": [0, 0.55556, 0, 0, 0.34444],
      "8407": [0, 0.72444, 0.15486, 0, 0.575],
      "8463": [0, 0.69444, 0, 0, 0.66759],
      "8465": [0, 0.69444, 0, 0, 0.83055],
      "8467": [0, 0.69444, 0, 0, 0.47361],
      "8472": [0.19444, 0.44444, 0, 0, 0.74027],
      "8476": [0, 0.69444, 0, 0, 0.83055],
      "8501": [0, 0.69444, 0, 0, 0.70277],
      "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8593": [0.19444, 0.69444, 0, 0, 0.575],
      "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8595": [0.19444, 0.69444, 0, 0, 0.575],
      "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8597": [0.25, 0.75, 0, 0, 0.575],
      "8598": [0.19444, 0.69444, 0, 0, 1.14999],
      "8599": [0.19444, 0.69444, 0, 0, 1.14999],
      "8600": [0.19444, 0.69444, 0, 0, 1.14999],
      "8601": [0.19444, 0.69444, 0, 0, 1.14999],
      "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8657": [0.19444, 0.69444, 0, 0, 0.70277],
      "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8659": [0.19444, 0.69444, 0, 0, 0.70277],
      "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
      "8661": [0.25, 0.75, 0, 0, 0.70277],
      "8704": [0, 0.69444, 0, 0, 0.63889],
      "8706": [0, 0.69444, 0.06389, 0, 0.62847],
      "8707": [0, 0.69444, 0, 0, 0.63889],
      "8709": [0.05556, 0.75, 0, 0, 0.575],
      "8711": [0, 0.68611, 0, 0, 0.95833],
      "8712": [0.08556, 0.58556, 0, 0, 0.76666],
      "8715": [0.08556, 0.58556, 0, 0, 0.76666],
      "8722": [0.13333, 0.63333, 0, 0, 0.89444],
      "8723": [0.13333, 0.63333, 0, 0, 0.89444],
      "8725": [0.25, 0.75, 0, 0, 0.575],
      "8726": [0.25, 0.75, 0, 0, 0.575],
      "8727": [-0.02778, 0.47222, 0, 0, 0.575],
      "8728": [-0.02639, 0.47361, 0, 0, 0.575],
      "8729": [-0.02639, 0.47361, 0, 0, 0.575],
      "8730": [0.18, 0.82, 0, 0, 0.95833],
      "8733": [0, 0.44444, 0, 0, 0.89444],
      "8734": [0, 0.44444, 0, 0, 1.14999],
      "8736": [0, 0.69224, 0, 0, 0.72222],
      "8739": [0.25, 0.75, 0, 0, 0.31944],
      "8741": [0.25, 0.75, 0, 0, 0.575],
      "8743": [0, 0.55556, 0, 0, 0.76666],
      "8744": [0, 0.55556, 0, 0, 0.76666],
      "8745": [0, 0.55556, 0, 0, 0.76666],
      "8746": [0, 0.55556, 0, 0, 0.76666],
      "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
      "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
      "8768": [0.19444, 0.69444, 0, 0, 0.31944],
      "8771": [222e-5, 0.50222, 0, 0, 0.89444],
      "8773": [0.027, 0.638, 0, 0, 0.894],
      "8776": [0.02444, 0.52444, 0, 0, 0.89444],
      "8781": [222e-5, 0.50222, 0, 0, 0.89444],
      "8801": [222e-5, 0.50222, 0, 0, 0.89444],
      "8804": [0.19667, 0.69667, 0, 0, 0.89444],
      "8805": [0.19667, 0.69667, 0, 0, 0.89444],
      "8810": [0.08556, 0.58556, 0, 0, 1.14999],
      "8811": [0.08556, 0.58556, 0, 0, 1.14999],
      "8826": [0.08556, 0.58556, 0, 0, 0.89444],
      "8827": [0.08556, 0.58556, 0, 0, 0.89444],
      "8834": [0.08556, 0.58556, 0, 0, 0.89444],
      "8835": [0.08556, 0.58556, 0, 0, 0.89444],
      "8838": [0.19667, 0.69667, 0, 0, 0.89444],
      "8839": [0.19667, 0.69667, 0, 0, 0.89444],
      "8846": [0, 0.55556, 0, 0, 0.76666],
      "8849": [0.19667, 0.69667, 0, 0, 0.89444],
      "8850": [0.19667, 0.69667, 0, 0, 0.89444],
      "8851": [0, 0.55556, 0, 0, 0.76666],
      "8852": [0, 0.55556, 0, 0, 0.76666],
      "8853": [0.13333, 0.63333, 0, 0, 0.89444],
      "8854": [0.13333, 0.63333, 0, 0, 0.89444],
      "8855": [0.13333, 0.63333, 0, 0, 0.89444],
      "8856": [0.13333, 0.63333, 0, 0, 0.89444],
      "8857": [0.13333, 0.63333, 0, 0, 0.89444],
      "8866": [0, 0.69444, 0, 0, 0.70277],
      "8867": [0, 0.69444, 0, 0, 0.70277],
      "8868": [0, 0.69444, 0, 0, 0.89444],
      "8869": [0, 0.69444, 0, 0, 0.89444],
      "8900": [-0.02639, 0.47361, 0, 0, 0.575],
      "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
      "8902": [-0.02778, 0.47222, 0, 0, 0.575],
      "8968": [0.25, 0.75, 0, 0, 0.51111],
      "8969": [0.25, 0.75, 0, 0, 0.51111],
      "8970": [0.25, 0.75, 0, 0, 0.51111],
      "8971": [0.25, 0.75, 0, 0, 0.51111],
      "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
      "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
      "9651": [0.19444, 0.69444, 0, 0, 1.02222],
      "9657": [-0.02778, 0.47222, 0, 0, 0.575],
      "9661": [0.19444, 0.69444, 0, 0, 1.02222],
      "9667": [-0.02778, 0.47222, 0, 0, 0.575],
      "9711": [0.19444, 0.69444, 0, 0, 1.14999],
      "9824": [0.12963, 0.69444, 0, 0, 0.89444],
      "9825": [0.12963, 0.69444, 0, 0, 0.89444],
      "9826": [0.12963, 0.69444, 0, 0, 0.89444],
      "9827": [0.12963, 0.69444, 0, 0, 0.89444],
      "9837": [0, 0.75, 0, 0, 0.44722],
      "9838": [0.19444, 0.69444, 0, 0, 0.44722],
      "9839": [0.19444, 0.69444, 0, 0, 0.44722],
      "10216": [0.25, 0.75, 0, 0, 0.44722],
      "10217": [0.25, 0.75, 0, 0, 0.44722],
      "10815": [0, 0.68611, 0, 0, 0.9],
      "10927": [0.19667, 0.69667, 0, 0, 0.89444],
      "10928": [0.19667, 0.69667, 0, 0, 0.89444],
      "57376": [0.19444, 0.69444, 0, 0, 0]
    },
    "Main-BoldItalic": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0.11417, 0, 0.38611],
      "34": [0, 0.69444, 0.07939, 0, 0.62055],
      "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
      "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
      "38": [0, 0.69444, 0.08528, 0, 0.88555],
      "39": [0, 0.69444, 0.12945, 0, 0.35555],
      "40": [0.25, 0.75, 0.15806, 0, 0.47333],
      "41": [0.25, 0.75, 0.03306, 0, 0.47333],
      "42": [0, 0.75, 0.14333, 0, 0.59111],
      "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
      "44": [0.19444, 0.14722, 0, 0, 0.35555],
      "45": [0, 0.44444, 0.02611, 0, 0.41444],
      "46": [0, 0.14722, 0, 0, 0.35555],
      "47": [0.25, 0.75, 0.15806, 0, 0.59111],
      "48": [0, 0.64444, 0.13167, 0, 0.59111],
      "49": [0, 0.64444, 0.13167, 0, 0.59111],
      "50": [0, 0.64444, 0.13167, 0, 0.59111],
      "51": [0, 0.64444, 0.13167, 0, 0.59111],
      "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
      "53": [0, 0.64444, 0.13167, 0, 0.59111],
      "54": [0, 0.64444, 0.13167, 0, 0.59111],
      "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
      "56": [0, 0.64444, 0.13167, 0, 0.59111],
      "57": [0, 0.64444, 0.13167, 0, 0.59111],
      "58": [0, 0.44444, 0.06695, 0, 0.35555],
      "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
      "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
      "63": [0, 0.69444, 0.11472, 0, 0.59111],
      "64": [0, 0.69444, 0.09208, 0, 0.88555],
      "65": [0, 0.68611, 0, 0, 0.86555],
      "66": [0, 0.68611, 0.0992, 0, 0.81666],
      "67": [0, 0.68611, 0.14208, 0, 0.82666],
      "68": [0, 0.68611, 0.09062, 0, 0.87555],
      "69": [0, 0.68611, 0.11431, 0, 0.75666],
      "70": [0, 0.68611, 0.12903, 0, 0.72722],
      "71": [0, 0.68611, 0.07347, 0, 0.89527],
      "72": [0, 0.68611, 0.17208, 0, 0.8961],
      "73": [0, 0.68611, 0.15681, 0, 0.47166],
      "74": [0, 0.68611, 0.145, 0, 0.61055],
      "75": [0, 0.68611, 0.14208, 0, 0.89499],
      "76": [0, 0.68611, 0, 0, 0.69777],
      "77": [0, 0.68611, 0.17208, 0, 1.07277],
      "78": [0, 0.68611, 0.17208, 0, 0.8961],
      "79": [0, 0.68611, 0.09062, 0, 0.85499],
      "80": [0, 0.68611, 0.0992, 0, 0.78721],
      "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
      "82": [0, 0.68611, 0.02559, 0, 0.85944],
      "83": [0, 0.68611, 0.11264, 0, 0.64999],
      "84": [0, 0.68611, 0.12903, 0, 0.7961],
      "85": [0, 0.68611, 0.17208, 0, 0.88083],
      "86": [0, 0.68611, 0.18625, 0, 0.86555],
      "87": [0, 0.68611, 0.18625, 0, 1.15999],
      "88": [0, 0.68611, 0.15681, 0, 0.86555],
      "89": [0, 0.68611, 0.19803, 0, 0.86555],
      "90": [0, 0.68611, 0.14208, 0, 0.70888],
      "91": [0.25, 0.75, 0.1875, 0, 0.35611],
      "93": [0.25, 0.75, 0.09972, 0, 0.35611],
      "94": [0, 0.69444, 0.06709, 0, 0.59111],
      "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
      "97": [0, 0.44444, 0.09426, 0, 0.59111],
      "98": [0, 0.69444, 0.07861, 0, 0.53222],
      "99": [0, 0.44444, 0.05222, 0, 0.53222],
      "100": [0, 0.69444, 0.10861, 0, 0.59111],
      "101": [0, 0.44444, 0.085, 0, 0.53222],
      "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
      "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
      "104": [0, 0.69444, 0.09426, 0, 0.59111],
      "105": [0, 0.69326, 0.11387, 0, 0.35555],
      "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
      "107": [0, 0.69444, 0.11111, 0, 0.53222],
      "108": [0, 0.69444, 0.10861, 0, 0.29666],
      "109": [0, 0.44444, 0.09426, 0, 0.94444],
      "110": [0, 0.44444, 0.09426, 0, 0.64999],
      "111": [0, 0.44444, 0.07861, 0, 0.59111],
      "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
      "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
      "114": [0, 0.44444, 0.11111, 0, 0.50167],
      "115": [0, 0.44444, 0.08167, 0, 0.48694],
      "116": [0, 0.63492, 0.09639, 0, 0.385],
      "117": [0, 0.44444, 0.09426, 0, 0.62055],
      "118": [0, 0.44444, 0.11111, 0, 0.53222],
      "119": [0, 0.44444, 0.11111, 0, 0.76777],
      "120": [0, 0.44444, 0.12583, 0, 0.56055],
      "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
      "122": [0, 0.44444, 0.13889, 0, 0.49055],
      "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
      "160": [0, 0, 0, 0, 0.25],
      "168": [0, 0.69444, 0.11473, 0, 0.59111],
      "176": [0, 0.69444, 0, 0, 0.94888],
      "184": [0.17014, 0, 0, 0, 0.53222],
      "198": [0, 0.68611, 0.11431, 0, 1.02277],
      "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
      "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
      "230": [0, 0.44444, 0.085, 0, 0.82666],
      "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
      "305": [0, 0.44444, 0.09426, 0, 0.35555],
      "338": [0, 0.68611, 0.11431, 0, 1.14054],
      "339": [0, 0.44444, 0.085, 0, 0.82666],
      "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
      "710": [0, 0.69444, 0.06709, 0, 0.59111],
      "711": [0, 0.63194, 0.08271, 0, 0.59111],
      "713": [0, 0.59444, 0.10444, 0, 0.59111],
      "714": [0, 0.69444, 0.08528, 0, 0.59111],
      "715": [0, 0.69444, 0, 0, 0.59111],
      "728": [0, 0.69444, 0.10333, 0, 0.59111],
      "729": [0, 0.69444, 0.12945, 0, 0.35555],
      "730": [0, 0.69444, 0, 0, 0.94888],
      "732": [0, 0.69444, 0.11472, 0, 0.59111],
      "733": [0, 0.69444, 0.11472, 0, 0.59111],
      "915": [0, 0.68611, 0.12903, 0, 0.69777],
      "916": [0, 0.68611, 0, 0, 0.94444],
      "920": [0, 0.68611, 0.09062, 0, 0.88555],
      "923": [0, 0.68611, 0, 0, 0.80666],
      "926": [0, 0.68611, 0.15092, 0, 0.76777],
      "928": [0, 0.68611, 0.17208, 0, 0.8961],
      "931": [0, 0.68611, 0.11431, 0, 0.82666],
      "933": [0, 0.68611, 0.10778, 0, 0.88555],
      "934": [0, 0.68611, 0.05632, 0, 0.82666],
      "936": [0, 0.68611, 0.10778, 0, 0.88555],
      "937": [0, 0.68611, 0.0992, 0, 0.82666],
      "8211": [0, 0.44444, 0.09811, 0, 0.59111],
      "8212": [0, 0.44444, 0.09811, 0, 1.18221],
      "8216": [0, 0.69444, 0.12945, 0, 0.35555],
      "8217": [0, 0.69444, 0.12945, 0, 0.35555],
      "8220": [0, 0.69444, 0.16772, 0, 0.62055],
      "8221": [0, 0.69444, 0.07939, 0, 0.62055]
    },
    "Main-Italic": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0.12417, 0, 0.30667],
      "34": [0, 0.69444, 0.06961, 0, 0.51444],
      "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
      "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
      "38": [0, 0.69444, 0.09694, 0, 0.76666],
      "39": [0, 0.69444, 0.12417, 0, 0.30667],
      "40": [0.25, 0.75, 0.16194, 0, 0.40889],
      "41": [0.25, 0.75, 0.03694, 0, 0.40889],
      "42": [0, 0.75, 0.14917, 0, 0.51111],
      "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
      "44": [0.19444, 0.10556, 0, 0, 0.30667],
      "45": [0, 0.43056, 0.02826, 0, 0.35778],
      "46": [0, 0.10556, 0, 0, 0.30667],
      "47": [0.25, 0.75, 0.16194, 0, 0.51111],
      "48": [0, 0.64444, 0.13556, 0, 0.51111],
      "49": [0, 0.64444, 0.13556, 0, 0.51111],
      "50": [0, 0.64444, 0.13556, 0, 0.51111],
      "51": [0, 0.64444, 0.13556, 0, 0.51111],
      "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
      "53": [0, 0.64444, 0.13556, 0, 0.51111],
      "54": [0, 0.64444, 0.13556, 0, 0.51111],
      "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
      "56": [0, 0.64444, 0.13556, 0, 0.51111],
      "57": [0, 0.64444, 0.13556, 0, 0.51111],
      "58": [0, 0.43056, 0.0582, 0, 0.30667],
      "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
      "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
      "63": [0, 0.69444, 0.1225, 0, 0.51111],
      "64": [0, 0.69444, 0.09597, 0, 0.76666],
      "65": [0, 0.68333, 0, 0, 0.74333],
      "66": [0, 0.68333, 0.10257, 0, 0.70389],
      "67": [0, 0.68333, 0.14528, 0, 0.71555],
      "68": [0, 0.68333, 0.09403, 0, 0.755],
      "69": [0, 0.68333, 0.12028, 0, 0.67833],
      "70": [0, 0.68333, 0.13305, 0, 0.65277],
      "71": [0, 0.68333, 0.08722, 0, 0.77361],
      "72": [0, 0.68333, 0.16389, 0, 0.74333],
      "73": [0, 0.68333, 0.15806, 0, 0.38555],
      "74": [0, 0.68333, 0.14028, 0, 0.525],
      "75": [0, 0.68333, 0.14528, 0, 0.76888],
      "76": [0, 0.68333, 0, 0, 0.62722],
      "77": [0, 0.68333, 0.16389, 0, 0.89666],
      "78": [0, 0.68333, 0.16389, 0, 0.74333],
      "79": [0, 0.68333, 0.09403, 0, 0.76666],
      "80": [0, 0.68333, 0.10257, 0, 0.67833],
      "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
      "82": [0, 0.68333, 0.03868, 0, 0.72944],
      "83": [0, 0.68333, 0.11972, 0, 0.56222],
      "84": [0, 0.68333, 0.13305, 0, 0.71555],
      "85": [0, 0.68333, 0.16389, 0, 0.74333],
      "86": [0, 0.68333, 0.18361, 0, 0.74333],
      "87": [0, 0.68333, 0.18361, 0, 0.99888],
      "88": [0, 0.68333, 0.15806, 0, 0.74333],
      "89": [0, 0.68333, 0.19383, 0, 0.74333],
      "90": [0, 0.68333, 0.14528, 0, 0.61333],
      "91": [0.25, 0.75, 0.1875, 0, 0.30667],
      "93": [0.25, 0.75, 0.10528, 0, 0.30667],
      "94": [0, 0.69444, 0.06646, 0, 0.51111],
      "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
      "97": [0, 0.43056, 0.07671, 0, 0.51111],
      "98": [0, 0.69444, 0.06312, 0, 0.46],
      "99": [0, 0.43056, 0.05653, 0, 0.46],
      "100": [0, 0.69444, 0.10333, 0, 0.51111],
      "101": [0, 0.43056, 0.07514, 0, 0.46],
      "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
      "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
      "104": [0, 0.69444, 0.07671, 0, 0.51111],
      "105": [0, 0.65536, 0.1019, 0, 0.30667],
      "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
      "107": [0, 0.69444, 0.10764, 0, 0.46],
      "108": [0, 0.69444, 0.10333, 0, 0.25555],
      "109": [0, 0.43056, 0.07671, 0, 0.81777],
      "110": [0, 0.43056, 0.07671, 0, 0.56222],
      "111": [0, 0.43056, 0.06312, 0, 0.51111],
      "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
      "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
      "114": [0, 0.43056, 0.10764, 0, 0.42166],
      "115": [0, 0.43056, 0.08208, 0, 0.40889],
      "116": [0, 0.61508, 0.09486, 0, 0.33222],
      "117": [0, 0.43056, 0.07671, 0, 0.53666],
      "118": [0, 0.43056, 0.10764, 0, 0.46],
      "119": [0, 0.43056, 0.10764, 0, 0.66444],
      "120": [0, 0.43056, 0.12042, 0, 0.46389],
      "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
      "122": [0, 0.43056, 0.12292, 0, 0.40889],
      "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
      "160": [0, 0, 0, 0, 0.25],
      "168": [0, 0.66786, 0.10474, 0, 0.51111],
      "176": [0, 0.69444, 0, 0, 0.83129],
      "184": [0.17014, 0, 0, 0, 0.46],
      "198": [0, 0.68333, 0.12028, 0, 0.88277],
      "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
      "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
      "230": [0, 0.43056, 0.07514, 0, 0.71555],
      "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
      "338": [0, 0.68333, 0.12028, 0, 0.98499],
      "339": [0, 0.43056, 0.07514, 0, 0.71555],
      "710": [0, 0.69444, 0.06646, 0, 0.51111],
      "711": [0, 0.62847, 0.08295, 0, 0.51111],
      "713": [0, 0.56167, 0.10333, 0, 0.51111],
      "714": [0, 0.69444, 0.09694, 0, 0.51111],
      "715": [0, 0.69444, 0, 0, 0.51111],
      "728": [0, 0.69444, 0.10806, 0, 0.51111],
      "729": [0, 0.66786, 0.11752, 0, 0.30667],
      "730": [0, 0.69444, 0, 0, 0.83129],
      "732": [0, 0.66786, 0.11585, 0, 0.51111],
      "733": [0, 0.69444, 0.1225, 0, 0.51111],
      "915": [0, 0.68333, 0.13305, 0, 0.62722],
      "916": [0, 0.68333, 0, 0, 0.81777],
      "920": [0, 0.68333, 0.09403, 0, 0.76666],
      "923": [0, 0.68333, 0, 0, 0.69222],
      "926": [0, 0.68333, 0.15294, 0, 0.66444],
      "928": [0, 0.68333, 0.16389, 0, 0.74333],
      "931": [0, 0.68333, 0.12028, 0, 0.71555],
      "933": [0, 0.68333, 0.11111, 0, 0.76666],
      "934": [0, 0.68333, 0.05986, 0, 0.71555],
      "936": [0, 0.68333, 0.11111, 0, 0.76666],
      "937": [0, 0.68333, 0.10257, 0, 0.71555],
      "8211": [0, 0.43056, 0.09208, 0, 0.51111],
      "8212": [0, 0.43056, 0.09208, 0, 1.02222],
      "8216": [0, 0.69444, 0.12417, 0, 0.30667],
      "8217": [0, 0.69444, 0.12417, 0, 0.30667],
      "8220": [0, 0.69444, 0.1685, 0, 0.51444],
      "8221": [0, 0.69444, 0.06961, 0, 0.51444],
      "8463": [0, 0.68889, 0, 0, 0.54028]
    },
    "Main-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0, 0, 0.27778],
      "34": [0, 0.69444, 0, 0, 0.5],
      "35": [0.19444, 0.69444, 0, 0, 0.83334],
      "36": [0.05556, 0.75, 0, 0, 0.5],
      "37": [0.05556, 0.75, 0, 0, 0.83334],
      "38": [0, 0.69444, 0, 0, 0.77778],
      "39": [0, 0.69444, 0, 0, 0.27778],
      "40": [0.25, 0.75, 0, 0, 0.38889],
      "41": [0.25, 0.75, 0, 0, 0.38889],
      "42": [0, 0.75, 0, 0, 0.5],
      "43": [0.08333, 0.58333, 0, 0, 0.77778],
      "44": [0.19444, 0.10556, 0, 0, 0.27778],
      "45": [0, 0.43056, 0, 0, 0.33333],
      "46": [0, 0.10556, 0, 0, 0.27778],
      "47": [0.25, 0.75, 0, 0, 0.5],
      "48": [0, 0.64444, 0, 0, 0.5],
      "49": [0, 0.64444, 0, 0, 0.5],
      "50": [0, 0.64444, 0, 0, 0.5],
      "51": [0, 0.64444, 0, 0, 0.5],
      "52": [0, 0.64444, 0, 0, 0.5],
      "53": [0, 0.64444, 0, 0, 0.5],
      "54": [0, 0.64444, 0, 0, 0.5],
      "55": [0, 0.64444, 0, 0, 0.5],
      "56": [0, 0.64444, 0, 0, 0.5],
      "57": [0, 0.64444, 0, 0, 0.5],
      "58": [0, 0.43056, 0, 0, 0.27778],
      "59": [0.19444, 0.43056, 0, 0, 0.27778],
      "60": [0.0391, 0.5391, 0, 0, 0.77778],
      "61": [-0.13313, 0.36687, 0, 0, 0.77778],
      "62": [0.0391, 0.5391, 0, 0, 0.77778],
      "63": [0, 0.69444, 0, 0, 0.47222],
      "64": [0, 0.69444, 0, 0, 0.77778],
      "65": [0, 0.68333, 0, 0, 0.75],
      "66": [0, 0.68333, 0, 0, 0.70834],
      "67": [0, 0.68333, 0, 0, 0.72222],
      "68": [0, 0.68333, 0, 0, 0.76389],
      "69": [0, 0.68333, 0, 0, 0.68056],
      "70": [0, 0.68333, 0, 0, 0.65278],
      "71": [0, 0.68333, 0, 0, 0.78472],
      "72": [0, 0.68333, 0, 0, 0.75],
      "73": [0, 0.68333, 0, 0, 0.36111],
      "74": [0, 0.68333, 0, 0, 0.51389],
      "75": [0, 0.68333, 0, 0, 0.77778],
      "76": [0, 0.68333, 0, 0, 0.625],
      "77": [0, 0.68333, 0, 0, 0.91667],
      "78": [0, 0.68333, 0, 0, 0.75],
      "79": [0, 0.68333, 0, 0, 0.77778],
      "80": [0, 0.68333, 0, 0, 0.68056],
      "81": [0.19444, 0.68333, 0, 0, 0.77778],
      "82": [0, 0.68333, 0, 0, 0.73611],
      "83": [0, 0.68333, 0, 0, 0.55556],
      "84": [0, 0.68333, 0, 0, 0.72222],
      "85": [0, 0.68333, 0, 0, 0.75],
      "86": [0, 0.68333, 0.01389, 0, 0.75],
      "87": [0, 0.68333, 0.01389, 0, 1.02778],
      "88": [0, 0.68333, 0, 0, 0.75],
      "89": [0, 0.68333, 0.025, 0, 0.75],
      "90": [0, 0.68333, 0, 0, 0.61111],
      "91": [0.25, 0.75, 0, 0, 0.27778],
      "92": [0.25, 0.75, 0, 0, 0.5],
      "93": [0.25, 0.75, 0, 0, 0.27778],
      "94": [0, 0.69444, 0, 0, 0.5],
      "95": [0.31, 0.12056, 0.02778, 0, 0.5],
      "97": [0, 0.43056, 0, 0, 0.5],
      "98": [0, 0.69444, 0, 0, 0.55556],
      "99": [0, 0.43056, 0, 0, 0.44445],
      "100": [0, 0.69444, 0, 0, 0.55556],
      "101": [0, 0.43056, 0, 0, 0.44445],
      "102": [0, 0.69444, 0.07778, 0, 0.30556],
      "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
      "104": [0, 0.69444, 0, 0, 0.55556],
      "105": [0, 0.66786, 0, 0, 0.27778],
      "106": [0.19444, 0.66786, 0, 0, 0.30556],
      "107": [0, 0.69444, 0, 0, 0.52778],
      "108": [0, 0.69444, 0, 0, 0.27778],
      "109": [0, 0.43056, 0, 0, 0.83334],
      "110": [0, 0.43056, 0, 0, 0.55556],
      "111": [0, 0.43056, 0, 0, 0.5],
      "112": [0.19444, 0.43056, 0, 0, 0.55556],
      "113": [0.19444, 0.43056, 0, 0, 0.52778],
      "114": [0, 0.43056, 0, 0, 0.39167],
      "115": [0, 0.43056, 0, 0, 0.39445],
      "116": [0, 0.61508, 0, 0, 0.38889],
      "117": [0, 0.43056, 0, 0, 0.55556],
      "118": [0, 0.43056, 0.01389, 0, 0.52778],
      "119": [0, 0.43056, 0.01389, 0, 0.72222],
      "120": [0, 0.43056, 0, 0, 0.52778],
      "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
      "122": [0, 0.43056, 0, 0, 0.44445],
      "123": [0.25, 0.75, 0, 0, 0.5],
      "124": [0.25, 0.75, 0, 0, 0.27778],
      "125": [0.25, 0.75, 0, 0, 0.5],
      "126": [0.35, 0.31786, 0, 0, 0.5],
      "160": [0, 0, 0, 0, 0.25],
      "163": [0, 0.69444, 0, 0, 0.76909],
      "167": [0.19444, 0.69444, 0, 0, 0.44445],
      "168": [0, 0.66786, 0, 0, 0.5],
      "172": [0, 0.43056, 0, 0, 0.66667],
      "176": [0, 0.69444, 0, 0, 0.75],
      "177": [0.08333, 0.58333, 0, 0, 0.77778],
      "182": [0.19444, 0.69444, 0, 0, 0.61111],
      "184": [0.17014, 0, 0, 0, 0.44445],
      "198": [0, 0.68333, 0, 0, 0.90278],
      "215": [0.08333, 0.58333, 0, 0, 0.77778],
      "216": [0.04861, 0.73194, 0, 0, 0.77778],
      "223": [0, 0.69444, 0, 0, 0.5],
      "230": [0, 0.43056, 0, 0, 0.72222],
      "247": [0.08333, 0.58333, 0, 0, 0.77778],
      "248": [0.09722, 0.52778, 0, 0, 0.5],
      "305": [0, 0.43056, 0, 0, 0.27778],
      "338": [0, 0.68333, 0, 0, 1.01389],
      "339": [0, 0.43056, 0, 0, 0.77778],
      "567": [0.19444, 0.43056, 0, 0, 0.30556],
      "710": [0, 0.69444, 0, 0, 0.5],
      "711": [0, 0.62847, 0, 0, 0.5],
      "713": [0, 0.56778, 0, 0, 0.5],
      "714": [0, 0.69444, 0, 0, 0.5],
      "715": [0, 0.69444, 0, 0, 0.5],
      "728": [0, 0.69444, 0, 0, 0.5],
      "729": [0, 0.66786, 0, 0, 0.27778],
      "730": [0, 0.69444, 0, 0, 0.75],
      "732": [0, 0.66786, 0, 0, 0.5],
      "733": [0, 0.69444, 0, 0, 0.5],
      "915": [0, 0.68333, 0, 0, 0.625],
      "916": [0, 0.68333, 0, 0, 0.83334],
      "920": [0, 0.68333, 0, 0, 0.77778],
      "923": [0, 0.68333, 0, 0, 0.69445],
      "926": [0, 0.68333, 0, 0, 0.66667],
      "928": [0, 0.68333, 0, 0, 0.75],
      "931": [0, 0.68333, 0, 0, 0.72222],
      "933": [0, 0.68333, 0, 0, 0.77778],
      "934": [0, 0.68333, 0, 0, 0.72222],
      "936": [0, 0.68333, 0, 0, 0.77778],
      "937": [0, 0.68333, 0, 0, 0.72222],
      "8211": [0, 0.43056, 0.02778, 0, 0.5],
      "8212": [0, 0.43056, 0.02778, 0, 1],
      "8216": [0, 0.69444, 0, 0, 0.27778],
      "8217": [0, 0.69444, 0, 0, 0.27778],
      "8220": [0, 0.69444, 0, 0, 0.5],
      "8221": [0, 0.69444, 0, 0, 0.5],
      "8224": [0.19444, 0.69444, 0, 0, 0.44445],
      "8225": [0.19444, 0.69444, 0, 0, 0.44445],
      "8230": [0, 0.123, 0, 0, 1.172],
      "8242": [0, 0.55556, 0, 0, 0.275],
      "8407": [0, 0.71444, 0.15382, 0, 0.5],
      "8463": [0, 0.68889, 0, 0, 0.54028],
      "8465": [0, 0.69444, 0, 0, 0.72222],
      "8467": [0, 0.69444, 0, 0.11111, 0.41667],
      "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
      "8476": [0, 0.69444, 0, 0, 0.72222],
      "8501": [0, 0.69444, 0, 0, 0.61111],
      "8592": [-0.13313, 0.36687, 0, 0, 1],
      "8593": [0.19444, 0.69444, 0, 0, 0.5],
      "8594": [-0.13313, 0.36687, 0, 0, 1],
      "8595": [0.19444, 0.69444, 0, 0, 0.5],
      "8596": [-0.13313, 0.36687, 0, 0, 1],
      "8597": [0.25, 0.75, 0, 0, 0.5],
      "8598": [0.19444, 0.69444, 0, 0, 1],
      "8599": [0.19444, 0.69444, 0, 0, 1],
      "8600": [0.19444, 0.69444, 0, 0, 1],
      "8601": [0.19444, 0.69444, 0, 0, 1],
      "8614": [0.011, 0.511, 0, 0, 1],
      "8617": [0.011, 0.511, 0, 0, 1.126],
      "8618": [0.011, 0.511, 0, 0, 1.126],
      "8636": [-0.13313, 0.36687, 0, 0, 1],
      "8637": [-0.13313, 0.36687, 0, 0, 1],
      "8640": [-0.13313, 0.36687, 0, 0, 1],
      "8641": [-0.13313, 0.36687, 0, 0, 1],
      "8652": [0.011, 0.671, 0, 0, 1],
      "8656": [-0.13313, 0.36687, 0, 0, 1],
      "8657": [0.19444, 0.69444, 0, 0, 0.61111],
      "8658": [-0.13313, 0.36687, 0, 0, 1],
      "8659": [0.19444, 0.69444, 0, 0, 0.61111],
      "8660": [-0.13313, 0.36687, 0, 0, 1],
      "8661": [0.25, 0.75, 0, 0, 0.61111],
      "8704": [0, 0.69444, 0, 0, 0.55556],
      "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
      "8707": [0, 0.69444, 0, 0, 0.55556],
      "8709": [0.05556, 0.75, 0, 0, 0.5],
      "8711": [0, 0.68333, 0, 0, 0.83334],
      "8712": [0.0391, 0.5391, 0, 0, 0.66667],
      "8715": [0.0391, 0.5391, 0, 0, 0.66667],
      "8722": [0.08333, 0.58333, 0, 0, 0.77778],
      "8723": [0.08333, 0.58333, 0, 0, 0.77778],
      "8725": [0.25, 0.75, 0, 0, 0.5],
      "8726": [0.25, 0.75, 0, 0, 0.5],
      "8727": [-0.03472, 0.46528, 0, 0, 0.5],
      "8728": [-0.05555, 0.44445, 0, 0, 0.5],
      "8729": [-0.05555, 0.44445, 0, 0, 0.5],
      "8730": [0.2, 0.8, 0, 0, 0.83334],
      "8733": [0, 0.43056, 0, 0, 0.77778],
      "8734": [0, 0.43056, 0, 0, 1],
      "8736": [0, 0.69224, 0, 0, 0.72222],
      "8739": [0.25, 0.75, 0, 0, 0.27778],
      "8741": [0.25, 0.75, 0, 0, 0.5],
      "8743": [0, 0.55556, 0, 0, 0.66667],
      "8744": [0, 0.55556, 0, 0, 0.66667],
      "8745": [0, 0.55556, 0, 0, 0.66667],
      "8746": [0, 0.55556, 0, 0, 0.66667],
      "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
      "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
      "8768": [0.19444, 0.69444, 0, 0, 0.27778],
      "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
      "8773": [-0.022, 0.589, 0, 0, 0.778],
      "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
      "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
      "8784": [-0.133, 0.673, 0, 0, 0.778],
      "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
      "8804": [0.13597, 0.63597, 0, 0, 0.77778],
      "8805": [0.13597, 0.63597, 0, 0, 0.77778],
      "8810": [0.0391, 0.5391, 0, 0, 1],
      "8811": [0.0391, 0.5391, 0, 0, 1],
      "8826": [0.0391, 0.5391, 0, 0, 0.77778],
      "8827": [0.0391, 0.5391, 0, 0, 0.77778],
      "8834": [0.0391, 0.5391, 0, 0, 0.77778],
      "8835": [0.0391, 0.5391, 0, 0, 0.77778],
      "8838": [0.13597, 0.63597, 0, 0, 0.77778],
      "8839": [0.13597, 0.63597, 0, 0, 0.77778],
      "8846": [0, 0.55556, 0, 0, 0.66667],
      "8849": [0.13597, 0.63597, 0, 0, 0.77778],
      "8850": [0.13597, 0.63597, 0, 0, 0.77778],
      "8851": [0, 0.55556, 0, 0, 0.66667],
      "8852": [0, 0.55556, 0, 0, 0.66667],
      "8853": [0.08333, 0.58333, 0, 0, 0.77778],
      "8854": [0.08333, 0.58333, 0, 0, 0.77778],
      "8855": [0.08333, 0.58333, 0, 0, 0.77778],
      "8856": [0.08333, 0.58333, 0, 0, 0.77778],
      "8857": [0.08333, 0.58333, 0, 0, 0.77778],
      "8866": [0, 0.69444, 0, 0, 0.61111],
      "8867": [0, 0.69444, 0, 0, 0.61111],
      "8868": [0, 0.69444, 0, 0, 0.77778],
      "8869": [0, 0.69444, 0, 0, 0.77778],
      "8872": [0.249, 0.75, 0, 0, 0.867],
      "8900": [-0.05555, 0.44445, 0, 0, 0.5],
      "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
      "8902": [-0.03472, 0.46528, 0, 0, 0.5],
      "8904": [5e-3, 0.505, 0, 0, 0.9],
      "8942": [0.03, 0.903, 0, 0, 0.278],
      "8943": [-0.19, 0.313, 0, 0, 1.172],
      "8945": [-0.1, 0.823, 0, 0, 1.282],
      "8968": [0.25, 0.75, 0, 0, 0.44445],
      "8969": [0.25, 0.75, 0, 0, 0.44445],
      "8970": [0.25, 0.75, 0, 0, 0.44445],
      "8971": [0.25, 0.75, 0, 0, 0.44445],
      "8994": [-0.14236, 0.35764, 0, 0, 1],
      "8995": [-0.14236, 0.35764, 0, 0, 1],
      "9136": [0.244, 0.744, 0, 0, 0.412],
      "9137": [0.244, 0.745, 0, 0, 0.412],
      "9651": [0.19444, 0.69444, 0, 0, 0.88889],
      "9657": [-0.03472, 0.46528, 0, 0, 0.5],
      "9661": [0.19444, 0.69444, 0, 0, 0.88889],
      "9667": [-0.03472, 0.46528, 0, 0, 0.5],
      "9711": [0.19444, 0.69444, 0, 0, 1],
      "9824": [0.12963, 0.69444, 0, 0, 0.77778],
      "9825": [0.12963, 0.69444, 0, 0, 0.77778],
      "9826": [0.12963, 0.69444, 0, 0, 0.77778],
      "9827": [0.12963, 0.69444, 0, 0, 0.77778],
      "9837": [0, 0.75, 0, 0, 0.38889],
      "9838": [0.19444, 0.69444, 0, 0, 0.38889],
      "9839": [0.19444, 0.69444, 0, 0, 0.38889],
      "10216": [0.25, 0.75, 0, 0, 0.38889],
      "10217": [0.25, 0.75, 0, 0, 0.38889],
      "10222": [0.244, 0.744, 0, 0, 0.412],
      "10223": [0.244, 0.745, 0, 0, 0.412],
      "10229": [0.011, 0.511, 0, 0, 1.609],
      "10230": [0.011, 0.511, 0, 0, 1.638],
      "10231": [0.011, 0.511, 0, 0, 1.859],
      "10232": [0.024, 0.525, 0, 0, 1.609],
      "10233": [0.024, 0.525, 0, 0, 1.638],
      "10234": [0.024, 0.525, 0, 0, 1.858],
      "10236": [0.011, 0.511, 0, 0, 1.638],
      "10815": [0, 0.68333, 0, 0, 0.75],
      "10927": [0.13597, 0.63597, 0, 0, 0.77778],
      "10928": [0.13597, 0.63597, 0, 0, 0.77778],
      "57376": [0.19444, 0.69444, 0, 0, 0]
    },
    "Math-BoldItalic": {
      "32": [0, 0, 0, 0, 0.25],
      "48": [0, 0.44444, 0, 0, 0.575],
      "49": [0, 0.44444, 0, 0, 0.575],
      "50": [0, 0.44444, 0, 0, 0.575],
      "51": [0.19444, 0.44444, 0, 0, 0.575],
      "52": [0.19444, 0.44444, 0, 0, 0.575],
      "53": [0.19444, 0.44444, 0, 0, 0.575],
      "54": [0, 0.64444, 0, 0, 0.575],
      "55": [0.19444, 0.44444, 0, 0, 0.575],
      "56": [0, 0.64444, 0, 0, 0.575],
      "57": [0.19444, 0.44444, 0, 0, 0.575],
      "65": [0, 0.68611, 0, 0, 0.86944],
      "66": [0, 0.68611, 0.04835, 0, 0.8664],
      "67": [0, 0.68611, 0.06979, 0, 0.81694],
      "68": [0, 0.68611, 0.03194, 0, 0.93812],
      "69": [0, 0.68611, 0.05451, 0, 0.81007],
      "70": [0, 0.68611, 0.15972, 0, 0.68889],
      "71": [0, 0.68611, 0, 0, 0.88673],
      "72": [0, 0.68611, 0.08229, 0, 0.98229],
      "73": [0, 0.68611, 0.07778, 0, 0.51111],
      "74": [0, 0.68611, 0.10069, 0, 0.63125],
      "75": [0, 0.68611, 0.06979, 0, 0.97118],
      "76": [0, 0.68611, 0, 0, 0.75555],
      "77": [0, 0.68611, 0.11424, 0, 1.14201],
      "78": [0, 0.68611, 0.11424, 0, 0.95034],
      "79": [0, 0.68611, 0.03194, 0, 0.83666],
      "80": [0, 0.68611, 0.15972, 0, 0.72309],
      "81": [0.19444, 0.68611, 0, 0, 0.86861],
      "82": [0, 0.68611, 421e-5, 0, 0.87235],
      "83": [0, 0.68611, 0.05382, 0, 0.69271],
      "84": [0, 0.68611, 0.15972, 0, 0.63663],
      "85": [0, 0.68611, 0.11424, 0, 0.80027],
      "86": [0, 0.68611, 0.25555, 0, 0.67778],
      "87": [0, 0.68611, 0.15972, 0, 1.09305],
      "88": [0, 0.68611, 0.07778, 0, 0.94722],
      "89": [0, 0.68611, 0.25555, 0, 0.67458],
      "90": [0, 0.68611, 0.06979, 0, 0.77257],
      "97": [0, 0.44444, 0, 0, 0.63287],
      "98": [0, 0.69444, 0, 0, 0.52083],
      "99": [0, 0.44444, 0, 0, 0.51342],
      "100": [0, 0.69444, 0, 0, 0.60972],
      "101": [0, 0.44444, 0, 0, 0.55361],
      "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
      "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
      "104": [0, 0.69444, 0, 0, 0.66759],
      "105": [0, 0.69326, 0, 0, 0.4048],
      "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
      "107": [0, 0.69444, 0.01852, 0, 0.6037],
      "108": [0, 0.69444, 88e-4, 0, 0.34815],
      "109": [0, 0.44444, 0, 0, 1.0324],
      "110": [0, 0.44444, 0, 0, 0.71296],
      "111": [0, 0.44444, 0, 0, 0.58472],
      "112": [0.19444, 0.44444, 0, 0, 0.60092],
      "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
      "114": [0, 0.44444, 0.03194, 0, 0.5287],
      "115": [0, 0.44444, 0, 0, 0.53125],
      "116": [0, 0.63492, 0, 0, 0.41528],
      "117": [0, 0.44444, 0, 0, 0.68102],
      "118": [0, 0.44444, 0.03704, 0, 0.56666],
      "119": [0, 0.44444, 0.02778, 0, 0.83148],
      "120": [0, 0.44444, 0, 0, 0.65903],
      "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
      "122": [0, 0.44444, 0.04213, 0, 0.55509],
      "160": [0, 0, 0, 0, 0.25],
      "915": [0, 0.68611, 0.15972, 0, 0.65694],
      "916": [0, 0.68611, 0, 0, 0.95833],
      "920": [0, 0.68611, 0.03194, 0, 0.86722],
      "923": [0, 0.68611, 0, 0, 0.80555],
      "926": [0, 0.68611, 0.07458, 0, 0.84125],
      "928": [0, 0.68611, 0.08229, 0, 0.98229],
      "931": [0, 0.68611, 0.05451, 0, 0.88507],
      "933": [0, 0.68611, 0.15972, 0, 0.67083],
      "934": [0, 0.68611, 0, 0, 0.76666],
      "936": [0, 0.68611, 0.11653, 0, 0.71402],
      "937": [0, 0.68611, 0.04835, 0, 0.8789],
      "945": [0, 0.44444, 0, 0, 0.76064],
      "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
      "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
      "948": [0, 0.69444, 0.03819, 0, 0.52222],
      "949": [0, 0.44444, 0, 0, 0.52882],
      "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
      "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
      "952": [0, 0.69444, 0.03194, 0, 0.5618],
      "953": [0, 0.44444, 0, 0, 0.41204],
      "954": [0, 0.44444, 0, 0, 0.66759],
      "955": [0, 0.69444, 0, 0, 0.67083],
      "956": [0.19444, 0.44444, 0, 0, 0.70787],
      "957": [0, 0.44444, 0.06898, 0, 0.57685],
      "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
      "959": [0, 0.44444, 0, 0, 0.58472],
      "960": [0, 0.44444, 0.03704, 0, 0.68241],
      "961": [0.19444, 0.44444, 0, 0, 0.6118],
      "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
      "963": [0, 0.44444, 0.03704, 0, 0.68588],
      "964": [0, 0.44444, 0.13472, 0, 0.52083],
      "965": [0, 0.44444, 0.03704, 0, 0.63055],
      "966": [0.19444, 0.44444, 0, 0, 0.74722],
      "967": [0.19444, 0.44444, 0, 0, 0.71805],
      "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
      "969": [0, 0.44444, 0.03704, 0, 0.71782],
      "977": [0, 0.69444, 0, 0, 0.69155],
      "981": [0.19444, 0.69444, 0, 0, 0.7125],
      "982": [0, 0.44444, 0.03194, 0, 0.975],
      "1009": [0.19444, 0.44444, 0, 0, 0.6118],
      "1013": [0, 0.44444, 0, 0, 0.48333],
      "57649": [0, 0.44444, 0, 0, 0.39352],
      "57911": [0.19444, 0.44444, 0, 0, 0.43889]
    },
    "Math-Italic": {
      "32": [0, 0, 0, 0, 0.25],
      "48": [0, 0.43056, 0, 0, 0.5],
      "49": [0, 0.43056, 0, 0, 0.5],
      "50": [0, 0.43056, 0, 0, 0.5],
      "51": [0.19444, 0.43056, 0, 0, 0.5],
      "52": [0.19444, 0.43056, 0, 0, 0.5],
      "53": [0.19444, 0.43056, 0, 0, 0.5],
      "54": [0, 0.64444, 0, 0, 0.5],
      "55": [0.19444, 0.43056, 0, 0, 0.5],
      "56": [0, 0.64444, 0, 0, 0.5],
      "57": [0.19444, 0.43056, 0, 0, 0.5],
      "65": [0, 0.68333, 0, 0.13889, 0.75],
      "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
      "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
      "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
      "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
      "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
      "71": [0, 0.68333, 0, 0.08334, 0.78625],
      "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
      "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
      "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
      "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
      "76": [0, 0.68333, 0, 0.02778, 0.68056],
      "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
      "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
      "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
      "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
      "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
      "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
      "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
      "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
      "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
      "86": [0, 0.68333, 0.22222, 0, 0.58333],
      "87": [0, 0.68333, 0.13889, 0, 0.94445],
      "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
      "89": [0, 0.68333, 0.22222, 0, 0.58056],
      "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
      "97": [0, 0.43056, 0, 0, 0.52859],
      "98": [0, 0.69444, 0, 0, 0.42917],
      "99": [0, 0.43056, 0, 0.05556, 0.43276],
      "100": [0, 0.69444, 0, 0.16667, 0.52049],
      "101": [0, 0.43056, 0, 0.05556, 0.46563],
      "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
      "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
      "104": [0, 0.69444, 0, 0, 0.57616],
      "105": [0, 0.65952, 0, 0, 0.34451],
      "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
      "107": [0, 0.69444, 0.03148, 0, 0.5206],
      "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
      "109": [0, 0.43056, 0, 0, 0.87801],
      "110": [0, 0.43056, 0, 0, 0.60023],
      "111": [0, 0.43056, 0, 0.05556, 0.48472],
      "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
      "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
      "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
      "115": [0, 0.43056, 0, 0.05556, 0.46875],
      "116": [0, 0.61508, 0, 0.08334, 0.36111],
      "117": [0, 0.43056, 0, 0.02778, 0.57246],
      "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
      "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
      "120": [0, 0.43056, 0, 0.02778, 0.57153],
      "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
      "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
      "160": [0, 0, 0, 0, 0.25],
      "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
      "916": [0, 0.68333, 0, 0.16667, 0.83334],
      "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
      "923": [0, 0.68333, 0, 0.16667, 0.69445],
      "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
      "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
      "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
      "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
      "934": [0, 0.68333, 0, 0.08334, 0.66667],
      "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
      "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
      "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
      "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
      "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
      "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
      "949": [0, 0.43056, 0, 0.08334, 0.46632],
      "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
      "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
      "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
      "953": [0, 0.43056, 0, 0.05556, 0.35394],
      "954": [0, 0.43056, 0, 0, 0.57616],
      "955": [0, 0.69444, 0, 0, 0.58334],
      "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
      "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
      "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
      "959": [0, 0.43056, 0, 0.05556, 0.48472],
      "960": [0, 0.43056, 0.03588, 0, 0.57003],
      "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
      "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
      "963": [0, 0.43056, 0.03588, 0, 0.57141],
      "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
      "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
      "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
      "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
      "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
      "969": [0, 0.43056, 0.03588, 0, 0.62245],
      "977": [0, 0.69444, 0, 0.08334, 0.59144],
      "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
      "982": [0, 0.43056, 0.02778, 0, 0.82813],
      "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
      "1013": [0, 0.43056, 0, 0.05556, 0.4059],
      "57649": [0, 0.43056, 0, 0.02778, 0.32246],
      "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
    },
    "SansSerif-Bold": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0, 0, 0.36667],
      "34": [0, 0.69444, 0, 0, 0.55834],
      "35": [0.19444, 0.69444, 0, 0, 0.91667],
      "36": [0.05556, 0.75, 0, 0, 0.55],
      "37": [0.05556, 0.75, 0, 0, 1.02912],
      "38": [0, 0.69444, 0, 0, 0.83056],
      "39": [0, 0.69444, 0, 0, 0.30556],
      "40": [0.25, 0.75, 0, 0, 0.42778],
      "41": [0.25, 0.75, 0, 0, 0.42778],
      "42": [0, 0.75, 0, 0, 0.55],
      "43": [0.11667, 0.61667, 0, 0, 0.85556],
      "44": [0.10556, 0.13056, 0, 0, 0.30556],
      "45": [0, 0.45833, 0, 0, 0.36667],
      "46": [0, 0.13056, 0, 0, 0.30556],
      "47": [0.25, 0.75, 0, 0, 0.55],
      "48": [0, 0.69444, 0, 0, 0.55],
      "49": [0, 0.69444, 0, 0, 0.55],
      "50": [0, 0.69444, 0, 0, 0.55],
      "51": [0, 0.69444, 0, 0, 0.55],
      "52": [0, 0.69444, 0, 0, 0.55],
      "53": [0, 0.69444, 0, 0, 0.55],
      "54": [0, 0.69444, 0, 0, 0.55],
      "55": [0, 0.69444, 0, 0, 0.55],
      "56": [0, 0.69444, 0, 0, 0.55],
      "57": [0, 0.69444, 0, 0, 0.55],
      "58": [0, 0.45833, 0, 0, 0.30556],
      "59": [0.10556, 0.45833, 0, 0, 0.30556],
      "61": [-0.09375, 0.40625, 0, 0, 0.85556],
      "63": [0, 0.69444, 0, 0, 0.51945],
      "64": [0, 0.69444, 0, 0, 0.73334],
      "65": [0, 0.69444, 0, 0, 0.73334],
      "66": [0, 0.69444, 0, 0, 0.73334],
      "67": [0, 0.69444, 0, 0, 0.70278],
      "68": [0, 0.69444, 0, 0, 0.79445],
      "69": [0, 0.69444, 0, 0, 0.64167],
      "70": [0, 0.69444, 0, 0, 0.61111],
      "71": [0, 0.69444, 0, 0, 0.73334],
      "72": [0, 0.69444, 0, 0, 0.79445],
      "73": [0, 0.69444, 0, 0, 0.33056],
      "74": [0, 0.69444, 0, 0, 0.51945],
      "75": [0, 0.69444, 0, 0, 0.76389],
      "76": [0, 0.69444, 0, 0, 0.58056],
      "77": [0, 0.69444, 0, 0, 0.97778],
      "78": [0, 0.69444, 0, 0, 0.79445],
      "79": [0, 0.69444, 0, 0, 0.79445],
      "80": [0, 0.69444, 0, 0, 0.70278],
      "81": [0.10556, 0.69444, 0, 0, 0.79445],
      "82": [0, 0.69444, 0, 0, 0.70278],
      "83": [0, 0.69444, 0, 0, 0.61111],
      "84": [0, 0.69444, 0, 0, 0.73334],
      "85": [0, 0.69444, 0, 0, 0.76389],
      "86": [0, 0.69444, 0.01528, 0, 0.73334],
      "87": [0, 0.69444, 0.01528, 0, 1.03889],
      "88": [0, 0.69444, 0, 0, 0.73334],
      "89": [0, 0.69444, 0.0275, 0, 0.73334],
      "90": [0, 0.69444, 0, 0, 0.67223],
      "91": [0.25, 0.75, 0, 0, 0.34306],
      "93": [0.25, 0.75, 0, 0, 0.34306],
      "94": [0, 0.69444, 0, 0, 0.55],
      "95": [0.35, 0.10833, 0.03056, 0, 0.55],
      "97": [0, 0.45833, 0, 0, 0.525],
      "98": [0, 0.69444, 0, 0, 0.56111],
      "99": [0, 0.45833, 0, 0, 0.48889],
      "100": [0, 0.69444, 0, 0, 0.56111],
      "101": [0, 0.45833, 0, 0, 0.51111],
      "102": [0, 0.69444, 0.07639, 0, 0.33611],
      "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
      "104": [0, 0.69444, 0, 0, 0.56111],
      "105": [0, 0.69444, 0, 0, 0.25556],
      "106": [0.19444, 0.69444, 0, 0, 0.28611],
      "107": [0, 0.69444, 0, 0, 0.53056],
      "108": [0, 0.69444, 0, 0, 0.25556],
      "109": [0, 0.45833, 0, 0, 0.86667],
      "110": [0, 0.45833, 0, 0, 0.56111],
      "111": [0, 0.45833, 0, 0, 0.55],
      "112": [0.19444, 0.45833, 0, 0, 0.56111],
      "113": [0.19444, 0.45833, 0, 0, 0.56111],
      "114": [0, 0.45833, 0.01528, 0, 0.37222],
      "115": [0, 0.45833, 0, 0, 0.42167],
      "116": [0, 0.58929, 0, 0, 0.40417],
      "117": [0, 0.45833, 0, 0, 0.56111],
      "118": [0, 0.45833, 0.01528, 0, 0.5],
      "119": [0, 0.45833, 0.01528, 0, 0.74445],
      "120": [0, 0.45833, 0, 0, 0.5],
      "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
      "122": [0, 0.45833, 0, 0, 0.47639],
      "126": [0.35, 0.34444, 0, 0, 0.55],
      "160": [0, 0, 0, 0, 0.25],
      "168": [0, 0.69444, 0, 0, 0.55],
      "176": [0, 0.69444, 0, 0, 0.73334],
      "180": [0, 0.69444, 0, 0, 0.55],
      "184": [0.17014, 0, 0, 0, 0.48889],
      "305": [0, 0.45833, 0, 0, 0.25556],
      "567": [0.19444, 0.45833, 0, 0, 0.28611],
      "710": [0, 0.69444, 0, 0, 0.55],
      "711": [0, 0.63542, 0, 0, 0.55],
      "713": [0, 0.63778, 0, 0, 0.55],
      "728": [0, 0.69444, 0, 0, 0.55],
      "729": [0, 0.69444, 0, 0, 0.30556],
      "730": [0, 0.69444, 0, 0, 0.73334],
      "732": [0, 0.69444, 0, 0, 0.55],
      "733": [0, 0.69444, 0, 0, 0.55],
      "915": [0, 0.69444, 0, 0, 0.58056],
      "916": [0, 0.69444, 0, 0, 0.91667],
      "920": [0, 0.69444, 0, 0, 0.85556],
      "923": [0, 0.69444, 0, 0, 0.67223],
      "926": [0, 0.69444, 0, 0, 0.73334],
      "928": [0, 0.69444, 0, 0, 0.79445],
      "931": [0, 0.69444, 0, 0, 0.79445],
      "933": [0, 0.69444, 0, 0, 0.85556],
      "934": [0, 0.69444, 0, 0, 0.79445],
      "936": [0, 0.69444, 0, 0, 0.85556],
      "937": [0, 0.69444, 0, 0, 0.79445],
      "8211": [0, 0.45833, 0.03056, 0, 0.55],
      "8212": [0, 0.45833, 0.03056, 0, 1.10001],
      "8216": [0, 0.69444, 0, 0, 0.30556],
      "8217": [0, 0.69444, 0, 0, 0.30556],
      "8220": [0, 0.69444, 0, 0, 0.55834],
      "8221": [0, 0.69444, 0, 0, 0.55834]
    },
    "SansSerif-Italic": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0.05733, 0, 0.31945],
      "34": [0, 0.69444, 316e-5, 0, 0.5],
      "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
      "36": [0.05556, 0.75, 0.11156, 0, 0.5],
      "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
      "38": [0, 0.69444, 0.03058, 0, 0.75834],
      "39": [0, 0.69444, 0.07816, 0, 0.27778],
      "40": [0.25, 0.75, 0.13164, 0, 0.38889],
      "41": [0.25, 0.75, 0.02536, 0, 0.38889],
      "42": [0, 0.75, 0.11775, 0, 0.5],
      "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
      "44": [0.125, 0.08333, 0, 0, 0.27778],
      "45": [0, 0.44444, 0.01946, 0, 0.33333],
      "46": [0, 0.08333, 0, 0, 0.27778],
      "47": [0.25, 0.75, 0.13164, 0, 0.5],
      "48": [0, 0.65556, 0.11156, 0, 0.5],
      "49": [0, 0.65556, 0.11156, 0, 0.5],
      "50": [0, 0.65556, 0.11156, 0, 0.5],
      "51": [0, 0.65556, 0.11156, 0, 0.5],
      "52": [0, 0.65556, 0.11156, 0, 0.5],
      "53": [0, 0.65556, 0.11156, 0, 0.5],
      "54": [0, 0.65556, 0.11156, 0, 0.5],
      "55": [0, 0.65556, 0.11156, 0, 0.5],
      "56": [0, 0.65556, 0.11156, 0, 0.5],
      "57": [0, 0.65556, 0.11156, 0, 0.5],
      "58": [0, 0.44444, 0.02502, 0, 0.27778],
      "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
      "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
      "63": [0, 0.69444, 0.11809, 0, 0.47222],
      "64": [0, 0.69444, 0.07555, 0, 0.66667],
      "65": [0, 0.69444, 0, 0, 0.66667],
      "66": [0, 0.69444, 0.08293, 0, 0.66667],
      "67": [0, 0.69444, 0.11983, 0, 0.63889],
      "68": [0, 0.69444, 0.07555, 0, 0.72223],
      "69": [0, 0.69444, 0.11983, 0, 0.59722],
      "70": [0, 0.69444, 0.13372, 0, 0.56945],
      "71": [0, 0.69444, 0.11983, 0, 0.66667],
      "72": [0, 0.69444, 0.08094, 0, 0.70834],
      "73": [0, 0.69444, 0.13372, 0, 0.27778],
      "74": [0, 0.69444, 0.08094, 0, 0.47222],
      "75": [0, 0.69444, 0.11983, 0, 0.69445],
      "76": [0, 0.69444, 0, 0, 0.54167],
      "77": [0, 0.69444, 0.08094, 0, 0.875],
      "78": [0, 0.69444, 0.08094, 0, 0.70834],
      "79": [0, 0.69444, 0.07555, 0, 0.73611],
      "80": [0, 0.69444, 0.08293, 0, 0.63889],
      "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
      "82": [0, 0.69444, 0.08293, 0, 0.64584],
      "83": [0, 0.69444, 0.09205, 0, 0.55556],
      "84": [0, 0.69444, 0.13372, 0, 0.68056],
      "85": [0, 0.69444, 0.08094, 0, 0.6875],
      "86": [0, 0.69444, 0.1615, 0, 0.66667],
      "87": [0, 0.69444, 0.1615, 0, 0.94445],
      "88": [0, 0.69444, 0.13372, 0, 0.66667],
      "89": [0, 0.69444, 0.17261, 0, 0.66667],
      "90": [0, 0.69444, 0.11983, 0, 0.61111],
      "91": [0.25, 0.75, 0.15942, 0, 0.28889],
      "93": [0.25, 0.75, 0.08719, 0, 0.28889],
      "94": [0, 0.69444, 0.0799, 0, 0.5],
      "95": [0.35, 0.09444, 0.08616, 0, 0.5],
      "97": [0, 0.44444, 981e-5, 0, 0.48056],
      "98": [0, 0.69444, 0.03057, 0, 0.51667],
      "99": [0, 0.44444, 0.08336, 0, 0.44445],
      "100": [0, 0.69444, 0.09483, 0, 0.51667],
      "101": [0, 0.44444, 0.06778, 0, 0.44445],
      "102": [0, 0.69444, 0.21705, 0, 0.30556],
      "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
      "104": [0, 0.69444, 0.01778, 0, 0.51667],
      "105": [0, 0.67937, 0.09718, 0, 0.23889],
      "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
      "107": [0, 0.69444, 0.08336, 0, 0.48889],
      "108": [0, 0.69444, 0.09483, 0, 0.23889],
      "109": [0, 0.44444, 0.01778, 0, 0.79445],
      "110": [0, 0.44444, 0.01778, 0, 0.51667],
      "111": [0, 0.44444, 0.06613, 0, 0.5],
      "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
      "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
      "114": [0, 0.44444, 0.10836, 0, 0.34167],
      "115": [0, 0.44444, 0.0778, 0, 0.38333],
      "116": [0, 0.57143, 0.07225, 0, 0.36111],
      "117": [0, 0.44444, 0.04169, 0, 0.51667],
      "118": [0, 0.44444, 0.10836, 0, 0.46111],
      "119": [0, 0.44444, 0.10836, 0, 0.68334],
      "120": [0, 0.44444, 0.09169, 0, 0.46111],
      "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
      "122": [0, 0.44444, 0.08752, 0, 0.43472],
      "126": [0.35, 0.32659, 0.08826, 0, 0.5],
      "160": [0, 0, 0, 0, 0.25],
      "168": [0, 0.67937, 0.06385, 0, 0.5],
      "176": [0, 0.69444, 0, 0, 0.73752],
      "184": [0.17014, 0, 0, 0, 0.44445],
      "305": [0, 0.44444, 0.04169, 0, 0.23889],
      "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
      "710": [0, 0.69444, 0.0799, 0, 0.5],
      "711": [0, 0.63194, 0.08432, 0, 0.5],
      "713": [0, 0.60889, 0.08776, 0, 0.5],
      "714": [0, 0.69444, 0.09205, 0, 0.5],
      "715": [0, 0.69444, 0, 0, 0.5],
      "728": [0, 0.69444, 0.09483, 0, 0.5],
      "729": [0, 0.67937, 0.07774, 0, 0.27778],
      "730": [0, 0.69444, 0, 0, 0.73752],
      "732": [0, 0.67659, 0.08826, 0, 0.5],
      "733": [0, 0.69444, 0.09205, 0, 0.5],
      "915": [0, 0.69444, 0.13372, 0, 0.54167],
      "916": [0, 0.69444, 0, 0, 0.83334],
      "920": [0, 0.69444, 0.07555, 0, 0.77778],
      "923": [0, 0.69444, 0, 0, 0.61111],
      "926": [0, 0.69444, 0.12816, 0, 0.66667],
      "928": [0, 0.69444, 0.08094, 0, 0.70834],
      "931": [0, 0.69444, 0.11983, 0, 0.72222],
      "933": [0, 0.69444, 0.09031, 0, 0.77778],
      "934": [0, 0.69444, 0.04603, 0, 0.72222],
      "936": [0, 0.69444, 0.09031, 0, 0.77778],
      "937": [0, 0.69444, 0.08293, 0, 0.72222],
      "8211": [0, 0.44444, 0.08616, 0, 0.5],
      "8212": [0, 0.44444, 0.08616, 0, 1],
      "8216": [0, 0.69444, 0.07816, 0, 0.27778],
      "8217": [0, 0.69444, 0.07816, 0, 0.27778],
      "8220": [0, 0.69444, 0.14205, 0, 0.5],
      "8221": [0, 0.69444, 316e-5, 0, 0.5]
    },
    "SansSerif-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "33": [0, 0.69444, 0, 0, 0.31945],
      "34": [0, 0.69444, 0, 0, 0.5],
      "35": [0.19444, 0.69444, 0, 0, 0.83334],
      "36": [0.05556, 0.75, 0, 0, 0.5],
      "37": [0.05556, 0.75, 0, 0, 0.83334],
      "38": [0, 0.69444, 0, 0, 0.75834],
      "39": [0, 0.69444, 0, 0, 0.27778],
      "40": [0.25, 0.75, 0, 0, 0.38889],
      "41": [0.25, 0.75, 0, 0, 0.38889],
      "42": [0, 0.75, 0, 0, 0.5],
      "43": [0.08333, 0.58333, 0, 0, 0.77778],
      "44": [0.125, 0.08333, 0, 0, 0.27778],
      "45": [0, 0.44444, 0, 0, 0.33333],
      "46": [0, 0.08333, 0, 0, 0.27778],
      "47": [0.25, 0.75, 0, 0, 0.5],
      "48": [0, 0.65556, 0, 0, 0.5],
      "49": [0, 0.65556, 0, 0, 0.5],
      "50": [0, 0.65556, 0, 0, 0.5],
      "51": [0, 0.65556, 0, 0, 0.5],
      "52": [0, 0.65556, 0, 0, 0.5],
      "53": [0, 0.65556, 0, 0, 0.5],
      "54": [0, 0.65556, 0, 0, 0.5],
      "55": [0, 0.65556, 0, 0, 0.5],
      "56": [0, 0.65556, 0, 0, 0.5],
      "57": [0, 0.65556, 0, 0, 0.5],
      "58": [0, 0.44444, 0, 0, 0.27778],
      "59": [0.125, 0.44444, 0, 0, 0.27778],
      "61": [-0.13, 0.37, 0, 0, 0.77778],
      "63": [0, 0.69444, 0, 0, 0.47222],
      "64": [0, 0.69444, 0, 0, 0.66667],
      "65": [0, 0.69444, 0, 0, 0.66667],
      "66": [0, 0.69444, 0, 0, 0.66667],
      "67": [0, 0.69444, 0, 0, 0.63889],
      "68": [0, 0.69444, 0, 0, 0.72223],
      "69": [0, 0.69444, 0, 0, 0.59722],
      "70": [0, 0.69444, 0, 0, 0.56945],
      "71": [0, 0.69444, 0, 0, 0.66667],
      "72": [0, 0.69444, 0, 0, 0.70834],
      "73": [0, 0.69444, 0, 0, 0.27778],
      "74": [0, 0.69444, 0, 0, 0.47222],
      "75": [0, 0.69444, 0, 0, 0.69445],
      "76": [0, 0.69444, 0, 0, 0.54167],
      "77": [0, 0.69444, 0, 0, 0.875],
      "78": [0, 0.69444, 0, 0, 0.70834],
      "79": [0, 0.69444, 0, 0, 0.73611],
      "80": [0, 0.69444, 0, 0, 0.63889],
      "81": [0.125, 0.69444, 0, 0, 0.73611],
      "82": [0, 0.69444, 0, 0, 0.64584],
      "83": [0, 0.69444, 0, 0, 0.55556],
      "84": [0, 0.69444, 0, 0, 0.68056],
      "85": [0, 0.69444, 0, 0, 0.6875],
      "86": [0, 0.69444, 0.01389, 0, 0.66667],
      "87": [0, 0.69444, 0.01389, 0, 0.94445],
      "88": [0, 0.69444, 0, 0, 0.66667],
      "89": [0, 0.69444, 0.025, 0, 0.66667],
      "90": [0, 0.69444, 0, 0, 0.61111],
      "91": [0.25, 0.75, 0, 0, 0.28889],
      "93": [0.25, 0.75, 0, 0, 0.28889],
      "94": [0, 0.69444, 0, 0, 0.5],
      "95": [0.35, 0.09444, 0.02778, 0, 0.5],
      "97": [0, 0.44444, 0, 0, 0.48056],
      "98": [0, 0.69444, 0, 0, 0.51667],
      "99": [0, 0.44444, 0, 0, 0.44445],
      "100": [0, 0.69444, 0, 0, 0.51667],
      "101": [0, 0.44444, 0, 0, 0.44445],
      "102": [0, 0.69444, 0.06944, 0, 0.30556],
      "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
      "104": [0, 0.69444, 0, 0, 0.51667],
      "105": [0, 0.67937, 0, 0, 0.23889],
      "106": [0.19444, 0.67937, 0, 0, 0.26667],
      "107": [0, 0.69444, 0, 0, 0.48889],
      "108": [0, 0.69444, 0, 0, 0.23889],
      "109": [0, 0.44444, 0, 0, 0.79445],
      "110": [0, 0.44444, 0, 0, 0.51667],
      "111": [0, 0.44444, 0, 0, 0.5],
      "112": [0.19444, 0.44444, 0, 0, 0.51667],
      "113": [0.19444, 0.44444, 0, 0, 0.51667],
      "114": [0, 0.44444, 0.01389, 0, 0.34167],
      "115": [0, 0.44444, 0, 0, 0.38333],
      "116": [0, 0.57143, 0, 0, 0.36111],
      "117": [0, 0.44444, 0, 0, 0.51667],
      "118": [0, 0.44444, 0.01389, 0, 0.46111],
      "119": [0, 0.44444, 0.01389, 0, 0.68334],
      "120": [0, 0.44444, 0, 0, 0.46111],
      "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
      "122": [0, 0.44444, 0, 0, 0.43472],
      "126": [0.35, 0.32659, 0, 0, 0.5],
      "160": [0, 0, 0, 0, 0.25],
      "168": [0, 0.67937, 0, 0, 0.5],
      "176": [0, 0.69444, 0, 0, 0.66667],
      "184": [0.17014, 0, 0, 0, 0.44445],
      "305": [0, 0.44444, 0, 0, 0.23889],
      "567": [0.19444, 0.44444, 0, 0, 0.26667],
      "710": [0, 0.69444, 0, 0, 0.5],
      "711": [0, 0.63194, 0, 0, 0.5],
      "713": [0, 0.60889, 0, 0, 0.5],
      "714": [0, 0.69444, 0, 0, 0.5],
      "715": [0, 0.69444, 0, 0, 0.5],
      "728": [0, 0.69444, 0, 0, 0.5],
      "729": [0, 0.67937, 0, 0, 0.27778],
      "730": [0, 0.69444, 0, 0, 0.66667],
      "732": [0, 0.67659, 0, 0, 0.5],
      "733": [0, 0.69444, 0, 0, 0.5],
      "915": [0, 0.69444, 0, 0, 0.54167],
      "916": [0, 0.69444, 0, 0, 0.83334],
      "920": [0, 0.69444, 0, 0, 0.77778],
      "923": [0, 0.69444, 0, 0, 0.61111],
      "926": [0, 0.69444, 0, 0, 0.66667],
      "928": [0, 0.69444, 0, 0, 0.70834],
      "931": [0, 0.69444, 0, 0, 0.72222],
      "933": [0, 0.69444, 0, 0, 0.77778],
      "934": [0, 0.69444, 0, 0, 0.72222],
      "936": [0, 0.69444, 0, 0, 0.77778],
      "937": [0, 0.69444, 0, 0, 0.72222],
      "8211": [0, 0.44444, 0.02778, 0, 0.5],
      "8212": [0, 0.44444, 0.02778, 0, 1],
      "8216": [0, 0.69444, 0, 0, 0.27778],
      "8217": [0, 0.69444, 0, 0, 0.27778],
      "8220": [0, 0.69444, 0, 0, 0.5],
      "8221": [0, 0.69444, 0, 0, 0.5]
    },
    "Script-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "65": [0, 0.7, 0.22925, 0, 0.80253],
      "66": [0, 0.7, 0.04087, 0, 0.90757],
      "67": [0, 0.7, 0.1689, 0, 0.66619],
      "68": [0, 0.7, 0.09371, 0, 0.77443],
      "69": [0, 0.7, 0.18583, 0, 0.56162],
      "70": [0, 0.7, 0.13634, 0, 0.89544],
      "71": [0, 0.7, 0.17322, 0, 0.60961],
      "72": [0, 0.7, 0.29694, 0, 0.96919],
      "73": [0, 0.7, 0.19189, 0, 0.80907],
      "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
      "75": [0, 0.7, 0.31259, 0, 0.91364],
      "76": [0, 0.7, 0.19189, 0, 0.87373],
      "77": [0, 0.7, 0.15981, 0, 1.08031],
      "78": [0, 0.7, 0.3525, 0, 0.9015],
      "79": [0, 0.7, 0.08078, 0, 0.73787],
      "80": [0, 0.7, 0.08078, 0, 1.01262],
      "81": [0, 0.7, 0.03305, 0, 0.88282],
      "82": [0, 0.7, 0.06259, 0, 0.85],
      "83": [0, 0.7, 0.19189, 0, 0.86767],
      "84": [0, 0.7, 0.29087, 0, 0.74697],
      "85": [0, 0.7, 0.25815, 0, 0.79996],
      "86": [0, 0.7, 0.27523, 0, 0.62204],
      "87": [0, 0.7, 0.27523, 0, 0.80532],
      "88": [0, 0.7, 0.26006, 0, 0.94445],
      "89": [0, 0.7, 0.2939, 0, 0.70961],
      "90": [0, 0.7, 0.24037, 0, 0.8212],
      "160": [0, 0, 0, 0, 0.25]
    },
    "Size1-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "40": [0.35001, 0.85, 0, 0, 0.45834],
      "41": [0.35001, 0.85, 0, 0, 0.45834],
      "47": [0.35001, 0.85, 0, 0, 0.57778],
      "91": [0.35001, 0.85, 0, 0, 0.41667],
      "92": [0.35001, 0.85, 0, 0, 0.57778],
      "93": [0.35001, 0.85, 0, 0, 0.41667],
      "123": [0.35001, 0.85, 0, 0, 0.58334],
      "125": [0.35001, 0.85, 0, 0, 0.58334],
      "160": [0, 0, 0, 0, 0.25],
      "710": [0, 0.72222, 0, 0, 0.55556],
      "732": [0, 0.72222, 0, 0, 0.55556],
      "770": [0, 0.72222, 0, 0, 0.55556],
      "771": [0, 0.72222, 0, 0, 0.55556],
      "8214": [-99e-5, 0.601, 0, 0, 0.77778],
      "8593": [1e-5, 0.6, 0, 0, 0.66667],
      "8595": [1e-5, 0.6, 0, 0, 0.66667],
      "8657": [1e-5, 0.6, 0, 0, 0.77778],
      "8659": [1e-5, 0.6, 0, 0, 0.77778],
      "8719": [0.25001, 0.75, 0, 0, 0.94445],
      "8720": [0.25001, 0.75, 0, 0, 0.94445],
      "8721": [0.25001, 0.75, 0, 0, 1.05556],
      "8730": [0.35001, 0.85, 0, 0, 1],
      "8739": [-599e-5, 0.606, 0, 0, 0.33333],
      "8741": [-599e-5, 0.606, 0, 0, 0.55556],
      "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
      "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
      "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
      "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
      "8896": [0.25001, 0.75, 0, 0, 0.83334],
      "8897": [0.25001, 0.75, 0, 0, 0.83334],
      "8898": [0.25001, 0.75, 0, 0, 0.83334],
      "8899": [0.25001, 0.75, 0, 0, 0.83334],
      "8968": [0.35001, 0.85, 0, 0, 0.47222],
      "8969": [0.35001, 0.85, 0, 0, 0.47222],
      "8970": [0.35001, 0.85, 0, 0, 0.47222],
      "8971": [0.35001, 0.85, 0, 0, 0.47222],
      "9168": [-99e-5, 0.601, 0, 0, 0.66667],
      "10216": [0.35001, 0.85, 0, 0, 0.47222],
      "10217": [0.35001, 0.85, 0, 0, 0.47222],
      "10752": [0.25001, 0.75, 0, 0, 1.11111],
      "10753": [0.25001, 0.75, 0, 0, 1.11111],
      "10754": [0.25001, 0.75, 0, 0, 1.11111],
      "10756": [0.25001, 0.75, 0, 0, 0.83334],
      "10758": [0.25001, 0.75, 0, 0, 0.83334]
    },
    "Size2-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "40": [0.65002, 1.15, 0, 0, 0.59722],
      "41": [0.65002, 1.15, 0, 0, 0.59722],
      "47": [0.65002, 1.15, 0, 0, 0.81111],
      "91": [0.65002, 1.15, 0, 0, 0.47222],
      "92": [0.65002, 1.15, 0, 0, 0.81111],
      "93": [0.65002, 1.15, 0, 0, 0.47222],
      "123": [0.65002, 1.15, 0, 0, 0.66667],
      "125": [0.65002, 1.15, 0, 0, 0.66667],
      "160": [0, 0, 0, 0, 0.25],
      "710": [0, 0.75, 0, 0, 1],
      "732": [0, 0.75, 0, 0, 1],
      "770": [0, 0.75, 0, 0, 1],
      "771": [0, 0.75, 0, 0, 1],
      "8719": [0.55001, 1.05, 0, 0, 1.27778],
      "8720": [0.55001, 1.05, 0, 0, 1.27778],
      "8721": [0.55001, 1.05, 0, 0, 1.44445],
      "8730": [0.65002, 1.15, 0, 0, 1],
      "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
      "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
      "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
      "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
      "8896": [0.55001, 1.05, 0, 0, 1.11111],
      "8897": [0.55001, 1.05, 0, 0, 1.11111],
      "8898": [0.55001, 1.05, 0, 0, 1.11111],
      "8899": [0.55001, 1.05, 0, 0, 1.11111],
      "8968": [0.65002, 1.15, 0, 0, 0.52778],
      "8969": [0.65002, 1.15, 0, 0, 0.52778],
      "8970": [0.65002, 1.15, 0, 0, 0.52778],
      "8971": [0.65002, 1.15, 0, 0, 0.52778],
      "10216": [0.65002, 1.15, 0, 0, 0.61111],
      "10217": [0.65002, 1.15, 0, 0, 0.61111],
      "10752": [0.55001, 1.05, 0, 0, 1.51112],
      "10753": [0.55001, 1.05, 0, 0, 1.51112],
      "10754": [0.55001, 1.05, 0, 0, 1.51112],
      "10756": [0.55001, 1.05, 0, 0, 1.11111],
      "10758": [0.55001, 1.05, 0, 0, 1.11111]
    },
    "Size3-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "40": [0.95003, 1.45, 0, 0, 0.73611],
      "41": [0.95003, 1.45, 0, 0, 0.73611],
      "47": [0.95003, 1.45, 0, 0, 1.04445],
      "91": [0.95003, 1.45, 0, 0, 0.52778],
      "92": [0.95003, 1.45, 0, 0, 1.04445],
      "93": [0.95003, 1.45, 0, 0, 0.52778],
      "123": [0.95003, 1.45, 0, 0, 0.75],
      "125": [0.95003, 1.45, 0, 0, 0.75],
      "160": [0, 0, 0, 0, 0.25],
      "710": [0, 0.75, 0, 0, 1.44445],
      "732": [0, 0.75, 0, 0, 1.44445],
      "770": [0, 0.75, 0, 0, 1.44445],
      "771": [0, 0.75, 0, 0, 1.44445],
      "8730": [0.95003, 1.45, 0, 0, 1],
      "8968": [0.95003, 1.45, 0, 0, 0.58334],
      "8969": [0.95003, 1.45, 0, 0, 0.58334],
      "8970": [0.95003, 1.45, 0, 0, 0.58334],
      "8971": [0.95003, 1.45, 0, 0, 0.58334],
      "10216": [0.95003, 1.45, 0, 0, 0.75],
      "10217": [0.95003, 1.45, 0, 0, 0.75]
    },
    "Size4-Regular": {
      "32": [0, 0, 0, 0, 0.25],
      "40": [1.25003, 1.75, 0, 0, 0.79167],
      "41": [1.25003, 1.75, 0, 0, 0.79167],
      "47": [1.25003, 1.75, 0, 0, 1.27778],
      "91": [1.25003, 1.75, 0, 0, 0.58334],
      "92": [1.25003, 1.75, 0, 0, 1.27778],
      "93": [1.25003, 1.75, 0, 0, 0.58334],
      "123": [1.25003, 1.75, 0, 0, 0.80556],
      "125": [1.25003, 1.75, 0, 0, 0.80556],
      "160": [0, 0, 0, 0, 0.25],
      "710": [0, 0.825, 0, 0, 1.8889],
      "732": [0, 0.825, 0, 0, 1.8889],
      "770": [0, 0.825, 0, 0, 1.8889],
      "771": [0, 0.825, 0, 0, 1.8889],
      "8730": [1.25003, 1.75, 0, 0, 1],
      "8968": [1.25003, 1.75, 0, 0, 0.63889],
      "8969": [1.25003, 1.75, 0, 0, 0.63889],
      "8970": [1.25003, 1.75, 0, 0, 0.63889],
      "8971": [1.25003, 1.75, 0, 0, 0.63889],
      "9115": [0.64502, 1.155, 0, 0, 0.875],
      "9116": [1e-5, 0.6, 0, 0, 0.875],
      "9117": [0.64502, 1.155, 0, 0, 0.875],
      "9118": [0.64502, 1.155, 0, 0, 0.875],
      "9119": [1e-5, 0.6, 0, 0, 0.875],
      "9120": [0.64502, 1.155, 0, 0, 0.875],
      "9121": [0.64502, 1.155, 0, 0, 0.66667],
      "9122": [-99e-5, 0.601, 0, 0, 0.66667],
      "9123": [0.64502, 1.155, 0, 0, 0.66667],
      "9124": [0.64502, 1.155, 0, 0, 0.66667],
      "9125": [-99e-5, 0.601, 0, 0, 0.66667],
      "9126": [0.64502, 1.155, 0, 0, 0.66667],
      "9127": [1e-5, 0.9, 0, 0, 0.88889],
      "9128": [0.65002, 1.15, 0, 0, 0.88889],
      "9129": [0.90001, 0, 0, 0, 0.88889],
      "9130": [0, 0.3, 0, 0, 0.88889],
      "9131": [1e-5, 0.9, 0, 0, 0.88889],
      "9132": [0.65002, 1.15, 0, 0, 0.88889],
      "9133": [0.90001, 0, 0, 0, 0.88889],
      "9143": [0.88502, 0.915, 0, 0, 1.05556],
      "10216": [1.25003, 1.75, 0, 0, 0.80556],
      "10217": [1.25003, 1.75, 0, 0, 0.80556],
      "57344": [-499e-5, 0.605, 0, 0, 1.05556],
      "57345": [-499e-5, 0.605, 0, 0, 1.05556],
      "57680": [0, 0.12, 0, 0, 0.45],
      "57681": [0, 0.12, 0, 0, 0.45],
      "57682": [0, 0.12, 0, 0, 0.45],
      "57683": [0, 0.12, 0, 0, 0.45]
    },
    "Typewriter-Regular": {
      "32": [0, 0, 0, 0, 0.525],
      "33": [0, 0.61111, 0, 0, 0.525],
      "34": [0, 0.61111, 0, 0, 0.525],
      "35": [0, 0.61111, 0, 0, 0.525],
      "36": [0.08333, 0.69444, 0, 0, 0.525],
      "37": [0.08333, 0.69444, 0, 0, 0.525],
      "38": [0, 0.61111, 0, 0, 0.525],
      "39": [0, 0.61111, 0, 0, 0.525],
      "40": [0.08333, 0.69444, 0, 0, 0.525],
      "41": [0.08333, 0.69444, 0, 0, 0.525],
      "42": [0, 0.52083, 0, 0, 0.525],
      "43": [-0.08056, 0.53055, 0, 0, 0.525],
      "44": [0.13889, 0.125, 0, 0, 0.525],
      "45": [-0.08056, 0.53055, 0, 0, 0.525],
      "46": [0, 0.125, 0, 0, 0.525],
      "47": [0.08333, 0.69444, 0, 0, 0.525],
      "48": [0, 0.61111, 0, 0, 0.525],
      "49": [0, 0.61111, 0, 0, 0.525],
      "50": [0, 0.61111, 0, 0, 0.525],
      "51": [0, 0.61111, 0, 0, 0.525],
      "52": [0, 0.61111, 0, 0, 0.525],
      "53": [0, 0.61111, 0, 0, 0.525],
      "54": [0, 0.61111, 0, 0, 0.525],
      "55": [0, 0.61111, 0, 0, 0.525],
      "56": [0, 0.61111, 0, 0, 0.525],
      "57": [0, 0.61111, 0, 0, 0.525],
      "58": [0, 0.43056, 0, 0, 0.525],
      "59": [0.13889, 0.43056, 0, 0, 0.525],
      "60": [-0.05556, 0.55556, 0, 0, 0.525],
      "61": [-0.19549, 0.41562, 0, 0, 0.525],
      "62": [-0.05556, 0.55556, 0, 0, 0.525],
      "63": [0, 0.61111, 0, 0, 0.525],
      "64": [0, 0.61111, 0, 0, 0.525],
      "65": [0, 0.61111, 0, 0, 0.525],
      "66": [0, 0.61111, 0, 0, 0.525],
      "67": [0, 0.61111, 0, 0, 0.525],
      "68": [0, 0.61111, 0, 0, 0.525],
      "69": [0, 0.61111, 0, 0, 0.525],
      "70": [0, 0.61111, 0, 0, 0.525],
      "71": [0, 0.61111, 0, 0, 0.525],
      "72": [0, 0.61111, 0, 0, 0.525],
      "73": [0, 0.61111, 0, 0, 0.525],
      "74": [0, 0.61111, 0, 0, 0.525],
      "75": [0, 0.61111, 0, 0, 0.525],
      "76": [0, 0.61111, 0, 0, 0.525],
      "77": [0, 0.61111, 0, 0, 0.525],
      "78": [0, 0.61111, 0, 0, 0.525],
      "79": [0, 0.61111, 0, 0, 0.525],
      "80": [0, 0.61111, 0, 0, 0.525],
      "81": [0.13889, 0.61111, 0, 0, 0.525],
      "82": [0, 0.61111, 0, 0, 0.525],
      "83": [0, 0.61111, 0, 0, 0.525],
      "84": [0, 0.61111, 0, 0, 0.525],
      "85": [0, 0.61111, 0, 0, 0.525],
      "86": [0, 0.61111, 0, 0, 0.525],
      "87": [0, 0.61111, 0, 0, 0.525],
      "88": [0, 0.61111, 0, 0, 0.525],
      "89": [0, 0.61111, 0, 0, 0.525],
      "90": [0, 0.61111, 0, 0, 0.525],
      "91": [0.08333, 0.69444, 0, 0, 0.525],
      "92": [0.08333, 0.69444, 0, 0, 0.525],
      "93": [0.08333, 0.69444, 0, 0, 0.525],
      "94": [0, 0.61111, 0, 0, 0.525],
      "95": [0.09514, 0, 0, 0, 0.525],
      "96": [0, 0.61111, 0, 0, 0.525],
      "97": [0, 0.43056, 0, 0, 0.525],
      "98": [0, 0.61111, 0, 0, 0.525],
      "99": [0, 0.43056, 0, 0, 0.525],
      "100": [0, 0.61111, 0, 0, 0.525],
      "101": [0, 0.43056, 0, 0, 0.525],
      "102": [0, 0.61111, 0, 0, 0.525],
      "103": [0.22222, 0.43056, 0, 0, 0.525],
      "104": [0, 0.61111, 0, 0, 0.525],
      "105": [0, 0.61111, 0, 0, 0.525],
      "106": [0.22222, 0.61111, 0, 0, 0.525],
      "107": [0, 0.61111, 0, 0, 0.525],
      "108": [0, 0.61111, 0, 0, 0.525],
      "109": [0, 0.43056, 0, 0, 0.525],
      "110": [0, 0.43056, 0, 0, 0.525],
      "111": [0, 0.43056, 0, 0, 0.525],
      "112": [0.22222, 0.43056, 0, 0, 0.525],
      "113": [0.22222, 0.43056, 0, 0, 0.525],
      "114": [0, 0.43056, 0, 0, 0.525],
      "115": [0, 0.43056, 0, 0, 0.525],
      "116": [0, 0.55358, 0, 0, 0.525],
      "117": [0, 0.43056, 0, 0, 0.525],
      "118": [0, 0.43056, 0, 0, 0.525],
      "119": [0, 0.43056, 0, 0, 0.525],
      "120": [0, 0.43056, 0, 0, 0.525],
      "121": [0.22222, 0.43056, 0, 0, 0.525],
      "122": [0, 0.43056, 0, 0, 0.525],
      "123": [0.08333, 0.69444, 0, 0, 0.525],
      "124": [0.08333, 0.69444, 0, 0, 0.525],
      "125": [0.08333, 0.69444, 0, 0, 0.525],
      "126": [0, 0.61111, 0, 0, 0.525],
      "127": [0, 0.61111, 0, 0, 0.525],
      "160": [0, 0, 0, 0, 0.525],
      "176": [0, 0.61111, 0, 0, 0.525],
      "184": [0.19445, 0, 0, 0, 0.525],
      "305": [0, 0.43056, 0, 0, 0.525],
      "567": [0.22222, 0.43056, 0, 0, 0.525],
      "711": [0, 0.56597, 0, 0, 0.525],
      "713": [0, 0.56555, 0, 0, 0.525],
      "714": [0, 0.61111, 0, 0, 0.525],
      "715": [0, 0.61111, 0, 0, 0.525],
      "728": [0, 0.61111, 0, 0, 0.525],
      "730": [0, 0.61111, 0, 0, 0.525],
      "770": [0, 0.61111, 0, 0, 0.525],
      "771": [0, 0.61111, 0, 0, 0.525],
      "776": [0, 0.61111, 0, 0, 0.525],
      "915": [0, 0.61111, 0, 0, 0.525],
      "916": [0, 0.61111, 0, 0, 0.525],
      "920": [0, 0.61111, 0, 0, 0.525],
      "923": [0, 0.61111, 0, 0, 0.525],
      "926": [0, 0.61111, 0, 0, 0.525],
      "928": [0, 0.61111, 0, 0, 0.525],
      "931": [0, 0.61111, 0, 0, 0.525],
      "933": [0, 0.61111, 0, 0, 0.525],
      "934": [0, 0.61111, 0, 0, 0.525],
      "936": [0, 0.61111, 0, 0, 0.525],
      "937": [0, 0.61111, 0, 0, 0.525],
      "8216": [0, 0.61111, 0, 0, 0.525],
      "8217": [0, 0.61111, 0, 0, 0.525],
      "8242": [0, 0.61111, 0, 0, 0.525],
      "9251": [0.11111, 0.21944, 0, 0, 0.525]
    }
  };
  var sigmasAndXis = {
    slant: [0.25, 0.25, 0.25],
    // sigma1
    space: [0, 0, 0],
    // sigma2
    stretch: [0, 0, 0],
    // sigma3
    shrink: [0, 0, 0],
    // sigma4
    xHeight: [0.431, 0.431, 0.431],
    // sigma5
    quad: [1, 1.171, 1.472],
    // sigma6
    extraSpace: [0, 0, 0],
    // sigma7
    num1: [0.677, 0.732, 0.925],
    // sigma8
    num2: [0.394, 0.384, 0.387],
    // sigma9
    num3: [0.444, 0.471, 0.504],
    // sigma10
    denom1: [0.686, 0.752, 1.025],
    // sigma11
    denom2: [0.345, 0.344, 0.532],
    // sigma12
    sup1: [0.413, 0.503, 0.504],
    // sigma13
    sup2: [0.363, 0.431, 0.404],
    // sigma14
    sup3: [0.289, 0.286, 0.294],
    // sigma15
    sub1: [0.15, 0.143, 0.2],
    // sigma16
    sub2: [0.247, 0.286, 0.4],
    // sigma17
    supDrop: [0.386, 0.353, 0.494],
    // sigma18
    subDrop: [0.05, 0.071, 0.1],
    // sigma19
    delim1: [2.39, 1.7, 1.98],
    // sigma20
    delim2: [1.01, 1.157, 1.42],
    // sigma21
    axisHeight: [0.25, 0.25, 0.25],
    // sigma22
    // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
    // they correspond to the font parameters of the extension fonts (family 3).
    // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
    // match cmex7, we'd use cmex7.tfm values for script and scriptscript
    // values.
    defaultRuleThickness: [0.04, 0.049, 0.049],
    // xi8; cmex7: 0.049
    bigOpSpacing1: [0.111, 0.111, 0.111],
    // xi9
    bigOpSpacing2: [0.166, 0.166, 0.166],
    // xi10
    bigOpSpacing3: [0.2, 0.2, 0.2],
    // xi11
    bigOpSpacing4: [0.6, 0.611, 0.611],
    // xi12; cmex7: 0.611
    bigOpSpacing5: [0.1, 0.143, 0.143],
    // xi13; cmex7: 0.143
    // The \sqrt rule width is taken from the height of the surd character.
    // Since we use the same font at all sizes, this thickness doesn't scale.
    sqrtRuleThickness: [0.04, 0.04, 0.04],
    // This value determines how large a pt is, for metrics which are defined
    // in terms of pts.
    // This value is also used in katex.scss; if you change it make sure the
    // values match.
    ptPerEm: [10, 10, 10],
    // The space between adjacent `|` columns in an array definition. From
    // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
    doubleRuleSep: [0.2, 0.2, 0.2],
    // The width of separator lines in {array} environments. From
    // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
    arrayRuleWidth: [0.04, 0.04, 0.04],
    // Two values from LaTeX source2e:
    fboxsep: [0.3, 0.3, 0.3],
    //        3 pt / ptPerEm
    fboxrule: [0.04, 0.04, 0.04]
    // 0.4 pt / ptPerEm
  };
  var extraCharacterMap = {
    // Latin-1
    "\xC5": "A",
    "\xD0": "D",
    "\xDE": "o",
    "\xE5": "a",
    "\xF0": "d",
    "\xFE": "o",
    // Cyrillic
    "\u0410": "A",
    "\u0411": "B",
    "\u0412": "B",
    "\u0413": "F",
    "\u0414": "A",
    "\u0415": "E",
    "\u0416": "K",
    "\u0417": "3",
    "\u0418": "N",
    "\u0419": "N",
    "\u041A": "K",
    "\u041B": "N",
    "\u041C": "M",
    "\u041D": "H",
    "\u041E": "O",
    "\u041F": "N",
    "\u0420": "P",
    "\u0421": "C",
    "\u0422": "T",
    "\u0423": "y",
    "\u0424": "O",
    "\u0425": "X",
    "\u0426": "U",
    "\u0427": "h",
    "\u0428": "W",
    "\u0429": "W",
    "\u042A": "B",
    "\u042B": "X",
    "\u042C": "B",
    "\u042D": "3",
    "\u042E": "X",
    "\u042F": "R",
    "\u0430": "a",
    "\u0431": "b",
    "\u0432": "a",
    "\u0433": "r",
    "\u0434": "y",
    "\u0435": "e",
    "\u0436": "m",
    "\u0437": "e",
    "\u0438": "n",
    "\u0439": "n",
    "\u043A": "n",
    "\u043B": "n",
    "\u043C": "m",
    "\u043D": "n",
    "\u043E": "o",
    "\u043F": "n",
    "\u0440": "p",
    "\u0441": "c",
    "\u0442": "o",
    "\u0443": "y",
    "\u0444": "b",
    "\u0445": "x",
    "\u0446": "n",
    "\u0447": "n",
    "\u0448": "w",
    "\u0449": "w",
    "\u044A": "a",
    "\u044B": "m",
    "\u044C": "a",
    "\u044D": "e",
    "\u044E": "m",
    "\u044F": "r"
  };
  function setFontMetrics(fontName, metrics) {
    fontMetricsData[fontName] = metrics;
  }
  function getCharacterMetrics(character, font, mode) {
    if (!fontMetricsData[font]) {
      throw new Error("Font metrics not found for font: " + font + ".");
    }
    var ch = character.charCodeAt(0);
    var metrics = fontMetricsData[font][ch];
    if (!metrics && character[0] in extraCharacterMap) {
      ch = extraCharacterMap[character[0]].charCodeAt(0);
      metrics = fontMetricsData[font][ch];
    }
    if (!metrics && mode === "text") {
      if (supportedCodepoint(ch)) {
        metrics = fontMetricsData[font][77];
      }
    }
    if (metrics) {
      return {
        depth: metrics[0],
        height: metrics[1],
        italic: metrics[2],
        skew: metrics[3],
        width: metrics[4]
      };
    }
  }
  var fontMetricsBySizeIndex = {};
  function getGlobalMetrics(size) {
    var sizeIndex;
    if (size >= 5) {
      sizeIndex = 0;
    } else if (size >= 3) {
      sizeIndex = 1;
    } else {
      sizeIndex = 2;
    }
    if (!fontMetricsBySizeIndex[sizeIndex]) {
      var metrics = fontMetricsBySizeIndex[sizeIndex] = {
        cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
      };
      for (var key in sigmasAndXis) {
        if (sigmasAndXis.hasOwnProperty(key)) {
          metrics[key] = sigmasAndXis[key][sizeIndex];
        }
      }
    }
    return fontMetricsBySizeIndex[sizeIndex];
  }
  var sizeStyleMap = [
    // Each element contains [textsize, scriptsize, scriptscriptsize].
    // The size mappings are taken from TeX with \normalsize=10pt.
    [1, 1, 1],
    // size1: [5, 5, 5]              \tiny
    [2, 1, 1],
    // size2: [6, 5, 5]
    [3, 1, 1],
    // size3: [7, 5, 5]              \scriptsize
    [4, 2, 1],
    // size4: [8, 6, 5]              \footnotesize
    [5, 2, 1],
    // size5: [9, 6, 5]              \small
    [6, 3, 1],
    // size6: [10, 7, 5]             \normalsize
    [7, 4, 2],
    // size7: [12, 8, 6]             \large
    [8, 6, 3],
    // size8: [14.4, 10, 7]          \Large
    [9, 7, 6],
    // size9: [17.28, 12, 10]        \LARGE
    [10, 8, 7],
    // size10: [20.74, 14.4, 12]     \huge
    [11, 10, 9]
    // size11: [24.88, 20.74, 17.28] \HUGE
  ];
  var sizeMultipliers = [
    // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
    // you change size indexes, change that function.
    0.5,
    0.6,
    0.7,
    0.8,
    0.9,
    1,
    1.2,
    1.44,
    1.728,
    2.074,
    2.488
  ];
  var sizeAtStyle = function sizeAtStyle2(size, style) {
    return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
  };
  var Options = class _Options {
    // A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    /**
     * The base size index.
     */
    constructor(data) {
      this.style = void 0;
      this.color = void 0;
      this.size = void 0;
      this.textSize = void 0;
      this.phantom = void 0;
      this.font = void 0;
      this.fontFamily = void 0;
      this.fontWeight = void 0;
      this.fontShape = void 0;
      this.sizeMultiplier = void 0;
      this.maxSize = void 0;
      this.minRuleThickness = void 0;
      this._fontMetrics = void 0;
      this.style = data.style;
      this.color = data.color;
      this.size = data.size || _Options.BASESIZE;
      this.textSize = data.textSize || this.size;
      this.phantom = !!data.phantom;
      this.font = data.font || "";
      this.fontFamily = data.fontFamily || "";
      this.fontWeight = data.fontWeight || "";
      this.fontShape = data.fontShape || "";
      this.sizeMultiplier = sizeMultipliers[this.size - 1];
      this.maxSize = data.maxSize;
      this.minRuleThickness = data.minRuleThickness;
      this._fontMetrics = void 0;
    }
    /**
     * Returns a new options object with the same properties as "this".  Properties
     * from "extension" will be copied to the new options object.
     */
    extend(extension) {
      var data = {
        style: this.style,
        size: this.size,
        textSize: this.textSize,
        color: this.color,
        phantom: this.phantom,
        font: this.font,
        fontFamily: this.fontFamily,
        fontWeight: this.fontWeight,
        fontShape: this.fontShape,
        maxSize: this.maxSize,
        minRuleThickness: this.minRuleThickness
      };
      for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
          data[key] = extension[key];
        }
      }
      return new _Options(data);
    }
    /**
     * Return an options object with the given style. If `this.style === style`,
     * returns `this`.
     */
    havingStyle(style) {
      if (this.style === style) {
        return this;
      } else {
        return this.extend({
          style,
          size: sizeAtStyle(this.textSize, style)
        });
      }
    }
    /**
     * Return an options object with a cramped version of the current style. If
     * the current style is cramped, returns `this`.
     */
    havingCrampedStyle() {
      return this.havingStyle(this.style.cramp());
    }
    /**
     * Return an options object with the given size and in at least `\textstyle`.
     * Returns `this` if appropriate.
     */
    havingSize(size) {
      if (this.size === size && this.textSize === size) {
        return this;
      } else {
        return this.extend({
          style: this.style.text(),
          size,
          textSize: size,
          sizeMultiplier: sizeMultipliers[size - 1]
        });
      }
    }
    /**
     * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
     * changes to at least `\textstyle`.
     */
    havingBaseStyle(style) {
      style = style || this.style.text();
      var wantSize = sizeAtStyle(_Options.BASESIZE, style);
      if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style) {
        return this;
      } else {
        return this.extend({
          style,
          size: wantSize
        });
      }
    }
    /**
     * Remove the effect of sizing changes such as \Huge.
     * Keep the effect of the current style, such as \scriptstyle.
     */
    havingBaseSizing() {
      var size;
      switch (this.style.id) {
        case 4:
        case 5:
          size = 3;
          break;
        case 6:
        case 7:
          size = 1;
          break;
        default:
          size = 6;
      }
      return this.extend({
        style: this.style.text(),
        size
      });
    }
    /**
     * Create a new options object with the given color.
     */
    withColor(color) {
      return this.extend({
        color
      });
    }
    /**
     * Create a new options object with "phantom" set to true.
     */
    withPhantom() {
      return this.extend({
        phantom: true
      });
    }
    /**
     * Creates a new options object with the given math font or old text font.
     * @type {[type]}
     */
    withFont(font) {
      return this.extend({
        font
      });
    }
    /**
     * Create a new options objects with the given fontFamily.
     */
    withTextFontFamily(fontFamily) {
      return this.extend({
        fontFamily,
        font: ""
      });
    }
    /**
     * Creates a new options object with the given font weight
     */
    withTextFontWeight(fontWeight) {
      return this.extend({
        fontWeight,
        font: ""
      });
    }
    /**
     * Creates a new options object with the given font weight
     */
    withTextFontShape(fontShape) {
      return this.extend({
        fontShape,
        font: ""
      });
    }
    /**
     * Return the CSS sizing classes required to switch from enclosing options
     * `oldOptions` to `this`. Returns an array of classes.
     */
    sizingClasses(oldOptions) {
      if (oldOptions.size !== this.size) {
        return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
      } else {
        return [];
      }
    }
    /**
     * Return the CSS sizing classes required to switch to the base size. Like
     * `this.havingSize(BASESIZE).sizingClasses(this)`.
     */
    baseSizingClasses() {
      if (this.size !== _Options.BASESIZE) {
        return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
      } else {
        return [];
      }
    }
    /**
     * Return the font metrics for this size.
     */
    fontMetrics() {
      if (!this._fontMetrics) {
        this._fontMetrics = getGlobalMetrics(this.size);
      }
      return this._fontMetrics;
    }
    /**
     * Gets the CSS color of the current options object
     */
    getColor() {
      if (this.phantom) {
        return "transparent";
      } else {
        return this.color;
      }
    }
  };
  Options.BASESIZE = 6;
  var ptPerUnit = {
    // https://en.wikibooks.org/wiki/LaTeX/Lengths and
    // https://tex.stackexchange.com/a/8263
    "pt": 1,
    // TeX point
    "mm": 7227 / 2540,
    // millimeter
    "cm": 7227 / 254,
    // centimeter
    "in": 72.27,
    // inch
    "bp": 803 / 800,
    // big (PostScript) points
    "pc": 12,
    // pica
    "dd": 1238 / 1157,
    // didot
    "cc": 14856 / 1157,
    // cicero (12 didot)
    "nd": 685 / 642,
    // new didot
    "nc": 1370 / 107,
    // new cicero (12 new didot)
    "sp": 1 / 65536,
    // scaled point (TeX's internal smallest unit)
    // https://tex.stackexchange.com/a/41371
    "px": 803 / 800
    // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
  };
  var relativeUnit = {
    "ex": true,
    "em": true,
    "mu": true
  };
  var validUnit = function validUnit2(unit) {
    if (typeof unit !== "string") {
      unit = unit.unit;
    }
    return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
  };
  var calculateSize = function calculateSize2(sizeValue, options) {
    var scale;
    if (sizeValue.unit in ptPerUnit) {
      scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
    } else if (sizeValue.unit === "mu") {
      scale = options.fontMetrics().cssEmPerMu;
    } else {
      var unitOptions;
      if (options.style.isTight()) {
        unitOptions = options.havingStyle(options.style.text());
      } else {
        unitOptions = options;
      }
      if (sizeValue.unit === "ex") {
        scale = unitOptions.fontMetrics().xHeight;
      } else if (sizeValue.unit === "em") {
        scale = unitOptions.fontMetrics().quad;
      } else {
        throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
      }
      if (unitOptions !== options) {
        scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    return Math.min(sizeValue.number * scale, options.maxSize);
  };
  var makeEm = function makeEm2(n3) {
    return +n3.toFixed(4) + "em";
  };
  var createClass = function createClass2(classes) {
    return classes.filter((cls) => cls).join(" ");
  };
  var initNode = function initNode2(classes, options, style) {
    this.classes = classes || [];
    this.attributes = {};
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = style || {};
    if (options) {
      if (options.style.isTight()) {
        this.classes.push("mtight");
      }
      var color = options.getColor();
      if (color) {
        this.style.color = color;
      }
    }
  };
  var toNode = function toNode2(tagName) {
    var node = document.createElement(tagName);
    node.className = createClass(this.classes);
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node.style[style] = this.style[style];
      }
    }
    for (var attr in this.attributes) {
      if (this.attributes.hasOwnProperty(attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    for (var i4 = 0; i4 < this.children.length; i4++) {
      node.appendChild(this.children[i4].toNode());
    }
    return node;
  };
  var invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
  var toMarkup = function toMarkup2(tagName) {
    var markup = "<" + tagName;
    if (this.classes.length) {
      markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
    }
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    for (var attr in this.attributes) {
      if (this.attributes.hasOwnProperty(attr)) {
        if (invalidAttributeNameRegex.test(attr)) {
          throw new ParseError("Invalid attribute name '" + attr + "'");
        }
        markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
      }
    }
    markup += ">";
    for (var i4 = 0; i4 < this.children.length; i4++) {
      markup += this.children[i4].toMarkup();
    }
    markup += "</" + tagName + ">";
    return markup;
  };
  var Span = class {
    constructor(classes, children, options, style) {
      this.children = void 0;
      this.attributes = void 0;
      this.classes = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.width = void 0;
      this.maxFontSize = void 0;
      this.style = void 0;
      initNode.call(this, classes, options, style);
      this.children = children || [];
    }
    /**
     * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
     * all browsers support attributes the same, and having too many custom
     * attributes is probably bad.
     */
    setAttribute(attribute, value) {
      this.attributes[attribute] = value;
    }
    hasClass(className) {
      return utils.contains(this.classes, className);
    }
    toNode() {
      return toNode.call(this, "span");
    }
    toMarkup() {
      return toMarkup.call(this, "span");
    }
  };
  var Anchor = class {
    constructor(href, classes, children, options) {
      this.children = void 0;
      this.attributes = void 0;
      this.classes = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.maxFontSize = void 0;
      this.style = void 0;
      initNode.call(this, classes, options);
      this.children = children || [];
      this.setAttribute("href", href);
    }
    setAttribute(attribute, value) {
      this.attributes[attribute] = value;
    }
    hasClass(className) {
      return utils.contains(this.classes, className);
    }
    toNode() {
      return toNode.call(this, "a");
    }
    toMarkup() {
      return toMarkup.call(this, "a");
    }
  };
  var Img = class {
    constructor(src, alt, style) {
      this.src = void 0;
      this.alt = void 0;
      this.classes = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.maxFontSize = void 0;
      this.style = void 0;
      this.alt = alt;
      this.src = src;
      this.classes = ["mord"];
      this.style = style;
    }
    hasClass(className) {
      return utils.contains(this.classes, className);
    }
    toNode() {
      var node = document.createElement("img");
      node.src = this.src;
      node.alt = this.alt;
      node.className = "mord";
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          node.style[style] = this.style[style];
        }
      }
      return node;
    }
    toMarkup() {
      var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
      var styles2 = "";
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }
      if (styles2) {
        markup += ' style="' + utils.escape(styles2) + '"';
      }
      markup += "'/>";
      return markup;
    }
  };
  var iCombinations = {
    "\xEE": "\u0131\u0302",
    "\xEF": "\u0131\u0308",
    "\xED": "\u0131\u0301",
    // '': '\u0131\u0304', // enable when we add Extended Latin
    "\xEC": "\u0131\u0300"
  };
  var SymbolNode = class {
    constructor(text2, height, depth, italic, skew, width, classes, style) {
      this.text = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.italic = void 0;
      this.skew = void 0;
      this.width = void 0;
      this.maxFontSize = void 0;
      this.classes = void 0;
      this.style = void 0;
      this.text = text2;
      this.height = height || 0;
      this.depth = depth || 0;
      this.italic = italic || 0;
      this.skew = skew || 0;
      this.width = width || 0;
      this.classes = classes || [];
      this.style = style || {};
      this.maxFontSize = 0;
      var script = scriptFromCodepoint(this.text.charCodeAt(0));
      if (script) {
        this.classes.push(script + "_fallback");
      }
      if (/[]/.test(this.text)) {
        this.text = iCombinations[this.text];
      }
    }
    hasClass(className) {
      return utils.contains(this.classes, className);
    }
    /**
     * Creates a text node or span from a symbol node. Note that a span is only
     * created if it is needed.
     */
    toNode() {
      var node = document.createTextNode(this.text);
      var span = null;
      if (this.italic > 0) {
        span = document.createElement("span");
        span.style.marginRight = makeEm(this.italic);
      }
      if (this.classes.length > 0) {
        span = span || document.createElement("span");
        span.className = createClass(this.classes);
      }
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          span = span || document.createElement("span");
          span.style[style] = this.style[style];
        }
      }
      if (span) {
        span.appendChild(node);
        return span;
      } else {
        return node;
      }
    }
    /**
     * Creates markup for a symbol node.
     */
    toMarkup() {
      var needsSpan = false;
      var markup = "<span";
      if (this.classes.length) {
        needsSpan = true;
        markup += ' class="';
        markup += utils.escape(createClass(this.classes));
        markup += '"';
      }
      var styles2 = "";
      if (this.italic > 0) {
        styles2 += "margin-right:" + this.italic + "em;";
      }
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }
      if (styles2) {
        needsSpan = true;
        markup += ' style="' + utils.escape(styles2) + '"';
      }
      var escaped = utils.escape(this.text);
      if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
      } else {
        return escaped;
      }
    }
  };
  var SvgNode = class {
    constructor(children, attributes) {
      this.children = void 0;
      this.attributes = void 0;
      this.children = children || [];
      this.attributes = attributes || {};
    }
    toNode() {
      var svgNS = "http://www.w3.org/2000/svg";
      var node = document.createElementNS(svgNS, "svg");
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      }
      for (var i4 = 0; i4 < this.children.length; i4++) {
        node.appendChild(this.children[i4].toNode());
      }
      return node;
    }
    toMarkup() {
      var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
        }
      }
      markup += ">";
      for (var i4 = 0; i4 < this.children.length; i4++) {
        markup += this.children[i4].toMarkup();
      }
      markup += "</svg>";
      return markup;
    }
  };
  var PathNode = class {
    constructor(pathName, alternate) {
      this.pathName = void 0;
      this.alternate = void 0;
      this.pathName = pathName;
      this.alternate = alternate;
    }
    toNode() {
      var svgNS = "http://www.w3.org/2000/svg";
      var node = document.createElementNS(svgNS, "path");
      if (this.alternate) {
        node.setAttribute("d", this.alternate);
      } else {
        node.setAttribute("d", path[this.pathName]);
      }
      return node;
    }
    toMarkup() {
      if (this.alternate) {
        return '<path d="' + utils.escape(this.alternate) + '"/>';
      } else {
        return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
      }
    }
  };
  var LineNode = class {
    constructor(attributes) {
      this.attributes = void 0;
      this.attributes = attributes || {};
    }
    toNode() {
      var svgNS = "http://www.w3.org/2000/svg";
      var node = document.createElementNS(svgNS, "line");
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      }
      return node;
    }
    toMarkup() {
      var markup = "<line";
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
        }
      }
      markup += "/>";
      return markup;
    }
  };
  function assertSymbolDomNode(group) {
    if (group instanceof SymbolNode) {
      return group;
    } else {
      throw new Error("Expected symbolNode but got " + String(group) + ".");
    }
  }
  function assertSpan(group) {
    if (group instanceof Span) {
      return group;
    } else {
      throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
    }
  }
  var ATOMS = {
    "bin": 1,
    "close": 1,
    "inner": 1,
    "open": 1,
    "punct": 1,
    "rel": 1
  };
  var NON_ATOMS = {
    "accent-token": 1,
    "mathord": 1,
    "op-token": 1,
    "spacing": 1,
    "textord": 1
  };
  var symbols = {
    "math": {},
    "text": {}
  };
  function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
    symbols[mode][name] = {
      font,
      group,
      replace
    };
    if (acceptUnicodeChar && replace) {
      symbols[mode][replace] = symbols[mode][name];
    }
  }
  var math = "math";
  var text = "text";
  var main = "main";
  var ams = "ams";
  var accent = "accent-token";
  var bin = "bin";
  var close = "close";
  var inner = "inner";
  var mathord = "mathord";
  var op = "op-token";
  var open = "open";
  var punct = "punct";
  var rel = "rel";
  var spacing = "spacing";
  var textord = "textord";
  defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
  defineSymbol(math, main, rel, "\u227A", "\\prec", true);
  defineSymbol(math, main, rel, "\u227B", "\\succ", true);
  defineSymbol(math, main, rel, "\u223C", "\\sim", true);
  defineSymbol(math, main, rel, "\u22A5", "\\perp");
  defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
  defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
  defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
  defineSymbol(math, main, rel, "\u2223", "\\mid", true);
  defineSymbol(math, main, rel, "\u226A", "\\ll", true);
  defineSymbol(math, main, rel, "\u226B", "\\gg", true);
  defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
  defineSymbol(math, main, rel, "\u2225", "\\parallel");
  defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
  defineSymbol(math, main, rel, "\u2323", "\\smile", true);
  defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
  defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
  defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
  defineSymbol(math, main, rel, "\u2322", "\\frown", true);
  defineSymbol(math, main, rel, "\u220B", "\\ni", true);
  defineSymbol(math, main, rel, "\u221D", "\\propto", true);
  defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
  defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
  defineSymbol(math, main, rel, "\u220B", "\\owns");
  defineSymbol(math, main, punct, ".", "\\ldotp");
  defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
  defineSymbol(math, main, textord, "#", "\\#");
  defineSymbol(text, main, textord, "#", "\\#");
  defineSymbol(math, main, textord, "&", "\\&");
  defineSymbol(text, main, textord, "&", "\\&");
  defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
  defineSymbol(math, main, textord, "\u2200", "\\forall", true);
  defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
  defineSymbol(math, main, textord, "\u2203", "\\exists", true);
  defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
  defineSymbol(math, main, textord, "\u266D", "\\flat", true);
  defineSymbol(math, main, textord, "\u2113", "\\ell", true);
  defineSymbol(math, main, textord, "\u266E", "\\natural", true);
  defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
  defineSymbol(math, main, textord, "\u2118", "\\wp", true);
  defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
  defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
  defineSymbol(math, main, textord, "\u211C", "\\Re", true);
  defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
  defineSymbol(math, main, textord, "\u2111", "\\Im", true);
  defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
  defineSymbol(math, main, textord, "\xA7", "\\S", true);
  defineSymbol(text, main, textord, "\xA7", "\\S");
  defineSymbol(math, main, textord, "\xB6", "\\P", true);
  defineSymbol(text, main, textord, "\xB6", "\\P");
  defineSymbol(math, main, textord, "\u2020", "\\dag");
  defineSymbol(text, main, textord, "\u2020", "\\dag");
  defineSymbol(text, main, textord, "\u2020", "\\textdagger");
  defineSymbol(math, main, textord, "\u2021", "\\ddag");
  defineSymbol(text, main, textord, "\u2021", "\\ddag");
  defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
  defineSymbol(math, main, close, "\u23B1", "\\rmoustache", true);
  defineSymbol(math, main, open, "\u23B0", "\\lmoustache", true);
  defineSymbol(math, main, close, "\u27EF", "\\rgroup", true);
  defineSymbol(math, main, open, "\u27EE", "\\lgroup", true);
  defineSymbol(math, main, bin, "\u2213", "\\mp", true);
  defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
  defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
  defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
  defineSymbol(math, main, bin, "\u2217", "\\ast");
  defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
  defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
  defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
  defineSymbol(math, main, bin, "\u2021", "\\ddagger");
  defineSymbol(math, main, bin, "\u2240", "\\wr", true);
  defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
  defineSymbol(math, main, bin, "&", "\\And");
  defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
  defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
  defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
  defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
  defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
  defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
  defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
  defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
  defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
  defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
  defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
  defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
  defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
  defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
  defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
  defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
  defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
  defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
  defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
  defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
  defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
  defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
  defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
  defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
  defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
  defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
  defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
  defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
  defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
  defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
  defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
  defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
  defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
  defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
  defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
  defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
  defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
  defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
  defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
  defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
  defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
  defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
  defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
  defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
  defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
  defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
  defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
  defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
  defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
  defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
  defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
  defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
  defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
  defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
  defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
  defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
  defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
  defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
  defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
  defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
  defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
  defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
  defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
  defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
  defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
  defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
  defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
  defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
  defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
  defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
  defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
  defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
  defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
  defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
  defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
  defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
  defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
  defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
  defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
  defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
  defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
  defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
  defineSymbol(math, ams, textord, "\u210F", "\\hslash");
  defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
  defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
  defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
  defineSymbol(math, ams, textord, "\xAE", "\\circledR");
  defineSymbol(text, ams, textord, "\xAE", "\\circledR");
  defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
  defineSymbol(math, ams, textord, "\u2204", "\\nexists");
  defineSymbol(math, ams, textord, "\u2127", "\\mho");
  defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
  defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
  defineSymbol(math, ams, textord, "\u2035", "\\backprime");
  defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
  defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
  defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
  defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
  defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
  defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
  defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
  defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
  defineSymbol(text, main, textord, "\xF0", "\xF0");
  defineSymbol(math, ams, textord, "\u2571", "\\diagup");
  defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
  defineSymbol(math, ams, textord, "\u25A1", "\\square");
  defineSymbol(math, ams, textord, "\u25A1", "\\Box");
  defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
  defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
  defineSymbol(text, ams, textord, "\xA5", "\\yen", true);
  defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
  defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
  defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
  defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
  defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
  defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
  defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
  defineSymbol(math, ams, open, "\u250C", "\\@ulcorner", true);
  defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
  defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
  defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
  defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
  defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
  defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
  defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
  defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
  defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
  defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
  defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
  defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
  defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
  defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
  defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
  defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
  defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
  defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
  defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
  defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
  defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
  defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
  defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
  defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
  defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
  defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
  defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
  defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
  defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
  defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
  defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
  defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
  defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
  defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
  defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
  defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
  defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
  defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
  defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
  defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
  defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
  defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
  defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
  defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
  defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
  defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
  defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
  defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
  defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
  defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
  defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
  defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
  defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
  defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
  defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
  defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
  defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
  defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
  defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
  defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
  defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
  defineSymbol(math, ams, rel, "\u226C", "\\between", true);
  defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
  defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
  defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
  defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
  defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
  defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
  defineSymbol(math, ams, rel, "\u2235", "\\because", true);
  defineSymbol(math, ams, rel, "\u22D8", "\\llless");
  defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
  defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
  defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
  defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
  defineSymbol(math, main, rel, "\u22C8", "\\Join");
  defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
  defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
  defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
  defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
  defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
  defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
  defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
  defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
  defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
  defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
  defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
  defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
  defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
  defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
  defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
  defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
  defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
  defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
  defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
  defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
  defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
  defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
  defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
  defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
  defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
  defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
  defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
  defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
  defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
  defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
  defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
  defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
  defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
  defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
  defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
  defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
  defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
  defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
  defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
  defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
  defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
  defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
  defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
  defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
  defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
  defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
  defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
  defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
  defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
  defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
  defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
  defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
  defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
  defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
  defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
  defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
  defineSymbol(math, main, textord, "\u2018", "`");
  defineSymbol(math, main, textord, "$", "\\$");
  defineSymbol(text, main, textord, "$", "\\$");
  defineSymbol(text, main, textord, "$", "\\textdollar");
  defineSymbol(math, main, textord, "%", "\\%");
  defineSymbol(text, main, textord, "%", "\\%");
  defineSymbol(math, main, textord, "_", "\\_");
  defineSymbol(text, main, textord, "_", "\\_");
  defineSymbol(text, main, textord, "_", "\\textunderscore");
  defineSymbol(math, main, textord, "\u2220", "\\angle", true);
  defineSymbol(math, main, textord, "\u221E", "\\infty", true);
  defineSymbol(math, main, textord, "\u2032", "\\prime");
  defineSymbol(math, main, textord, "\u25B3", "\\triangle");
  defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
  defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
  defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
  defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
  defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
  defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
  defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
  defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
  defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
  defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
  defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
  defineSymbol(math, main, textord, "A", "\u0391");
  defineSymbol(math, main, textord, "B", "\u0392");
  defineSymbol(math, main, textord, "E", "\u0395");
  defineSymbol(math, main, textord, "Z", "\u0396");
  defineSymbol(math, main, textord, "H", "\u0397");
  defineSymbol(math, main, textord, "I", "\u0399");
  defineSymbol(math, main, textord, "K", "\u039A");
  defineSymbol(math, main, textord, "M", "\u039C");
  defineSymbol(math, main, textord, "N", "\u039D");
  defineSymbol(math, main, textord, "O", "\u039F");
  defineSymbol(math, main, textord, "P", "\u03A1");
  defineSymbol(math, main, textord, "T", "\u03A4");
  defineSymbol(math, main, textord, "X", "\u03A7");
  defineSymbol(math, main, textord, "\xAC", "\\neg", true);
  defineSymbol(math, main, textord, "\xAC", "\\lnot");
  defineSymbol(math, main, textord, "\u22A4", "\\top");
  defineSymbol(math, main, textord, "\u22A5", "\\bot");
  defineSymbol(math, main, textord, "\u2205", "\\emptyset");
  defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
  defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
  defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
  defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
  defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
  defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
  defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
  defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
  defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
  defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
  defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
  defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
  defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
  defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
  defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
  defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
  defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
  defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
  defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
  defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
  defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
  defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
  defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
  defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
  defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
  defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
  defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
  defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
  defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
  defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
  defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
  defineSymbol(math, main, bin, "\u2217", "*", true);
  defineSymbol(math, main, bin, "+", "+");
  defineSymbol(math, main, bin, "\u2212", "-", true);
  defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
  defineSymbol(math, main, bin, "\u2218", "\\circ", true);
  defineSymbol(math, main, bin, "\xF7", "\\div", true);
  defineSymbol(math, main, bin, "\xB1", "\\pm", true);
  defineSymbol(math, main, bin, "\xD7", "\\times", true);
  defineSymbol(math, main, bin, "\u2229", "\\cap", true);
  defineSymbol(math, main, bin, "\u222A", "\\cup", true);
  defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
  defineSymbol(math, main, bin, "\u2227", "\\land");
  defineSymbol(math, main, bin, "\u2228", "\\lor");
  defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
  defineSymbol(math, main, bin, "\u2228", "\\vee", true);
  defineSymbol(math, main, textord, "\u221A", "\\surd");
  defineSymbol(math, main, open, "\u27E8", "\\langle", true);
  defineSymbol(math, main, open, "\u2223", "\\lvert");
  defineSymbol(math, main, open, "\u2225", "\\lVert");
  defineSymbol(math, main, close, "?", "?");
  defineSymbol(math, main, close, "!", "!");
  defineSymbol(math, main, close, "\u27E9", "\\rangle", true);
  defineSymbol(math, main, close, "\u2223", "\\rvert");
  defineSymbol(math, main, close, "\u2225", "\\rVert");
  defineSymbol(math, main, rel, "=", "=");
  defineSymbol(math, main, rel, ":", ":");
  defineSymbol(math, main, rel, "\u2248", "\\approx", true);
  defineSymbol(math, main, rel, "\u2245", "\\cong", true);
  defineSymbol(math, main, rel, "\u2265", "\\ge");
  defineSymbol(math, main, rel, "\u2265", "\\geq", true);
  defineSymbol(math, main, rel, "\u2190", "\\gets");
  defineSymbol(math, main, rel, ">", "\\gt", true);
  defineSymbol(math, main, rel, "\u2208", "\\in", true);
  defineSymbol(math, main, rel, "\uE020", "\\@not");
  defineSymbol(math, main, rel, "\u2282", "\\subset", true);
  defineSymbol(math, main, rel, "\u2283", "\\supset", true);
  defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
  defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
  defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
  defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
  defineSymbol(math, main, rel, "\u22A8", "\\models");
  defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
  defineSymbol(math, main, rel, "\u2264", "\\le");
  defineSymbol(math, main, rel, "\u2264", "\\leq", true);
  defineSymbol(math, main, rel, "<", "\\lt", true);
  defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
  defineSymbol(math, main, rel, "\u2192", "\\to");
  defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
  defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
  defineSymbol(math, main, spacing, "\xA0", "\\ ");
  defineSymbol(math, main, spacing, "\xA0", "\\space");
  defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
  defineSymbol(text, main, spacing, "\xA0", "\\ ");
  defineSymbol(text, main, spacing, "\xA0", " ");
  defineSymbol(text, main, spacing, "\xA0", "\\space");
  defineSymbol(text, main, spacing, "\xA0", "\\nobreakspace");
  defineSymbol(math, main, spacing, null, "\\nobreak");
  defineSymbol(math, main, spacing, null, "\\allowbreak");
  defineSymbol(math, main, punct, ",", ",");
  defineSymbol(math, main, punct, ";", ";");
  defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
  defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
  defineSymbol(math, main, bin, "\u2299", "\\odot", true);
  defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
  defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
  defineSymbol(math, main, textord, "\u2202", "\\partial", true);
  defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
  defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
  defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
  defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
  defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
  defineSymbol(math, main, bin, "\u2020", "\\dagger");
  defineSymbol(math, main, bin, "\u22C4", "\\diamond");
  defineSymbol(math, main, bin, "\u22C6", "\\star");
  defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
  defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
  defineSymbol(math, main, open, "{", "\\{");
  defineSymbol(text, main, textord, "{", "\\{");
  defineSymbol(text, main, textord, "{", "\\textbraceleft");
  defineSymbol(math, main, close, "}", "\\}");
  defineSymbol(text, main, textord, "}", "\\}");
  defineSymbol(text, main, textord, "}", "\\textbraceright");
  defineSymbol(math, main, open, "{", "\\lbrace");
  defineSymbol(math, main, close, "}", "\\rbrace");
  defineSymbol(math, main, open, "[", "\\lbrack", true);
  defineSymbol(text, main, textord, "[", "\\lbrack", true);
  defineSymbol(math, main, close, "]", "\\rbrack", true);
  defineSymbol(text, main, textord, "]", "\\rbrack", true);
  defineSymbol(math, main, open, "(", "\\lparen", true);
  defineSymbol(math, main, close, ")", "\\rparen", true);
  defineSymbol(text, main, textord, "<", "\\textless", true);
  defineSymbol(text, main, textord, ">", "\\textgreater", true);
  defineSymbol(math, main, open, "\u230A", "\\lfloor", true);
  defineSymbol(math, main, close, "\u230B", "\\rfloor", true);
  defineSymbol(math, main, open, "\u2308", "\\lceil", true);
  defineSymbol(math, main, close, "\u2309", "\\rceil", true);
  defineSymbol(math, main, textord, "\\", "\\backslash");
  defineSymbol(math, main, textord, "\u2223", "|");
  defineSymbol(math, main, textord, "\u2223", "\\vert");
  defineSymbol(text, main, textord, "|", "\\textbar", true);
  defineSymbol(math, main, textord, "\u2225", "\\|");
  defineSymbol(math, main, textord, "\u2225", "\\Vert");
  defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
  defineSymbol(text, main, textord, "~", "\\textasciitilde");
  defineSymbol(text, main, textord, "\\", "\\textbackslash");
  defineSymbol(text, main, textord, "^", "\\textasciicircum");
  defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
  defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
  defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
  defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
  defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
  defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
  defineSymbol(math, main, op, "\u2210", "\\coprod");
  defineSymbol(math, main, op, "\u22C1", "\\bigvee");
  defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
  defineSymbol(math, main, op, "\u2A04", "\\biguplus");
  defineSymbol(math, main, op, "\u22C2", "\\bigcap");
  defineSymbol(math, main, op, "\u22C3", "\\bigcup");
  defineSymbol(math, main, op, "\u222B", "\\int");
  defineSymbol(math, main, op, "\u222B", "\\intop");
  defineSymbol(math, main, op, "\u222C", "\\iint");
  defineSymbol(math, main, op, "\u222D", "\\iiint");
  defineSymbol(math, main, op, "\u220F", "\\prod");
  defineSymbol(math, main, op, "\u2211", "\\sum");
  defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
  defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
  defineSymbol(math, main, op, "\u2A00", "\\bigodot");
  defineSymbol(math, main, op, "\u222E", "\\oint");
  defineSymbol(math, main, op, "\u222F", "\\oiint");
  defineSymbol(math, main, op, "\u2230", "\\oiiint");
  defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
  defineSymbol(math, main, op, "\u222B", "\\smallint");
  defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
  defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
  defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
  defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
  defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
  defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
  defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
  defineSymbol(text, main, textord, "\u22EE", "\\varvdots");
  defineSymbol(math, main, accent, "\u02CA", "\\acute");
  defineSymbol(math, main, accent, "\u02CB", "\\grave");
  defineSymbol(math, main, accent, "\xA8", "\\ddot");
  defineSymbol(math, main, accent, "~", "\\tilde");
  defineSymbol(math, main, accent, "\u02C9", "\\bar");
  defineSymbol(math, main, accent, "\u02D8", "\\breve");
  defineSymbol(math, main, accent, "\u02C7", "\\check");
  defineSymbol(math, main, accent, "^", "\\hat");
  defineSymbol(math, main, accent, "\u20D7", "\\vec");
  defineSymbol(math, main, accent, "\u02D9", "\\dot");
  defineSymbol(math, main, accent, "\u02DA", "\\mathring");
  defineSymbol(math, main, mathord, "\uE131", "\\@imath");
  defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
  defineSymbol(math, main, textord, "\u0131", "\u0131");
  defineSymbol(math, main, textord, "\u0237", "\u0237");
  defineSymbol(text, main, textord, "\u0131", "\\i", true);
  defineSymbol(text, main, textord, "\u0237", "\\j", true);
  defineSymbol(text, main, textord, "\xDF", "\\ss", true);
  defineSymbol(text, main, textord, "\xE6", "\\ae", true);
  defineSymbol(text, main, textord, "\u0153", "\\oe", true);
  defineSymbol(text, main, textord, "\xF8", "\\o", true);
  defineSymbol(text, main, textord, "\xC6", "\\AE", true);
  defineSymbol(text, main, textord, "\u0152", "\\OE", true);
  defineSymbol(text, main, textord, "\xD8", "\\O", true);
  defineSymbol(text, main, accent, "\u02CA", "\\'");
  defineSymbol(text, main, accent, "\u02CB", "\\`");
  defineSymbol(text, main, accent, "\u02C6", "\\^");
  defineSymbol(text, main, accent, "\u02DC", "\\~");
  defineSymbol(text, main, accent, "\u02C9", "\\=");
  defineSymbol(text, main, accent, "\u02D8", "\\u");
  defineSymbol(text, main, accent, "\u02D9", "\\.");
  defineSymbol(text, main, accent, "\xB8", "\\c");
  defineSymbol(text, main, accent, "\u02DA", "\\r");
  defineSymbol(text, main, accent, "\u02C7", "\\v");
  defineSymbol(text, main, accent, "\xA8", '\\"');
  defineSymbol(text, main, accent, "\u02DD", "\\H");
  defineSymbol(text, main, accent, "\u25EF", "\\textcircled");
  var ligatures = {
    "--": true,
    "---": true,
    "``": true,
    "''": true
  };
  defineSymbol(text, main, textord, "\u2013", "--", true);
  defineSymbol(text, main, textord, "\u2013", "\\textendash");
  defineSymbol(text, main, textord, "\u2014", "---", true);
  defineSymbol(text, main, textord, "\u2014", "\\textemdash");
  defineSymbol(text, main, textord, "\u2018", "`", true);
  defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
  defineSymbol(text, main, textord, "\u2019", "'", true);
  defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
  defineSymbol(text, main, textord, "\u201C", "``", true);
  defineSymbol(text, main, textord, "\u201C", "\\textquotedblleft");
  defineSymbol(text, main, textord, "\u201D", "''", true);
  defineSymbol(text, main, textord, "\u201D", "\\textquotedblright");
  defineSymbol(math, main, textord, "\xB0", "\\degree", true);
  defineSymbol(text, main, textord, "\xB0", "\\degree");
  defineSymbol(text, main, textord, "\xB0", "\\textdegree", true);
  defineSymbol(math, main, textord, "\xA3", "\\pounds");
  defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
  defineSymbol(text, main, textord, "\xA3", "\\pounds");
  defineSymbol(text, main, textord, "\xA3", "\\textsterling", true);
  defineSymbol(math, ams, textord, "\u2720", "\\maltese");
  defineSymbol(text, ams, textord, "\u2720", "\\maltese");
  var mathTextSymbols = '0123456789/@."';
  for (i4 = 0; i4 < mathTextSymbols.length; i4++) {
    ch = mathTextSymbols.charAt(i4);
    defineSymbol(math, main, textord, ch, ch);
  }
  var ch;
  var i4;
  var textSymbols = '0123456789!@*()-=+";:?/.,';
  for (_i = 0; _i < textSymbols.length; _i++) {
    _ch = textSymbols.charAt(_i);
    defineSymbol(text, main, textord, _ch, _ch);
  }
  var _ch;
  var _i;
  var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  for (_i2 = 0; _i2 < letters.length; _i2++) {
    _ch2 = letters.charAt(_i2);
    defineSymbol(math, main, mathord, _ch2, _ch2);
    defineSymbol(text, main, textord, _ch2, _ch2);
  }
  var _ch2;
  var _i2;
  defineSymbol(math, ams, textord, "C", "\u2102");
  defineSymbol(text, ams, textord, "C", "\u2102");
  defineSymbol(math, ams, textord, "H", "\u210D");
  defineSymbol(text, ams, textord, "H", "\u210D");
  defineSymbol(math, ams, textord, "N", "\u2115");
  defineSymbol(text, ams, textord, "N", "\u2115");
  defineSymbol(math, ams, textord, "P", "\u2119");
  defineSymbol(text, ams, textord, "P", "\u2119");
  defineSymbol(math, ams, textord, "Q", "\u211A");
  defineSymbol(text, ams, textord, "Q", "\u211A");
  defineSymbol(math, ams, textord, "R", "\u211D");
  defineSymbol(text, ams, textord, "R", "\u211D");
  defineSymbol(math, ams, textord, "Z", "\u2124");
  defineSymbol(text, ams, textord, "Z", "\u2124");
  defineSymbol(math, main, mathord, "h", "\u210E");
  defineSymbol(text, main, mathord, "h", "\u210E");
  var wideChar = "";
  for (_i3 = 0; _i3 < letters.length; _i3++) {
    _ch3 = letters.charAt(_i3);
    wideChar = String.fromCharCode(55349, 56320 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56372 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56424 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56580 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56684 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56736 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56788 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56840 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56944 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    if (_i3 < 26) {
      wideChar = String.fromCharCode(55349, 56632 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(55349, 56476 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
    }
  }
  var _ch3;
  var _i3;
  wideChar = String.fromCharCode(55349, 56668);
  defineSymbol(math, main, mathord, "k", wideChar);
  defineSymbol(text, main, textord, "k", wideChar);
  for (_i4 = 0; _i4 < 10; _i4++) {
    _ch4 = _i4.toString();
    wideChar = String.fromCharCode(55349, 57294 + _i4);
    defineSymbol(math, main, mathord, _ch4, wideChar);
    defineSymbol(text, main, textord, _ch4, wideChar);
    wideChar = String.fromCharCode(55349, 57314 + _i4);
    defineSymbol(math, main, mathord, _ch4, wideChar);
    defineSymbol(text, main, textord, _ch4, wideChar);
    wideChar = String.fromCharCode(55349, 57324 + _i4);
    defineSymbol(math, main, mathord, _ch4, wideChar);
    defineSymbol(text, main, textord, _ch4, wideChar);
    wideChar = String.fromCharCode(55349, 57334 + _i4);
    defineSymbol(math, main, mathord, _ch4, wideChar);
    defineSymbol(text, main, textord, _ch4, wideChar);
  }
  var _ch4;
  var _i4;
  var extraLatin = "\xD0\xDE\xFE";
  for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
    _ch5 = extraLatin.charAt(_i5);
    defineSymbol(math, main, mathord, _ch5, _ch5);
    defineSymbol(text, main, textord, _ch5, _ch5);
  }
  var _ch5;
  var _i5;
  var wideLatinLetterData = [
    ["mathbf", "textbf", "Main-Bold"],
    // A-Z bold upright
    ["mathbf", "textbf", "Main-Bold"],
    // a-z bold upright
    ["mathnormal", "textit", "Math-Italic"],
    // A-Z italic
    ["mathnormal", "textit", "Math-Italic"],
    // a-z italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
    // A-Z bold italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
    // a-z bold italic
    // Map fancy A-Z letters to script, not calligraphic.
    // This aligns with unicode-math and math fonts (except Cambria Math).
    ["mathscr", "textscr", "Script-Regular"],
    // A-Z script
    ["", "", ""],
    // a-z script.  No font
    ["", "", ""],
    // A-Z bold script. No font
    ["", "", ""],
    // a-z bold script. No font
    ["mathfrak", "textfrak", "Fraktur-Regular"],
    // A-Z Fraktur
    ["mathfrak", "textfrak", "Fraktur-Regular"],
    // a-z Fraktur
    ["mathbb", "textbb", "AMS-Regular"],
    // A-Z double-struck
    ["mathbb", "textbb", "AMS-Regular"],
    // k double-struck
    // Note that we are using a bold font, but font metrics for regular Fraktur.
    ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
    // A-Z bold Fraktur
    ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
    // a-z bold Fraktur
    ["mathsf", "textsf", "SansSerif-Regular"],
    // A-Z sans-serif
    ["mathsf", "textsf", "SansSerif-Regular"],
    // a-z sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    // A-Z bold sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    // a-z bold sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"],
    // A-Z italic sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"],
    // a-z italic sans-serif
    ["", "", ""],
    // A-Z bold italic sans. No font
    ["", "", ""],
    // a-z bold italic sans. No font
    ["mathtt", "texttt", "Typewriter-Regular"],
    // A-Z monospace
    ["mathtt", "texttt", "Typewriter-Regular"]
    // a-z monospace
  ];
  var wideNumeralData = [
    ["mathbf", "textbf", "Main-Bold"],
    // 0-9 bold
    ["", "", ""],
    // 0-9 double-struck. No KaTeX font.
    ["mathsf", "textsf", "SansSerif-Regular"],
    // 0-9 sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    // 0-9 bold sans-serif
    ["mathtt", "texttt", "Typewriter-Regular"]
    // 0-9 monospace
  ];
  var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
    var H3 = wideChar2.charCodeAt(0);
    var L4 = wideChar2.charCodeAt(1);
    var codePoint = (H3 - 55296) * 1024 + (L4 - 56320) + 65536;
    var j3 = mode === "math" ? 0 : 1;
    if (119808 <= codePoint && codePoint < 120484) {
      var i4 = Math.floor((codePoint - 119808) / 26);
      return [wideLatinLetterData[i4][2], wideLatinLetterData[i4][j3]];
    } else if (120782 <= codePoint && codePoint <= 120831) {
      var _i = Math.floor((codePoint - 120782) / 10);
      return [wideNumeralData[_i][2], wideNumeralData[_i][j3]];
    } else if (codePoint === 120485 || codePoint === 120486) {
      return [wideLatinLetterData[0][2], wideLatinLetterData[0][j3]];
    } else if (120486 < codePoint && codePoint < 120782) {
      return ["", ""];
    } else {
      throw new ParseError("Unsupported character: " + wideChar2);
    }
  };
  var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
    if (symbols[mode][value] && symbols[mode][value].replace) {
      value = symbols[mode][value].replace;
    }
    return {
      value,
      metrics: getCharacterMetrics(value, fontName, mode)
    };
  };
  var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
    var lookup = lookupSymbol(value, fontName, mode);
    var metrics = lookup.metrics;
    value = lookup.value;
    var symbolNode;
    if (metrics) {
      var italic = metrics.italic;
      if (mode === "text" || options && options.font === "mathit") {
        italic = 0;
      }
      symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
    } else {
      typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
      symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
    }
    if (options) {
      symbolNode.maxFontSize = options.sizeMultiplier;
      if (options.style.isTight()) {
        symbolNode.classes.push("mtight");
      }
      var color = options.getColor();
      if (color) {
        symbolNode.style.color = color;
      }
    }
    return symbolNode;
  };
  var mathsym = function mathsym2(value, mode, options, classes) {
    if (classes === void 0) {
      classes = [];
    }
    if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
      return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
    } else if (value === "\\" || symbols[mode][value].font === "main") {
      return makeSymbol(value, "Main-Regular", mode, options, classes);
    } else {
      return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
    }
  };
  var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
    if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
      return {
        fontName: "Math-BoldItalic",
        fontClass: "boldsymbol"
      };
    } else {
      return {
        fontName: "Main-Bold",
        fontClass: "mathbf"
      };
    }
  };
  var makeOrd = function makeOrd2(group, options, type) {
    var mode = group.mode;
    var text2 = group.text;
    var classes = ["mord"];
    var isFont = mode === "math" || mode === "text" && options.font;
    var fontOrFamily = isFont ? options.font : options.fontFamily;
    var wideFontName = "";
    var wideFontClass = "";
    if (text2.charCodeAt(0) === 55349) {
      [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
    }
    if (wideFontName.length > 0) {
      return makeSymbol(text2, wideFontName, mode, options, classes.concat(wideFontClass));
    } else if (fontOrFamily) {
      var fontName;
      var fontClasses;
      if (fontOrFamily === "boldsymbol") {
        var fontData = boldsymbol(text2, mode, options, classes, type);
        fontName = fontData.fontName;
        fontClasses = [fontData.fontClass];
      } else if (isFont) {
        fontName = fontMap[fontOrFamily].fontName;
        fontClasses = [fontOrFamily];
      } else {
        fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
        fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
      }
      if (lookupSymbol(text2, fontName, mode).metrics) {
        return makeSymbol(text2, fontName, mode, options, classes.concat(fontClasses));
      } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
        var parts = [];
        for (var i4 = 0; i4 < text2.length; i4++) {
          parts.push(makeSymbol(text2[i4], fontName, mode, options, classes.concat(fontClasses)));
        }
        return makeFragment(parts);
      }
    }
    if (type === "mathord") {
      return makeSymbol(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
    } else if (type === "textord") {
      var font = symbols[mode][text2] && symbols[mode][text2].font;
      if (font === "ams") {
        var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
        return makeSymbol(text2, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
      } else if (font === "main" || !font) {
        var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
        return makeSymbol(text2, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
      } else {
        var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
        return makeSymbol(text2, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
      }
    } else {
      throw new Error("unexpected type: " + type + " in makeOrd");
    }
  };
  var canCombine = (prev, next) => {
    if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
      return false;
    }
    if (prev.classes.length === 1) {
      var cls = prev.classes[0];
      if (cls === "mbin" || cls === "mord") {
        return false;
      }
    }
    for (var style in prev.style) {
      if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
        return false;
      }
    }
    for (var _style in next.style) {
      if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
        return false;
      }
    }
    return true;
  };
  var tryCombineChars = (chars) => {
    for (var i4 = 0; i4 < chars.length - 1; i4++) {
      var prev = chars[i4];
      var next = chars[i4 + 1];
      if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
        prev.text += next.text;
        prev.height = Math.max(prev.height, next.height);
        prev.depth = Math.max(prev.depth, next.depth);
        prev.italic = next.italic;
        chars.splice(i4 + 1, 1);
        i4--;
      }
    }
    return chars;
  };
  var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
    var height = 0;
    var depth = 0;
    var maxFontSize = 0;
    for (var i4 = 0; i4 < elem.children.length; i4++) {
      var child = elem.children[i4];
      if (child.height > height) {
        height = child.height;
      }
      if (child.depth > depth) {
        depth = child.depth;
      }
      if (child.maxFontSize > maxFontSize) {
        maxFontSize = child.maxFontSize;
      }
    }
    elem.height = height;
    elem.depth = depth;
    elem.maxFontSize = maxFontSize;
  };
  var makeSpan$2 = function makeSpan(classes, children, options, style) {
    var span = new Span(classes, children, options, style);
    sizeElementFromChildren(span);
    return span;
  };
  var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
  var makeLineSpan = function makeLineSpan2(className, options, thickness) {
    var line = makeSpan$2([className], [], options);
    line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
    line.style.borderBottomWidth = makeEm(line.height);
    line.maxFontSize = 1;
    return line;
  };
  var makeAnchor = function makeAnchor2(href, classes, children, options) {
    var anchor = new Anchor(href, classes, children, options);
    sizeElementFromChildren(anchor);
    return anchor;
  };
  var makeFragment = function makeFragment2(children) {
    var fragment = new DocumentFragment2(children);
    sizeElementFromChildren(fragment);
    return fragment;
  };
  var wrapFragment = function wrapFragment2(group, options) {
    if (group instanceof DocumentFragment2) {
      return makeSpan$2([], [group], options);
    }
    return group;
  };
  var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
    if (params.positionType === "individualShift") {
      var oldChildren = params.children;
      var children = [oldChildren[0]];
      var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
      var currPos = _depth;
      for (var i4 = 1; i4 < oldChildren.length; i4++) {
        var diff = -oldChildren[i4].shift - currPos - oldChildren[i4].elem.depth;
        var size = diff - (oldChildren[i4 - 1].elem.height + oldChildren[i4 - 1].elem.depth);
        currPos = currPos + diff;
        children.push({
          type: "kern",
          size
        });
        children.push(oldChildren[i4]);
      }
      return {
        children,
        depth: _depth
      };
    }
    var depth;
    if (params.positionType === "top") {
      var bottom = params.positionData;
      for (var _i = 0; _i < params.children.length; _i++) {
        var child = params.children[_i];
        bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
      }
      depth = bottom;
    } else if (params.positionType === "bottom") {
      depth = -params.positionData;
    } else {
      var firstChild = params.children[0];
      if (firstChild.type !== "elem") {
        throw new Error('First child must have type "elem".');
      }
      if (params.positionType === "shift") {
        depth = -firstChild.elem.depth - params.positionData;
      } else if (params.positionType === "firstBaseline") {
        depth = -firstChild.elem.depth;
      } else {
        throw new Error("Invalid positionType " + params.positionType + ".");
      }
    }
    return {
      children: params.children,
      depth
    };
  };
  var makeVList = function makeVList2(params, options) {
    var {
      children,
      depth
    } = getVListChildrenAndDepth(params);
    var pstrutSize = 0;
    for (var i4 = 0; i4 < children.length; i4++) {
      var child = children[i4];
      if (child.type === "elem") {
        var elem = child.elem;
        pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
      }
    }
    pstrutSize += 2;
    var pstrut = makeSpan$2(["pstrut"], []);
    pstrut.style.height = makeEm(pstrutSize);
    var realChildren = [];
    var minPos = depth;
    var maxPos = depth;
    var currPos = depth;
    for (var _i2 = 0; _i2 < children.length; _i2++) {
      var _child = children[_i2];
      if (_child.type === "kern") {
        currPos += _child.size;
      } else {
        var _elem = _child.elem;
        var classes = _child.wrapperClasses || [];
        var style = _child.wrapperStyle || {};
        var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
        childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
        if (_child.marginLeft) {
          childWrap.style.marginLeft = _child.marginLeft;
        }
        if (_child.marginRight) {
          childWrap.style.marginRight = _child.marginRight;
        }
        realChildren.push(childWrap);
        currPos += _elem.height + _elem.depth;
      }
      minPos = Math.min(minPos, currPos);
      maxPos = Math.max(maxPos, currPos);
    }
    var vlist = makeSpan$2(["vlist"], realChildren);
    vlist.style.height = makeEm(maxPos);
    var rows;
    if (minPos < 0) {
      var emptySpan = makeSpan$2([], []);
      var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
      depthStrut.style.height = makeEm(-minPos);
      var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
      rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
    } else {
      rows = [makeSpan$2(["vlist-r"], [vlist])];
    }
    var vtable = makeSpan$2(["vlist-t"], rows);
    if (rows.length === 2) {
      vtable.classes.push("vlist-t2");
    }
    vtable.height = maxPos;
    vtable.depth = -minPos;
    return vtable;
  };
  var makeGlue = (measurement, options) => {
    var rule = makeSpan$2(["mspace"], [], options);
    var size = calculateSize(measurement, options);
    rule.style.marginRight = makeEm(size);
    return rule;
  };
  var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
    var baseFontName = "";
    switch (fontFamily) {
      case "amsrm":
        baseFontName = "AMS";
        break;
      case "textrm":
        baseFontName = "Main";
        break;
      case "textsf":
        baseFontName = "SansSerif";
        break;
      case "texttt":
        baseFontName = "Typewriter";
        break;
      default:
        baseFontName = fontFamily;
    }
    var fontStylesName;
    if (fontWeight === "textbf" && fontShape === "textit") {
      fontStylesName = "BoldItalic";
    } else if (fontWeight === "textbf") {
      fontStylesName = "Bold";
    } else if (fontWeight === "textit") {
      fontStylesName = "Italic";
    } else {
      fontStylesName = "Regular";
    }
    return baseFontName + "-" + fontStylesName;
  };
  var fontMap = {
    // styles
    "mathbf": {
      variant: "bold",
      fontName: "Main-Bold"
    },
    "mathrm": {
      variant: "normal",
      fontName: "Main-Regular"
    },
    "textit": {
      variant: "italic",
      fontName: "Main-Italic"
    },
    "mathit": {
      variant: "italic",
      fontName: "Main-Italic"
    },
    "mathnormal": {
      variant: "italic",
      fontName: "Math-Italic"
    },
    "mathsfit": {
      variant: "sans-serif-italic",
      fontName: "SansSerif-Italic"
    },
    // "boldsymbol" is missing because they require the use of multiple fonts:
    // Math-BoldItalic and Main-Bold.  This is handled by a special case in
    // makeOrd which ends up calling boldsymbol.
    // families
    "mathbb": {
      variant: "double-struck",
      fontName: "AMS-Regular"
    },
    "mathcal": {
      variant: "script",
      fontName: "Caligraphic-Regular"
    },
    "mathfrak": {
      variant: "fraktur",
      fontName: "Fraktur-Regular"
    },
    "mathscr": {
      variant: "script",
      fontName: "Script-Regular"
    },
    "mathsf": {
      variant: "sans-serif",
      fontName: "SansSerif-Regular"
    },
    "mathtt": {
      variant: "monospace",
      fontName: "Typewriter-Regular"
    }
  };
  var svgData = {
    //   path, width, height
    vec: ["vec", 0.471, 0.714],
    // values from the font glyph
    oiintSize1: ["oiintSize1", 0.957, 0.499],
    // oval to overlay the integrand
    oiintSize2: ["oiintSize2", 1.472, 0.659],
    oiiintSize1: ["oiiintSize1", 1.304, 0.499],
    oiiintSize2: ["oiiintSize2", 1.98, 0.659]
  };
  var staticSvg = function staticSvg2(value, options) {
    var [pathName, width, height] = svgData[value];
    var path2 = new PathNode(pathName);
    var svgNode = new SvgNode([path2], {
      "width": makeEm(width),
      "height": makeEm(height),
      // Override CSS rule `.katex svg { width: 100% }`
      "style": "width:" + makeEm(width),
      "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
      "preserveAspectRatio": "xMinYMin"
    });
    var span = makeSvgSpan(["overlay"], [svgNode], options);
    span.height = height;
    span.style.height = makeEm(height);
    span.style.width = makeEm(width);
    return span;
  };
  var buildCommon = {
    fontMap,
    makeSymbol,
    mathsym,
    makeSpan: makeSpan$2,
    makeSvgSpan,
    makeLineSpan,
    makeAnchor,
    makeFragment,
    wrapFragment,
    makeVList,
    makeOrd,
    makeGlue,
    staticSvg,
    svgData,
    tryCombineChars
  };
  var thinspace = {
    number: 3,
    unit: "mu"
  };
  var mediumspace = {
    number: 4,
    unit: "mu"
  };
  var thickspace = {
    number: 5,
    unit: "mu"
  };
  var spacings = {
    mord: {
      mop: thinspace,
      mbin: mediumspace,
      mrel: thickspace,
      minner: thinspace
    },
    mop: {
      mord: thinspace,
      mop: thinspace,
      mrel: thickspace,
      minner: thinspace
    },
    mbin: {
      mord: mediumspace,
      mop: mediumspace,
      mopen: mediumspace,
      minner: mediumspace
    },
    mrel: {
      mord: thickspace,
      mop: thickspace,
      mopen: thickspace,
      minner: thickspace
    },
    mopen: {},
    mclose: {
      mop: thinspace,
      mbin: mediumspace,
      mrel: thickspace,
      minner: thinspace
    },
    mpunct: {
      mord: thinspace,
      mop: thinspace,
      mrel: thickspace,
      mopen: thinspace,
      mclose: thinspace,
      mpunct: thinspace,
      minner: thinspace
    },
    minner: {
      mord: thinspace,
      mop: thinspace,
      mbin: mediumspace,
      mrel: thickspace,
      mopen: thinspace,
      mpunct: thinspace,
      minner: thinspace
    }
  };
  var tightSpacings = {
    mord: {
      mop: thinspace
    },
    mop: {
      mord: thinspace,
      mop: thinspace
    },
    mbin: {},
    mrel: {},
    mopen: {},
    mclose: {
      mop: thinspace
    },
    mpunct: {},
    minner: {
      mop: thinspace
    }
  };
  var _functions = {};
  var _htmlGroupBuilders = {};
  var _mathmlGroupBuilders = {};
  function defineFunction(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs,
      argTypes: props.argTypes,
      allowedInArgument: !!props.allowedInArgument,
      allowedInText: !!props.allowedInText,
      allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
      numOptionalArgs: props.numOptionalArgs || 0,
      infix: !!props.infix,
      primitive: !!props.primitive,
      handler
    };
    for (var i4 = 0; i4 < names.length; ++i4) {
      _functions[names[i4]] = data;
    }
    if (type) {
      if (htmlBuilder3) {
        _htmlGroupBuilders[type] = htmlBuilder3;
      }
      if (mathmlBuilder3) {
        _mathmlGroupBuilders[type] = mathmlBuilder3;
      }
    }
  }
  function defineFunctionBuilders(_ref2) {
    var {
      type,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref2;
    defineFunction({
      type,
      names: [],
      props: {
        numArgs: 0
      },
      handler() {
        throw new Error("Should never be called.");
      },
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    });
  }
  var normalizeArgument = function normalizeArgument2(arg) {
    return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
  };
  var ordargument = function ordargument2(arg) {
    return arg.type === "ordgroup" ? arg.body : [arg];
  };
  var makeSpan$1 = buildCommon.makeSpan;
  var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
  var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
  var styleMap$1 = {
    "display": Style$1.DISPLAY,
    "text": Style$1.TEXT,
    "script": Style$1.SCRIPT,
    "scriptscript": Style$1.SCRIPTSCRIPT
  };
  var DomEnum = {
    mord: "mord",
    mop: "mop",
    mbin: "mbin",
    mrel: "mrel",
    mopen: "mopen",
    mclose: "mclose",
    mpunct: "mpunct",
    minner: "minner"
  };
  var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
    if (surrounding === void 0) {
      surrounding = [null, null];
    }
    var groups = [];
    for (var i4 = 0; i4 < expression.length; i4++) {
      var output = buildGroup$1(expression[i4], options);
      if (output instanceof DocumentFragment2) {
        var children = output.children;
        groups.push(...children);
      } else {
        groups.push(output);
      }
    }
    buildCommon.tryCombineChars(groups);
    if (!isRealGroup) {
      return groups;
    }
    var glueOptions = options;
    if (expression.length === 1) {
      var node = expression[0];
      if (node.type === "sizing") {
        glueOptions = options.havingSize(node.size);
      } else if (node.type === "styling") {
        glueOptions = options.havingStyle(styleMap$1[node.style]);
      }
    }
    var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
    var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
    var isRoot = isRealGroup === "root";
    traverseNonSpaceNodes(groups, (node2, prev) => {
      var prevType = prev.classes[0];
      var type = node2.classes[0];
      if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
        prev.classes[0] = "mord";
      } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
        node2.classes[0] = "mord";
      }
    }, {
      node: dummyPrev
    }, dummyNext, isRoot);
    traverseNonSpaceNodes(groups, (node2, prev) => {
      var prevType = getTypeOfDomTree(prev);
      var type = getTypeOfDomTree(node2);
      var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
      if (space) {
        return buildCommon.makeGlue(space, glueOptions);
      }
    }, {
      node: dummyPrev
    }, dummyNext, isRoot);
    return groups;
  };
  var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
    if (next) {
      nodes.push(next);
    }
    var i4 = 0;
    for (; i4 < nodes.length; i4++) {
      var node = nodes[i4];
      var partialGroup = checkPartialGroup(node);
      if (partialGroup) {
        traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
        continue;
      }
      var nonspace = !node.hasClass("mspace");
      if (nonspace) {
        var result = callback(node, prev.node);
        if (result) {
          if (prev.insertAfter) {
            prev.insertAfter(result);
          } else {
            nodes.unshift(result);
            i4++;
          }
        }
      }
      if (nonspace) {
        prev.node = node;
      } else if (isRoot && node.hasClass("newline")) {
        prev.node = makeSpan$1(["leftmost"]);
      }
      prev.insertAfter = /* @__PURE__ */ ((index) => (n3) => {
        nodes.splice(index + 1, 0, n3);
        i4++;
      })(i4);
    }
    if (next) {
      nodes.pop();
    }
  };
  var checkPartialGroup = function checkPartialGroup2(node) {
    if (node instanceof DocumentFragment2 || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
      return node;
    }
    return null;
  };
  var getOutermostNode = function getOutermostNode2(node, side) {
    var partialGroup = checkPartialGroup(node);
    if (partialGroup) {
      var children = partialGroup.children;
      if (children.length) {
        if (side === "right") {
          return getOutermostNode2(children[children.length - 1], "right");
        } else if (side === "left") {
          return getOutermostNode2(children[0], "left");
        }
      }
    }
    return node;
  };
  var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
    if (!node) {
      return null;
    }
    if (side) {
      node = getOutermostNode(node, side);
    }
    return DomEnum[node.classes[0]] || null;
  };
  var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
    var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
    return makeSpan$1(classes.concat(moreClasses));
  };
  var buildGroup$1 = function buildGroup(group, options, baseOptions) {
    if (!group) {
      return makeSpan$1();
    }
    if (_htmlGroupBuilders[group.type]) {
      var groupNode = _htmlGroupBuilders[group.type](group, options);
      if (baseOptions && options.size !== baseOptions.size) {
        groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
        var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
        groupNode.height *= multiplier;
        groupNode.depth *= multiplier;
      }
      return groupNode;
    } else {
      throw new ParseError("Got group of unknown type: '" + group.type + "'");
    }
  };
  function buildHTMLUnbreakable(children, options) {
    var body = makeSpan$1(["base"], children, options);
    var strut = makeSpan$1(["strut"]);
    strut.style.height = makeEm(body.height + body.depth);
    if (body.depth) {
      strut.style.verticalAlign = makeEm(-body.depth);
    }
    body.children.unshift(strut);
    return body;
  }
  function buildHTML(tree, options) {
    var tag = null;
    if (tree.length === 1 && tree[0].type === "tag") {
      tag = tree[0].tag;
      tree = tree[0].body;
    }
    var expression = buildExpression$1(tree, options, "root");
    var eqnNum;
    if (expression.length === 2 && expression[1].hasClass("tag")) {
      eqnNum = expression.pop();
    }
    var children = [];
    var parts = [];
    for (var i4 = 0; i4 < expression.length; i4++) {
      parts.push(expression[i4]);
      if (expression[i4].hasClass("mbin") || expression[i4].hasClass("mrel") || expression[i4].hasClass("allowbreak")) {
        var nobreak = false;
        while (i4 < expression.length - 1 && expression[i4 + 1].hasClass("mspace") && !expression[i4 + 1].hasClass("newline")) {
          i4++;
          parts.push(expression[i4]);
          if (expression[i4].hasClass("nobreak")) {
            nobreak = true;
          }
        }
        if (!nobreak) {
          children.push(buildHTMLUnbreakable(parts, options));
          parts = [];
        }
      } else if (expression[i4].hasClass("newline")) {
        parts.pop();
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable(parts, options));
          parts = [];
        }
        children.push(expression[i4]);
      }
    }
    if (parts.length > 0) {
      children.push(buildHTMLUnbreakable(parts, options));
    }
    var tagChild;
    if (tag) {
      tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
      tagChild.classes = ["tag"];
      children.push(tagChild);
    } else if (eqnNum) {
      children.push(eqnNum);
    }
    var htmlNode = makeSpan$1(["katex-html"], children);
    htmlNode.setAttribute("aria-hidden", "true");
    if (tagChild) {
      var strut = tagChild.children[0];
      strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
      if (htmlNode.depth) {
        strut.style.verticalAlign = makeEm(-htmlNode.depth);
      }
    }
    return htmlNode;
  }
  function newDocumentFragment(children) {
    return new DocumentFragment2(children);
  }
  var MathNode = class {
    constructor(type, children, classes) {
      this.type = void 0;
      this.attributes = void 0;
      this.children = void 0;
      this.classes = void 0;
      this.type = type;
      this.attributes = {};
      this.children = children || [];
      this.classes = classes || [];
    }
    /**
     * Sets an attribute on a MathML node. MathML depends on attributes to convey a
     * semantic content, so this is used heavily.
     */
    setAttribute(name, value) {
      this.attributes[name] = value;
    }
    /**
     * Gets an attribute on a MathML node.
     */
    getAttribute(name) {
      return this.attributes[name];
    }
    /**
     * Converts the math node into a MathML-namespaced DOM element.
     */
    toNode() {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      }
      if (this.classes.length > 0) {
        node.className = createClass(this.classes);
      }
      for (var i4 = 0; i4 < this.children.length; i4++) {
        if (this.children[i4] instanceof TextNode && this.children[i4 + 1] instanceof TextNode) {
          var text2 = this.children[i4].toText() + this.children[++i4].toText();
          while (this.children[i4 + 1] instanceof TextNode) {
            text2 += this.children[++i4].toText();
          }
          node.appendChild(new TextNode(text2).toNode());
        } else {
          node.appendChild(this.children[i4].toNode());
        }
      }
      return node;
    }
    /**
     * Converts the math node into an HTML markup string.
     */
    toMarkup() {
      var markup = "<" + this.type;
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          markup += " " + attr + '="';
          markup += utils.escape(this.attributes[attr]);
          markup += '"';
        }
      }
      if (this.classes.length > 0) {
        markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
      }
      markup += ">";
      for (var i4 = 0; i4 < this.children.length; i4++) {
        markup += this.children[i4].toMarkup();
      }
      markup += "</" + this.type + ">";
      return markup;
    }
    /**
     * Converts the math node into a string, similar to innerText, but escaped.
     */
    toText() {
      return this.children.map((child) => child.toText()).join("");
    }
  };
  var TextNode = class {
    constructor(text2) {
      this.text = void 0;
      this.text = text2;
    }
    /**
     * Converts the text node into a DOM text node.
     */
    toNode() {
      return document.createTextNode(this.text);
    }
    /**
     * Converts the text node into escaped HTML markup
     * (representing the text itself).
     */
    toMarkup() {
      return utils.escape(this.toText());
    }
    /**
     * Converts the text node into a string
     * (representing the text itself).
     */
    toText() {
      return this.text;
    }
  };
  var SpaceNode = class {
    /**
     * Create a Space node with width given in CSS ems.
     */
    constructor(width) {
      this.width = void 0;
      this.character = void 0;
      this.width = width;
      if (width >= 0.05555 && width <= 0.05556) {
        this.character = "\u200A";
      } else if (width >= 0.1666 && width <= 0.1667) {
        this.character = "\u2009";
      } else if (width >= 0.2222 && width <= 0.2223) {
        this.character = "\u2005";
      } else if (width >= 0.2777 && width <= 0.2778) {
        this.character = "\u2005\u200A";
      } else if (width >= -0.05556 && width <= -0.05555) {
        this.character = "\u200A\u2063";
      } else if (width >= -0.1667 && width <= -0.1666) {
        this.character = "\u2009\u2063";
      } else if (width >= -0.2223 && width <= -0.2222) {
        this.character = "\u205F\u2063";
      } else if (width >= -0.2778 && width <= -0.2777) {
        this.character = "\u2005\u2063";
      } else {
        this.character = null;
      }
    }
    /**
     * Converts the math node into a MathML-namespaced DOM element.
     */
    toNode() {
      if (this.character) {
        return document.createTextNode(this.character);
      } else {
        var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
        node.setAttribute("width", makeEm(this.width));
        return node;
      }
    }
    /**
     * Converts the math node into an HTML markup string.
     */
    toMarkup() {
      if (this.character) {
        return "<mtext>" + this.character + "</mtext>";
      } else {
        return '<mspace width="' + makeEm(this.width) + '"/>';
      }
    }
    /**
     * Converts the math node into a string, similar to innerText.
     */
    toText() {
      if (this.character) {
        return this.character;
      } else {
        return " ";
      }
    }
  };
  var mathMLTree = {
    MathNode,
    TextNode,
    SpaceNode,
    newDocumentFragment
  };
  var makeText = function makeText2(text2, mode, options) {
    if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
      text2 = symbols[mode][text2].replace;
    }
    return new mathMLTree.TextNode(text2);
  };
  var makeRow = function makeRow2(body) {
    if (body.length === 1) {
      return body[0];
    } else {
      return new mathMLTree.MathNode("mrow", body);
    }
  };
  var getVariant = function getVariant2(group, options) {
    if (options.fontFamily === "texttt") {
      return "monospace";
    } else if (options.fontFamily === "textsf") {
      if (options.fontShape === "textit" && options.fontWeight === "textbf") {
        return "sans-serif-bold-italic";
      } else if (options.fontShape === "textit") {
        return "sans-serif-italic";
      } else if (options.fontWeight === "textbf") {
        return "bold-sans-serif";
      } else {
        return "sans-serif";
      }
    } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "bold-italic";
    } else if (options.fontShape === "textit") {
      return "italic";
    } else if (options.fontWeight === "textbf") {
      return "bold";
    }
    var font = options.font;
    if (!font || font === "mathnormal") {
      return null;
    }
    var mode = group.mode;
    if (font === "mathit") {
      return "italic";
    } else if (font === "boldsymbol") {
      return group.type === "textord" ? "bold" : "bold-italic";
    } else if (font === "mathbf") {
      return "bold";
    } else if (font === "mathbb") {
      return "double-struck";
    } else if (font === "mathsfit") {
      return "sans-serif-italic";
    } else if (font === "mathfrak") {
      return "fraktur";
    } else if (font === "mathscr" || font === "mathcal") {
      return "script";
    } else if (font === "mathsf") {
      return "sans-serif";
    } else if (font === "mathtt") {
      return "monospace";
    }
    var text2 = group.text;
    if (utils.contains(["\\imath", "\\jmath"], text2)) {
      return null;
    }
    if (symbols[mode][text2] && symbols[mode][text2].replace) {
      text2 = symbols[mode][text2].replace;
    }
    var fontName = buildCommon.fontMap[font].fontName;
    if (getCharacterMetrics(text2, fontName, mode)) {
      return buildCommon.fontMap[font].variant;
    }
    return null;
  };
  function isNumberPunctuation(group) {
    if (!group) {
      return false;
    }
    if (group.type === "mi" && group.children.length === 1) {
      var child = group.children[0];
      return child instanceof TextNode && child.text === ".";
    } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
      var _child = group.children[0];
      return _child instanceof TextNode && _child.text === ",";
    } else {
      return false;
    }
  }
  var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
    if (expression.length === 1) {
      var group = buildGroup2(expression[0], options);
      if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
        group.setAttribute("lspace", "0em");
        group.setAttribute("rspace", "0em");
      }
      return [group];
    }
    var groups = [];
    var lastGroup;
    for (var i4 = 0; i4 < expression.length; i4++) {
      var _group = buildGroup2(expression[i4], options);
      if (_group instanceof MathNode && lastGroup instanceof MathNode) {
        if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
          lastGroup.children.push(..._group.children);
          continue;
        } else if (_group.type === "mn" && lastGroup.type === "mn") {
          lastGroup.children.push(..._group.children);
          continue;
        } else if (isNumberPunctuation(_group) && lastGroup.type === "mn") {
          lastGroup.children.push(..._group.children);
          continue;
        } else if (_group.type === "mn" && isNumberPunctuation(lastGroup)) {
          _group.children = [...lastGroup.children, ..._group.children];
          groups.pop();
        } else if ((_group.type === "msup" || _group.type === "msub") && _group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
          var base = _group.children[0];
          if (base instanceof MathNode && base.type === "mn") {
            base.children = [...lastGroup.children, ...base.children];
            groups.pop();
          }
        } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
          var lastChild = lastGroup.children[0];
          if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
            var child = _group.children[0];
            if (child instanceof TextNode && child.text.length > 0) {
              child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
              groups.pop();
            }
          }
        }
      }
      groups.push(_group);
      lastGroup = _group;
    }
    return groups;
  };
  var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
    return makeRow(buildExpression2(expression, options, isOrdgroup));
  };
  var buildGroup2 = function buildGroup3(group, options) {
    if (!group) {
      return new mathMLTree.MathNode("mrow");
    }
    if (_mathmlGroupBuilders[group.type]) {
      var result = _mathmlGroupBuilders[group.type](group, options);
      return result;
    } else {
      throw new ParseError("Got group of unknown type: '" + group.type + "'");
    }
  };
  function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
    var expression = buildExpression2(tree, options);
    var wrapper;
    if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
      wrapper = expression[0];
    } else {
      wrapper = new mathMLTree.MathNode("mrow", expression);
    }
    var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
    var math2 = new mathMLTree.MathNode("math", [semantics]);
    math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
    if (isDisplayMode) {
      math2.setAttribute("display", "block");
    }
    var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
    return buildCommon.makeSpan([wrapperClass], [math2]);
  }
  var optionsFromSettings = function optionsFromSettings2(settings) {
    return new Options({
      style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
      maxSize: settings.maxSize,
      minRuleThickness: settings.minRuleThickness
    });
  };
  var displayWrap = function displayWrap2(node, settings) {
    if (settings.displayMode) {
      var classes = ["katex-display"];
      if (settings.leqno) {
        classes.push("leqno");
      }
      if (settings.fleqn) {
        classes.push("fleqn");
      }
      node = buildCommon.makeSpan(classes, [node]);
    }
    return node;
  };
  var buildTree = function buildTree2(tree, expression, settings) {
    var options = optionsFromSettings(settings);
    var katexNode;
    if (settings.output === "mathml") {
      return buildMathML(tree, expression, options, settings.displayMode, true);
    } else if (settings.output === "html") {
      var htmlNode = buildHTML(tree, options);
      katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
    } else {
      var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
      var _htmlNode = buildHTML(tree, options);
      katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
    }
    return displayWrap(katexNode, settings);
  };
  var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
    var options = optionsFromSettings(settings);
    var htmlNode = buildHTML(tree, options);
    var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
    return displayWrap(katexNode, settings);
  };
  var stretchyCodePoint = {
    widehat: "^",
    widecheck: "\u02C7",
    widetilde: "~",
    utilde: "~",
    overleftarrow: "\u2190",
    underleftarrow: "\u2190",
    xleftarrow: "\u2190",
    overrightarrow: "\u2192",
    underrightarrow: "\u2192",
    xrightarrow: "\u2192",
    underbrace: "\u23DF",
    overbrace: "\u23DE",
    overgroup: "\u23E0",
    undergroup: "\u23E1",
    overleftrightarrow: "\u2194",
    underleftrightarrow: "\u2194",
    xleftrightarrow: "\u2194",
    Overrightarrow: "\u21D2",
    xRightarrow: "\u21D2",
    overleftharpoon: "\u21BC",
    xleftharpoonup: "\u21BC",
    overrightharpoon: "\u21C0",
    xrightharpoonup: "\u21C0",
    xLeftarrow: "\u21D0",
    xLeftrightarrow: "\u21D4",
    xhookleftarrow: "\u21A9",
    xhookrightarrow: "\u21AA",
    xmapsto: "\u21A6",
    xrightharpoondown: "\u21C1",
    xleftharpoondown: "\u21BD",
    xrightleftharpoons: "\u21CC",
    xleftrightharpoons: "\u21CB",
    xtwoheadleftarrow: "\u219E",
    xtwoheadrightarrow: "\u21A0",
    xlongequal: "=",
    xtofrom: "\u21C4",
    xrightleftarrows: "\u21C4",
    xrightequilibrium: "\u21CC",
    // Not a perfect match.
    xleftequilibrium: "\u21CB",
    // None better available.
    "\\cdrightarrow": "\u2192",
    "\\cdleftarrow": "\u2190",
    "\\cdlongequal": "="
  };
  var mathMLnode = function mathMLnode2(label) {
    var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
    node.setAttribute("stretchy", "true");
    return node;
  };
  var katexImagesData = {
    //   path(s), minWidth, height, align
    overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
    overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
    underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
    underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
    xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
    "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
    // CD minwwidth2.5pc
    xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
    "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
    Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
    xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
    xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
    overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
    xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
    xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
    overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
    xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
    xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
    xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
    "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
    xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
    xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
    overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
    overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
    underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
    underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
    xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
    xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
    xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
    xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
    xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
    xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
    overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
    underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
    overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
    undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
    xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
    xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
    // The next three arrows are from the mhchem package.
    // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
    // document as \xrightarrow or \xrightleftharpoons. Those have
    // min-length = 1.75em, so we set min-length on these next three to match.
    xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
    xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
    xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
  };
  var groupLength = function groupLength2(arg) {
    if (arg.type === "ordgroup") {
      return arg.body.length;
    } else {
      return 1;
    }
  };
  var svgSpan = function svgSpan2(group, options) {
    function buildSvgSpan_() {
      var viewBoxWidth = 4e5;
      var label = group.label.slice(1);
      if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
        var grp = group;
        var numChars = groupLength(grp.base);
        var viewBoxHeight;
        var pathName;
        var _height;
        if (numChars > 5) {
          if (label === "widehat" || label === "widecheck") {
            viewBoxHeight = 420;
            viewBoxWidth = 2364;
            _height = 0.42;
            pathName = label + "4";
          } else {
            viewBoxHeight = 312;
            viewBoxWidth = 2340;
            _height = 0.34;
            pathName = "tilde4";
          }
        } else {
          var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
          if (label === "widehat" || label === "widecheck") {
            viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
            viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
            _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
            pathName = label + imgIndex;
          } else {
            viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
            viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
            _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
            pathName = "tilde" + imgIndex;
          }
        }
        var path2 = new PathNode(pathName);
        var svgNode = new SvgNode([path2], {
          "width": "100%",
          "height": makeEm(_height),
          "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
          "preserveAspectRatio": "none"
        });
        return {
          span: buildCommon.makeSvgSpan([], [svgNode], options),
          minWidth: 0,
          height: _height
        };
      } else {
        var spans = [];
        var data = katexImagesData[label];
        var [paths, _minWidth, _viewBoxHeight] = data;
        var _height2 = _viewBoxHeight / 1e3;
        var numSvgChildren = paths.length;
        var widthClasses;
        var aligns;
        if (numSvgChildren === 1) {
          var align1 = data[3];
          widthClasses = ["hide-tail"];
          aligns = [align1];
        } else if (numSvgChildren === 2) {
          widthClasses = ["halfarrow-left", "halfarrow-right"];
          aligns = ["xMinYMin", "xMaxYMin"];
        } else if (numSvgChildren === 3) {
          widthClasses = ["brace-left", "brace-center", "brace-right"];
          aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
        } else {
          throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
        }
        for (var i4 = 0; i4 < numSvgChildren; i4++) {
          var _path = new PathNode(paths[i4]);
          var _svgNode = new SvgNode([_path], {
            "width": "400em",
            "height": makeEm(_height2),
            "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
            "preserveAspectRatio": aligns[i4] + " slice"
          });
          var _span = buildCommon.makeSvgSpan([widthClasses[i4]], [_svgNode], options);
          if (numSvgChildren === 1) {
            return {
              span: _span,
              minWidth: _minWidth,
              height: _height2
            };
          } else {
            _span.style.height = makeEm(_height2);
            spans.push(_span);
          }
        }
        return {
          span: buildCommon.makeSpan(["stretchy"], spans, options),
          minWidth: _minWidth,
          height: _height2
        };
      }
    }
    var {
      span,
      minWidth,
      height
    } = buildSvgSpan_();
    span.height = height;
    span.style.height = makeEm(height);
    if (minWidth > 0) {
      span.style.minWidth = makeEm(minWidth);
    }
    return span;
  };
  var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
    var img;
    var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
    if (/fbox|color|angl/.test(label)) {
      img = buildCommon.makeSpan(["stretchy", label], [], options);
      if (label === "fbox") {
        var color = options.color && options.getColor();
        if (color) {
          img.style.borderColor = color;
        }
      }
    } else {
      var lines = [];
      if (/^[bx]cancel$/.test(label)) {
        lines.push(new LineNode({
          "x1": "0",
          "y1": "0",
          "x2": "100%",
          "y2": "100%",
          "stroke-width": "0.046em"
        }));
      }
      if (/^x?cancel$/.test(label)) {
        lines.push(new LineNode({
          "x1": "0",
          "y1": "100%",
          "x2": "100%",
          "y2": "0",
          "stroke-width": "0.046em"
        }));
      }
      var svgNode = new SvgNode(lines, {
        "width": "100%",
        "height": makeEm(totalHeight)
      });
      img = buildCommon.makeSvgSpan([], [svgNode], options);
    }
    img.height = totalHeight;
    img.style.height = makeEm(totalHeight);
    return img;
  };
  var stretchy = {
    encloseSpan,
    mathMLnode,
    svgSpan
  };
  function assertNodeType(node, type) {
    if (!node || node.type !== type) {
      throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
    }
    return node;
  }
  function assertSymbolNodeType(node) {
    var typedNode = checkSymbolNodeType(node);
    if (!typedNode) {
      throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
    }
    return typedNode;
  }
  function checkSymbolNodeType(node) {
    if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
      return node;
    }
    return null;
  }
  var htmlBuilder$a = (grp, options) => {
    var base;
    var group;
    var supSubGroup;
    if (grp && grp.type === "supsub") {
      group = assertNodeType(grp.base, "accent");
      base = group.base;
      grp.base = base;
      supSubGroup = assertSpan(buildGroup$1(grp, options));
      grp.base = group;
    } else {
      group = assertNodeType(grp, "accent");
      base = group.base;
    }
    var body = buildGroup$1(base, options.havingCrampedStyle());
    var mustShift = group.isShifty && utils.isCharacterBox(base);
    var skew = 0;
    if (mustShift) {
      var baseChar = utils.getBaseElem(base);
      var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
      skew = assertSymbolDomNode(baseGroup).skew;
    }
    var accentBelow = group.label === "\\c";
    var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
    var accentBody;
    if (!group.isStretchy) {
      var accent2;
      var width;
      if (group.label === "\\vec") {
        accent2 = buildCommon.staticSvg("vec", options);
        width = buildCommon.svgData.vec[1];
      } else {
        accent2 = buildCommon.makeOrd({
          mode: group.mode,
          text: group.label
        }, options, "textord");
        accent2 = assertSymbolDomNode(accent2);
        accent2.italic = 0;
        width = accent2.width;
        if (accentBelow) {
          clearance += accent2.depth;
        }
      }
      accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
      var accentFull = group.label === "\\textcircled";
      if (accentFull) {
        accentBody.classes.push("accent-full");
        clearance = body.height;
      }
      var left = skew;
      if (!accentFull) {
        left -= width / 2;
      }
      accentBody.style.left = makeEm(left);
      if (group.label === "\\textcircled") {
        accentBody.style.top = ".2em";
      }
      accentBody = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: body
        }, {
          type: "kern",
          size: -clearance
        }, {
          type: "elem",
          elem: accentBody
        }]
      }, options);
    } else {
      accentBody = stretchy.svgSpan(group, options);
      accentBody = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: body
        }, {
          type: "elem",
          elem: accentBody,
          wrapperClasses: ["svg-align"],
          wrapperStyle: skew > 0 ? {
            width: "calc(100% - " + makeEm(2 * skew) + ")",
            marginLeft: makeEm(2 * skew)
          } : void 0
        }]
      }, options);
    }
    var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
    if (supSubGroup) {
      supSubGroup.children[0] = accentWrap;
      supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
      supSubGroup.classes[0] = "mord";
      return supSubGroup;
    } else {
      return accentWrap;
    }
  };
  var mathmlBuilder$9 = (group, options) => {
    var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
    var node = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
    node.setAttribute("accent", "true");
    return node;
  };
  var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
  defineFunction({
    type: "accent",
    names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
    props: {
      numArgs: 1
    },
    handler: (context, args) => {
      var base = normalizeArgument(args[0]);
      var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
      var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
      return {
        type: "accent",
        mode: context.parser.mode,
        label: context.funcName,
        isStretchy,
        isShifty,
        base
      };
    },
    htmlBuilder: htmlBuilder$a,
    mathmlBuilder: mathmlBuilder$9
  });
  defineFunction({
    type: "accent",
    names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
    props: {
      numArgs: 1,
      allowedInText: true,
      allowedInMath: true,
      // unless in strict mode
      argTypes: ["primitive"]
    },
    handler: (context, args) => {
      var base = args[0];
      var mode = context.parser.mode;
      if (mode === "math") {
        context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
        mode = "text";
      }
      return {
        type: "accent",
        mode,
        label: context.funcName,
        isStretchy: false,
        isShifty: true,
        base
      };
    },
    htmlBuilder: htmlBuilder$a,
    mathmlBuilder: mathmlBuilder$9
  });
  defineFunction({
    type: "accentUnder",
    names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
    props: {
      numArgs: 1
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var base = args[0];
      return {
        type: "accentUnder",
        mode: parser.mode,
        label: funcName,
        base
      };
    },
    htmlBuilder: (group, options) => {
      var innerGroup = buildGroup$1(group.base, options);
      var accentBody = stretchy.svgSpan(group, options);
      var kern = group.label === "\\utilde" ? 0.12 : 0;
      var vlist = buildCommon.makeVList({
        positionType: "top",
        positionData: innerGroup.height,
        children: [{
          type: "elem",
          elem: accentBody,
          wrapperClasses: ["svg-align"]
        }, {
          type: "kern",
          size: kern
        }, {
          type: "elem",
          elem: innerGroup
        }]
      }, options);
      return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
    },
    mathmlBuilder: (group, options) => {
      var accentNode = stretchy.mathMLnode(group.label);
      var node = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
      node.setAttribute("accentunder", "true");
      return node;
    }
  });
  var paddedNode = (group) => {
    var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
    node.setAttribute("width", "+0.6em");
    node.setAttribute("lspace", "0.3em");
    return node;
  };
  defineFunction({
    type: "xArrow",
    names: [
      "\\xleftarrow",
      "\\xrightarrow",
      "\\xLeftarrow",
      "\\xRightarrow",
      "\\xleftrightarrow",
      "\\xLeftrightarrow",
      "\\xhookleftarrow",
      "\\xhookrightarrow",
      "\\xmapsto",
      "\\xrightharpoondown",
      "\\xrightharpoonup",
      "\\xleftharpoondown",
      "\\xleftharpoonup",
      "\\xrightleftharpoons",
      "\\xleftrightharpoons",
      "\\xlongequal",
      "\\xtwoheadrightarrow",
      "\\xtwoheadleftarrow",
      "\\xtofrom",
      // The next 3 functions are here to support the mhchem extension.
      // Direct use of these functions is discouraged and may break someday.
      "\\xrightleftarrows",
      "\\xrightequilibrium",
      "\\xleftequilibrium",
      // The next 3 functions are here only to support the {CD} environment.
      "\\\\cdrightarrow",
      "\\\\cdleftarrow",
      "\\\\cdlongequal"
    ],
    props: {
      numArgs: 1,
      numOptionalArgs: 1
    },
    handler(_ref, args, optArgs) {
      var {
        parser,
        funcName
      } = _ref;
      return {
        type: "xArrow",
        mode: parser.mode,
        label: funcName,
        body: args[0],
        below: optArgs[0]
      };
    },
    // Flow is unable to correctly infer the type of `group`, even though it's
    // unambiguously determined from the passed-in `type` above.
    htmlBuilder(group, options) {
      var style = options.style;
      var newOptions = options.havingStyle(style.sup());
      var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
      var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
      upperGroup.classes.push(arrowPrefix + "-arrow-pad");
      var lowerGroup;
      if (group.below) {
        newOptions = options.havingStyle(style.sub());
        lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
        lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
      }
      var arrowBody = stretchy.svgSpan(group, options);
      var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
      var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
      if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
        upperShift -= upperGroup.depth;
      }
      var vlist;
      if (lowerGroup) {
        var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: upperGroup,
            shift: upperShift
          }, {
            type: "elem",
            elem: arrowBody,
            shift: arrowShift
          }, {
            type: "elem",
            elem: lowerGroup,
            shift: lowerShift
          }]
        }, options);
      } else {
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: upperGroup,
            shift: upperShift
          }, {
            type: "elem",
            elem: arrowBody,
            shift: arrowShift
          }]
        }, options);
      }
      vlist.children[0].children[0].children[1].classes.push("svg-align");
      return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
    },
    mathmlBuilder(group, options) {
      var arrowNode = stretchy.mathMLnode(group.label);
      arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
      var node;
      if (group.body) {
        var upperNode = paddedNode(buildGroup2(group.body, options));
        if (group.below) {
          var lowerNode = paddedNode(buildGroup2(group.below, options));
          node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
        } else {
          node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
        }
      } else if (group.below) {
        var _lowerNode = paddedNode(buildGroup2(group.below, options));
        node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
      } else {
        node = paddedNode();
        node = new mathMLTree.MathNode("mover", [arrowNode, node]);
      }
      return node;
    }
  });
  var makeSpan2 = buildCommon.makeSpan;
  function htmlBuilder$9(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    return makeSpan2([group.mclass], elements, options);
  }
  function mathmlBuilder$8(group, options) {
    var node;
    var inner2 = buildExpression2(group.body, options);
    if (group.mclass === "minner") {
      node = new mathMLTree.MathNode("mpadded", inner2);
    } else if (group.mclass === "mord") {
      if (group.isCharacterBox) {
        node = inner2[0];
        node.type = "mi";
      } else {
        node = new mathMLTree.MathNode("mi", inner2);
      }
    } else {
      if (group.isCharacterBox) {
        node = inner2[0];
        node.type = "mo";
      } else {
        node = new mathMLTree.MathNode("mo", inner2);
      }
      if (group.mclass === "mbin") {
        node.attributes.lspace = "0.22em";
        node.attributes.rspace = "0.22em";
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0.17em";
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner") {
        node.attributes.lspace = "0.0556em";
        node.attributes.width = "+0.1111em";
      }
    }
    return node;
  }
  defineFunction({
    type: "mclass",
    names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
    props: {
      numArgs: 1,
      primitive: true
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      var body = args[0];
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: "m" + funcName.slice(5),
        // TODO(kevinb): don't prefix with 'm'
        body: ordargument(body),
        isCharacterBox: utils.isCharacterBox(body)
      };
    },
    htmlBuilder: htmlBuilder$9,
    mathmlBuilder: mathmlBuilder$8
  });
  var binrelClass = (arg) => {
    var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
    if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
      return "m" + atom.family;
    } else {
      return "mord";
    }
  };
  defineFunction({
    type: "mclass",
    names: ["\\@binrel"],
    props: {
      numArgs: 2
    },
    handler(_ref2, args) {
      var {
        parser
      } = _ref2;
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: binrelClass(args[0]),
        body: ordargument(args[1]),
        isCharacterBox: utils.isCharacterBox(args[1])
      };
    }
  });
  defineFunction({
    type: "mclass",
    names: ["\\stackrel", "\\overset", "\\underset"],
    props: {
      numArgs: 2
    },
    handler(_ref3, args) {
      var {
        parser,
        funcName
      } = _ref3;
      var baseArg = args[1];
      var shiftedArg = args[0];
      var mclass;
      if (funcName !== "\\stackrel") {
        mclass = binrelClass(baseArg);
      } else {
        mclass = "mrel";
      }
      var baseOp = {
        type: "op",
        mode: baseArg.mode,
        limits: true,
        alwaysHandleSupSub: true,
        parentIsSupSub: false,
        symbol: false,
        suppressBaseShift: funcName !== "\\stackrel",
        body: ordargument(baseArg)
      };
      var supsub = {
        type: "supsub",
        mode: shiftedArg.mode,
        base: baseOp,
        sup: funcName === "\\underset" ? null : shiftedArg,
        sub: funcName === "\\underset" ? shiftedArg : null
      };
      return {
        type: "mclass",
        mode: parser.mode,
        mclass,
        body: [supsub],
        isCharacterBox: utils.isCharacterBox(supsub)
      };
    },
    htmlBuilder: htmlBuilder$9,
    mathmlBuilder: mathmlBuilder$8
  });
  defineFunction({
    type: "pmb",
    names: ["\\pmb"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      return {
        type: "pmb",
        mode: parser.mode,
        mclass: binrelClass(args[0]),
        body: ordargument(args[0])
      };
    },
    htmlBuilder(group, options) {
      var elements = buildExpression$1(group.body, options, true);
      var node = buildCommon.makeSpan([group.mclass], elements, options);
      node.style.textShadow = "0.02em 0.01em 0.04px";
      return node;
    },
    mathmlBuilder(group, style) {
      var inner2 = buildExpression2(group.body, style);
      var node = new mathMLTree.MathNode("mstyle", inner2);
      node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
      return node;
    }
  });
  var cdArrowFunctionName = {
    ">": "\\\\cdrightarrow",
    "<": "\\\\cdleftarrow",
    "=": "\\\\cdlongequal",
    "A": "\\uparrow",
    "V": "\\downarrow",
    "|": "\\Vert",
    ".": "no arrow"
  };
  var newCell = () => {
    return {
      type: "styling",
      body: [],
      mode: "math",
      style: "display"
    };
  };
  var isStartOfArrow = (node) => {
    return node.type === "textord" && node.text === "@";
  };
  var isLabelEnd = (node, endChar) => {
    return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
  };
  function cdArrow(arrowChar, labels, parser) {
    var funcName = cdArrowFunctionName[arrowChar];
    switch (funcName) {
      case "\\\\cdrightarrow":
      case "\\\\cdleftarrow":
        return parser.callFunction(funcName, [labels[0]], [labels[1]]);
      case "\\uparrow":
      case "\\downarrow": {
        var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
        var bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
        var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
        var arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser.callFunction("\\\\cdparent", [arrowGroup], []);
      }
      case "\\\\cdlongequal":
        return parser.callFunction("\\\\cdlongequal", [], []);
      case "\\Vert": {
        var arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser.callFunction("\\Big", [arrow], []);
      }
      default:
        return {
          type: "textord",
          text: " ",
          mode: "math"
        };
    }
  }
  function parseCD(parser) {
    var parsedRows = [];
    parser.gullet.beginGroup();
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
    parser.gullet.beginGroup();
    while (true) {
      parsedRows.push(parser.parseExpression(false, "\\\\"));
      parser.gullet.endGroup();
      parser.gullet.beginGroup();
      var next = parser.fetch().text;
      if (next === "&" || next === "\\\\") {
        parser.consume();
      } else if (next === "\\end") {
        if (parsedRows[parsedRows.length - 1].length === 0) {
          parsedRows.pop();
        }
        break;
      } else {
        throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
      }
    }
    var row = [];
    var body = [row];
    for (var i4 = 0; i4 < parsedRows.length; i4++) {
      var rowNodes = parsedRows[i4];
      var cell = newCell();
      for (var j3 = 0; j3 < rowNodes.length; j3++) {
        if (!isStartOfArrow(rowNodes[j3])) {
          cell.body.push(rowNodes[j3]);
        } else {
          row.push(cell);
          j3 += 1;
          var arrowChar = assertSymbolNodeType(rowNodes[j3]).text;
          var labels = new Array(2);
          labels[0] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          labels[1] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          if ("=|.".indexOf(arrowChar) > -1)
            ;
          else if ("<>AV".indexOf(arrowChar) > -1) {
            for (var labelNum = 0; labelNum < 2; labelNum++) {
              var inLabel = true;
              for (var k4 = j3 + 1; k4 < rowNodes.length; k4++) {
                if (isLabelEnd(rowNodes[k4], arrowChar)) {
                  inLabel = false;
                  j3 = k4;
                  break;
                }
                if (isStartOfArrow(rowNodes[k4])) {
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k4]);
                }
                labels[labelNum].body.push(rowNodes[k4]);
              }
              if (inLabel) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j3]);
              }
            }
          } else {
            throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j3]);
          }
          var arrow = cdArrow(arrowChar, labels, parser);
          var wrappedArrow = {
            type: "styling",
            body: [arrow],
            mode: "math",
            style: "display"
            // CD is always displaystyle.
          };
          row.push(wrappedArrow);
          cell = newCell();
        }
      }
      if (i4 % 2 === 0) {
        row.push(cell);
      } else {
        row.shift();
      }
      row = [];
      body.push(row);
    }
    parser.gullet.endGroup();
    parser.gullet.endGroup();
    var cols = new Array(body[0].length).fill({
      type: "align",
      align: "c",
      pregap: 0.25,
      // CD package sets \enskip between columns.
      postgap: 0.25
      // So pre and post each get half an \enskip, i.e. 0.25em.
    });
    return {
      type: "array",
      mode: "math",
      body,
      arraystretch: 1,
      addJot: true,
      rowGaps: [null],
      cols,
      colSeparationType: "CD",
      hLinesBeforeRow: new Array(body.length + 1).fill([])
    };
  }
  defineFunction({
    type: "cdlabel",
    names: ["\\\\cdleft", "\\\\cdright"],
    props: {
      numArgs: 1
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      return {
        type: "cdlabel",
        mode: parser.mode,
        side: funcName.slice(4),
        label: args[0]
      };
    },
    htmlBuilder(group, options) {
      var newOptions = options.havingStyle(options.style.sup());
      var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
      label.classes.push("cd-label-" + group.side);
      label.style.bottom = makeEm(0.8 - label.depth);
      label.height = 0;
      label.depth = 0;
      return label;
    },
    mathmlBuilder(group, options) {
      var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
      label = new mathMLTree.MathNode("mpadded", [label]);
      label.setAttribute("width", "0");
      if (group.side === "left") {
        label.setAttribute("lspace", "-1width");
      }
      label.setAttribute("voffset", "0.7em");
      label = new mathMLTree.MathNode("mstyle", [label]);
      label.setAttribute("displaystyle", "false");
      label.setAttribute("scriptlevel", "1");
      return label;
    }
  });
  defineFunction({
    type: "cdlabelparent",
    names: ["\\\\cdparent"],
    props: {
      numArgs: 1
    },
    handler(_ref2, args) {
      var {
        parser
      } = _ref2;
      return {
        type: "cdlabelparent",
        mode: parser.mode,
        fragment: args[0]
      };
    },
    htmlBuilder(group, options) {
      var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
      parent.classes.push("cd-vert-arrow");
      return parent;
    },
    mathmlBuilder(group, options) {
      return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
    }
  });
  defineFunction({
    type: "textord",
    names: ["\\@char"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      var arg = assertNodeType(args[0], "ordgroup");
      var group = arg.body;
      var number = "";
      for (var i4 = 0; i4 < group.length; i4++) {
        var node = assertNodeType(group[i4], "textord");
        number += node.text;
      }
      var code = parseInt(number);
      var text2;
      if (isNaN(code)) {
        throw new ParseError("\\@char has non-numeric argument " + number);
      } else if (code < 0 || code >= 1114111) {
        throw new ParseError("\\@char with invalid code point " + number);
      } else if (code <= 65535) {
        text2 = String.fromCharCode(code);
      } else {
        code -= 65536;
        text2 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      return {
        type: "textord",
        mode: parser.mode,
        text: text2
      };
    }
  });
  var htmlBuilder$8 = (group, options) => {
    var elements = buildExpression$1(group.body, options.withColor(group.color), false);
    return buildCommon.makeFragment(elements);
  };
  var mathmlBuilder$7 = (group, options) => {
    var inner2 = buildExpression2(group.body, options.withColor(group.color));
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("mathcolor", group.color);
    return node;
  };
  defineFunction({
    type: "color",
    names: ["\\textcolor"],
    props: {
      numArgs: 2,
      allowedInText: true,
      argTypes: ["color", "original"]
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      var color = assertNodeType(args[0], "color-token").color;
      var body = args[1];
      return {
        type: "color",
        mode: parser.mode,
        color,
        body: ordargument(body)
      };
    },
    htmlBuilder: htmlBuilder$8,
    mathmlBuilder: mathmlBuilder$7
  });
  defineFunction({
    type: "color",
    names: ["\\color"],
    props: {
      numArgs: 1,
      allowedInText: true,
      argTypes: ["color"]
    },
    handler(_ref2, args) {
      var {
        parser,
        breakOnTokenText
      } = _ref2;
      var color = assertNodeType(args[0], "color-token").color;
      parser.gullet.macros.set("\\current@color", color);
      var body = parser.parseExpression(true, breakOnTokenText);
      return {
        type: "color",
        mode: parser.mode,
        color,
        body
      };
    },
    htmlBuilder: htmlBuilder$8,
    mathmlBuilder: mathmlBuilder$7
  });
  defineFunction({
    type: "cr",
    names: ["\\\\"],
    props: {
      numArgs: 0,
      numOptionalArgs: 0,
      allowedInText: true
    },
    handler(_ref, args, optArgs) {
      var {
        parser
      } = _ref;
      var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
      var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
      return {
        type: "cr",
        mode: parser.mode,
        newLine,
        size: size && assertNodeType(size, "size").value
      };
    },
    // The following builders are called only at the top level,
    // not within tabular/array environments.
    htmlBuilder(group, options) {
      var span = buildCommon.makeSpan(["mspace"], [], options);
      if (group.newLine) {
        span.classes.push("newline");
        if (group.size) {
          span.style.marginTop = makeEm(calculateSize(group.size, options));
        }
      }
      return span;
    },
    mathmlBuilder(group, options) {
      var node = new mathMLTree.MathNode("mspace");
      if (group.newLine) {
        node.setAttribute("linebreak", "newline");
        if (group.size) {
          node.setAttribute("height", makeEm(calculateSize(group.size, options)));
        }
      }
      return node;
    }
  });
  var globalMap = {
    "\\global": "\\global",
    "\\long": "\\\\globallong",
    "\\\\globallong": "\\\\globallong",
    "\\def": "\\gdef",
    "\\gdef": "\\gdef",
    "\\edef": "\\xdef",
    "\\xdef": "\\xdef",
    "\\let": "\\\\globallet",
    "\\futurelet": "\\\\globalfuture"
  };
  var checkControlSequence = (tok) => {
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    return name;
  };
  var getRHS = (parser) => {
    var tok = parser.gullet.popToken();
    if (tok.text === "=") {
      tok = parser.gullet.popToken();
      if (tok.text === " ") {
        tok = parser.gullet.popToken();
      }
    }
    return tok;
  };
  var letCommand = (parser, name, tok, global) => {
    var macro = parser.gullet.macros.get(tok.text);
    if (macro == null) {
      tok.noexpand = true;
      macro = {
        tokens: [tok],
        numArgs: 0,
        // reproduce the same behavior in expansion
        unexpandable: !parser.gullet.isExpandable(tok.text)
      };
    }
    parser.gullet.macros.set(name, macro, global);
  };
  defineFunction({
    type: "internal",
    names: [
      "\\global",
      "\\long",
      "\\\\globallong"
      // cant be entered directly
    ],
    props: {
      numArgs: 0,
      allowedInText: true
    },
    handler(_ref) {
      var {
        parser,
        funcName
      } = _ref;
      parser.consumeSpaces();
      var token = parser.fetch();
      if (globalMap[token.text]) {
        if (funcName === "\\global" || funcName === "\\\\globallong") {
          token.text = globalMap[token.text];
        }
        return assertNodeType(parser.parseFunction(), "internal");
      }
      throw new ParseError("Invalid token after macro prefix", token);
    }
  });
  defineFunction({
    type: "internal",
    names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
    props: {
      numArgs: 0,
      allowedInText: true,
      primitive: true
    },
    handler(_ref2) {
      var {
        parser,
        funcName
      } = _ref2;
      var tok = parser.gullet.popToken();
      var name = tok.text;
      if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
        throw new ParseError("Expected a control sequence", tok);
      }
      var numArgs = 0;
      var insert;
      var delimiters2 = [[]];
      while (parser.gullet.future().text !== "{") {
        tok = parser.gullet.popToken();
        if (tok.text === "#") {
          if (parser.gullet.future().text === "{") {
            insert = parser.gullet.future();
            delimiters2[numArgs].push("{");
            break;
          }
          tok = parser.gullet.popToken();
          if (!/^[1-9]$/.test(tok.text)) {
            throw new ParseError('Invalid argument number "' + tok.text + '"');
          }
          if (parseInt(tok.text) !== numArgs + 1) {
            throw new ParseError('Argument number "' + tok.text + '" out of order');
          }
          numArgs++;
          delimiters2.push([]);
        } else if (tok.text === "EOF") {
          throw new ParseError("Expected a macro definition");
        } else {
          delimiters2[numArgs].push(tok.text);
        }
      }
      var {
        tokens
      } = parser.gullet.consumeArg();
      if (insert) {
        tokens.unshift(insert);
      }
      if (funcName === "\\edef" || funcName === "\\xdef") {
        tokens = parser.gullet.expandTokens(tokens);
        tokens.reverse();
      }
      parser.gullet.macros.set(name, {
        tokens,
        numArgs,
        delimiters: delimiters2
      }, funcName === globalMap[funcName]);
      return {
        type: "internal",
        mode: parser.mode
      };
    }
  });
  defineFunction({
    type: "internal",
    names: [
      "\\let",
      "\\\\globallet"
      // cant be entered directly
    ],
    props: {
      numArgs: 0,
      allowedInText: true,
      primitive: true
    },
    handler(_ref3) {
      var {
        parser,
        funcName
      } = _ref3;
      var name = checkControlSequence(parser.gullet.popToken());
      parser.gullet.consumeSpaces();
      var tok = getRHS(parser);
      letCommand(parser, name, tok, funcName === "\\\\globallet");
      return {
        type: "internal",
        mode: parser.mode
      };
    }
  });
  defineFunction({
    type: "internal",
    names: [
      "\\futurelet",
      "\\\\globalfuture"
      // cant be entered directly
    ],
    props: {
      numArgs: 0,
      allowedInText: true,
      primitive: true
    },
    handler(_ref4) {
      var {
        parser,
        funcName
      } = _ref4;
      var name = checkControlSequence(parser.gullet.popToken());
      var middle = parser.gullet.popToken();
      var tok = parser.gullet.popToken();
      letCommand(parser, name, tok, funcName === "\\\\globalfuture");
      parser.gullet.pushToken(tok);
      parser.gullet.pushToken(middle);
      return {
        type: "internal",
        mode: parser.mode
      };
    }
  });
  var getMetrics = function getMetrics2(symbol, font, mode) {
    var replace = symbols.math[symbol] && symbols.math[symbol].replace;
    var metrics = getCharacterMetrics(replace || symbol, font, mode);
    if (!metrics) {
      throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
    }
    return metrics;
  };
  var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
    var newOptions = options.havingBaseStyle(toStyle);
    var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
    var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
    span.height *= delimSizeMultiplier;
    span.depth *= delimSizeMultiplier;
    span.maxFontSize = newOptions.sizeMultiplier;
    return span;
  };
  var centerSpan = function centerSpan2(span, options, style) {
    var newOptions = options.havingBaseStyle(style);
    var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
    span.classes.push("delimcenter");
    span.style.top = makeEm(shift);
    span.height -= shift;
    span.depth += shift;
  };
  var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
    var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
    var span = styleWrap(text2, style, options, classes);
    if (center) {
      centerSpan(span, options, style);
    }
    return span;
  };
  var mathrmSize = function mathrmSize2(value, size, mode, options) {
    return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
  };
  var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
    var inner2 = mathrmSize(delim, size, mode, options);
    var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), Style$1.TEXT, options, classes);
    if (center) {
      centerSpan(span, options, Style$1.TEXT);
    }
    return span;
  };
  var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
    var sizeClass;
    if (font === "Size1-Regular") {
      sizeClass = "delim-size1";
    } else {
      sizeClass = "delim-size4";
    }
    var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
    return {
      type: "elem",
      elem: corner
    };
  };
  var makeInner = function makeInner2(ch, height, options) {
    var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
    var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
    var svgNode = new SvgNode([path2], {
      "width": makeEm(width),
      "height": makeEm(height),
      // Override CSS rule `.katex svg { width: 100% }`
      "style": "width:" + makeEm(width),
      "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
      "preserveAspectRatio": "xMinYMin"
    });
    var span = buildCommon.makeSvgSpan([], [svgNode], options);
    span.height = height;
    span.style.height = makeEm(height);
    span.style.width = makeEm(width);
    return {
      type: "elem",
      elem: span
    };
  };
  var lapInEms = 8e-3;
  var lap = {
    type: "kern",
    size: -1 * lapInEms
  };
  var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
  var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
  var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
    var top;
    var middle;
    var repeat;
    var bottom;
    var svgLabel = "";
    var viewBoxWidth = 0;
    top = repeat = bottom = delim;
    middle = null;
    var font = "Size1-Regular";
    if (delim === "\\uparrow") {
      repeat = bottom = "\u23D0";
    } else if (delim === "\\Uparrow") {
      repeat = bottom = "\u2016";
    } else if (delim === "\\downarrow") {
      top = repeat = "\u23D0";
    } else if (delim === "\\Downarrow") {
      top = repeat = "\u2016";
    } else if (delim === "\\updownarrow") {
      top = "\\uparrow";
      repeat = "\u23D0";
      bottom = "\\downarrow";
    } else if (delim === "\\Updownarrow") {
      top = "\\Uparrow";
      repeat = "\u2016";
      bottom = "\\Downarrow";
    } else if (utils.contains(verts, delim)) {
      repeat = "\u2223";
      svgLabel = "vert";
      viewBoxWidth = 333;
    } else if (utils.contains(doubleVerts, delim)) {
      repeat = "\u2225";
      svgLabel = "doublevert";
      viewBoxWidth = 556;
    } else if (delim === "[" || delim === "\\lbrack") {
      top = "\u23A1";
      repeat = "\u23A2";
      bottom = "\u23A3";
      font = "Size4-Regular";
      svgLabel = "lbrack";
      viewBoxWidth = 667;
    } else if (delim === "]" || delim === "\\rbrack") {
      top = "\u23A4";
      repeat = "\u23A5";
      bottom = "\u23A6";
      font = "Size4-Regular";
      svgLabel = "rbrack";
      viewBoxWidth = 667;
    } else if (delim === "\\lfloor" || delim === "\u230A") {
      repeat = top = "\u23A2";
      bottom = "\u23A3";
      font = "Size4-Regular";
      svgLabel = "lfloor";
      viewBoxWidth = 667;
    } else if (delim === "\\lceil" || delim === "\u2308") {
      top = "\u23A1";
      repeat = bottom = "\u23A2";
      font = "Size4-Regular";
      svgLabel = "lceil";
      viewBoxWidth = 667;
    } else if (delim === "\\rfloor" || delim === "\u230B") {
      repeat = top = "\u23A5";
      bottom = "\u23A6";
      font = "Size4-Regular";
      svgLabel = "rfloor";
      viewBoxWidth = 667;
    } else if (delim === "\\rceil" || delim === "\u2309") {
      top = "\u23A4";
      repeat = bottom = "\u23A5";
      font = "Size4-Regular";
      svgLabel = "rceil";
      viewBoxWidth = 667;
    } else if (delim === "(" || delim === "\\lparen") {
      top = "\u239B";
      repeat = "\u239C";
      bottom = "\u239D";
      font = "Size4-Regular";
      svgLabel = "lparen";
      viewBoxWidth = 875;
    } else if (delim === ")" || delim === "\\rparen") {
      top = "\u239E";
      repeat = "\u239F";
      bottom = "\u23A0";
      font = "Size4-Regular";
      svgLabel = "rparen";
      viewBoxWidth = 875;
    } else if (delim === "\\{" || delim === "\\lbrace") {
      top = "\u23A7";
      middle = "\u23A8";
      bottom = "\u23A9";
      repeat = "\u23AA";
      font = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
      top = "\u23AB";
      middle = "\u23AC";
      bottom = "\u23AD";
      repeat = "\u23AA";
      font = "Size4-Regular";
    } else if (delim === "\\lgroup" || delim === "\u27EE") {
      top = "\u23A7";
      bottom = "\u23A9";
      repeat = "\u23AA";
      font = "Size4-Regular";
    } else if (delim === "\\rgroup" || delim === "\u27EF") {
      top = "\u23AB";
      bottom = "\u23AD";
      repeat = "\u23AA";
      font = "Size4-Regular";
    } else if (delim === "\\lmoustache" || delim === "\u23B0") {
      top = "\u23A7";
      bottom = "\u23AD";
      repeat = "\u23AA";
      font = "Size4-Regular";
    } else if (delim === "\\rmoustache" || delim === "\u23B1") {
      top = "\u23AB";
      bottom = "\u23A9";
      repeat = "\u23AA";
      font = "Size4-Regular";
    }
    var topMetrics = getMetrics(top, font, mode);
    var topHeightTotal = topMetrics.height + topMetrics.depth;
    var repeatMetrics = getMetrics(repeat, font, mode);
    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    var bottomMetrics = getMetrics(bottom, font, mode);
    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    var middleHeightTotal = 0;
    var middleFactor = 1;
    if (middle !== null) {
      var middleMetrics = getMetrics(middle, font, mode);
      middleHeightTotal = middleMetrics.height + middleMetrics.depth;
      middleFactor = 2;
    }
    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
    var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
    var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
    var axisHeight = options.fontMetrics().axisHeight;
    if (center) {
      axisHeight *= options.sizeMultiplier;
    }
    var depth = realHeightTotal / 2 - axisHeight;
    var stack = [];
    if (svgLabel.length > 0) {
      var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
      var viewBoxHeight = Math.round(realHeightTotal * 1e3);
      var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
      var path2 = new PathNode(svgLabel, pathStr);
      var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
      var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
      var svg = new SvgNode([path2], {
        "width": width,
        "height": height,
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
      });
      var wrapper = buildCommon.makeSvgSpan([], [svg], options);
      wrapper.height = viewBoxHeight / 1e3;
      wrapper.style.width = width;
      wrapper.style.height = height;
      stack.push({
        type: "elem",
        elem: wrapper
      });
    } else {
      stack.push(makeGlyphSpan(bottom, font, mode));
      stack.push(lap);
      if (middle === null) {
        var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
        stack.push(makeInner(repeat, innerHeight, options));
      } else {
        var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
        stack.push(makeInner(repeat, _innerHeight, options));
        stack.push(lap);
        stack.push(makeGlyphSpan(middle, font, mode));
        stack.push(lap);
        stack.push(makeInner(repeat, _innerHeight, options));
      }
      stack.push(lap);
      stack.push(makeGlyphSpan(top, font, mode));
    }
    var newOptions = options.havingBaseStyle(Style$1.TEXT);
    var inner2 = buildCommon.makeVList({
      positionType: "bottom",
      positionData: depth,
      children: stack
    }, newOptions);
    return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes);
  };
  var vbPad = 80;
  var emPad = 0.08;
  var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
    var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
    var pathNode = new PathNode(sqrtName, path2);
    var svg = new SvgNode([pathNode], {
      // Note: 1000:1 ratio of viewBox to document em width.
      "width": "400em",
      "height": makeEm(height),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
  };
  var makeSqrtImage = function makeSqrtImage2(height, options) {
    var newOptions = options.havingBaseSizing();
    var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
    var sizeMultiplier = newOptions.sizeMultiplier;
    var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
    var span;
    var spanHeight = 0;
    var texHeight = 0;
    var viewBoxHeight = 0;
    var advanceWidth;
    if (delim.type === "small") {
      viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
      if (height < 1) {
        sizeMultiplier = 1;
      } else if (height < 1.4) {
        sizeMultiplier = 0.7;
      }
      spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
      texHeight = (1 + extraVinculum) / sizeMultiplier;
      span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
      span.style.minWidth = "0.853em";
      advanceWidth = 0.833 / sizeMultiplier;
    } else if (delim.type === "large") {
      viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
      texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
      spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
      span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
      span.style.minWidth = "1.02em";
      advanceWidth = 1 / sizeMultiplier;
    } else {
      spanHeight = height + extraVinculum + emPad;
      texHeight = height + extraVinculum;
      viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
      span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
      span.style.minWidth = "0.742em";
      advanceWidth = 1.056;
    }
    span.height = texHeight;
    span.style.height = makeEm(spanHeight);
    return {
      span,
      advanceWidth,
      // Calculate the actual line width.
      // This actually should depend on the chosen font -- e.g. \boldmath
      // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
      // have thicker rules.
      ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
    };
  };
  var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
  var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
  var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
  var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
  var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
    if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
      delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
      delim = "\\rangle";
    }
    if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
      return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
      return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
      throw new ParseError("Illegal delimiter: '" + delim + "'");
    }
  };
  var stackNeverDelimiterSequence = [{
    type: "small",
    style: Style$1.SCRIPTSCRIPT
  }, {
    type: "small",
    style: Style$1.SCRIPT
  }, {
    type: "small",
    style: Style$1.TEXT
  }, {
    type: "large",
    size: 1
  }, {
    type: "large",
    size: 2
  }, {
    type: "large",
    size: 3
  }, {
    type: "large",
    size: 4
  }];
  var stackAlwaysDelimiterSequence = [{
    type: "small",
    style: Style$1.SCRIPTSCRIPT
  }, {
    type: "small",
    style: Style$1.SCRIPT
  }, {
    type: "small",
    style: Style$1.TEXT
  }, {
    type: "stack"
  }];
  var stackLargeDelimiterSequence = [{
    type: "small",
    style: Style$1.SCRIPTSCRIPT
  }, {
    type: "small",
    style: Style$1.SCRIPT
  }, {
    type: "small",
    style: Style$1.TEXT
  }, {
    type: "large",
    size: 1
  }, {
    type: "large",
    size: 2
  }, {
    type: "large",
    size: 3
  }, {
    type: "large",
    size: 4
  }, {
    type: "stack"
  }];
  var delimTypeToFont = function delimTypeToFont2(type) {
    if (type.type === "small") {
      return "Main-Regular";
    } else if (type.type === "large") {
      return "Size" + type.size + "-Regular";
    } else if (type.type === "stack") {
      return "Size4-Regular";
    } else {
      throw new Error("Add support for delim type '" + type.type + "' here.");
    }
  };
  var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
    var start = Math.min(2, 3 - options.style.size);
    for (var i4 = start; i4 < sequence.length; i4++) {
      if (sequence[i4].type === "stack") {
        break;
      }
      var metrics = getMetrics(delim, delimTypeToFont(sequence[i4]), "math");
      var heightDepth = metrics.height + metrics.depth;
      if (sequence[i4].type === "small") {
        var newOptions = options.havingBaseStyle(sequence[i4].style);
        heightDepth *= newOptions.sizeMultiplier;
      }
      if (heightDepth > height) {
        return sequence[i4];
      }
    }
    return sequence[sequence.length - 1];
  };
  var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
    if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
      delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
      delim = "\\rangle";
    }
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
      sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
      sequence = stackLargeDelimiterSequence;
    } else {
      sequence = stackAlwaysDelimiterSequence;
    }
    var delimType = traverseSequence(delim, height, sequence, options);
    if (delimType.type === "small") {
      return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
    } else if (delimType.type === "large") {
      return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
    } else {
      return makeStackedDelim(delim, height, center, options, mode, classes);
    }
  };
  var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
    var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
    var delimiterFactor = 901;
    var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
    var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
    var totalHeight = Math.max(
      // In real TeX, calculations are done using integral values which are
      // 65536 per pt, or 655360 per em. So, the division here truncates in
      // TeX but doesn't here, producing different results. If we wanted to
      // exactly match TeX's calculation, we could do
      //   Math.floor(655360 * maxDistFromAxis / 500) *
      //    delimiterFactor / 655360
      // (To see the difference, compare
      //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
      // in TeX and KaTeX)
      maxDistFromAxis / 500 * delimiterFactor,
      2 * maxDistFromAxis - delimiterExtend
    );
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
  };
  var delimiter = {
    sqrtImage: makeSqrtImage,
    sizedDelim: makeSizedDelim,
    sizeToMaxHeight,
    customSizedDelim: makeCustomSizedDelim,
    leftRightDelim: makeLeftRightDelim
  };
  var delimiterSizes = {
    "\\bigl": {
      mclass: "mopen",
      size: 1
    },
    "\\Bigl": {
      mclass: "mopen",
      size: 2
    },
    "\\biggl": {
      mclass: "mopen",
      size: 3
    },
    "\\Biggl": {
      mclass: "mopen",
      size: 4
    },
    "\\bigr": {
      mclass: "mclose",
      size: 1
    },
    "\\Bigr": {
      mclass: "mclose",
      size: 2
    },
    "\\biggr": {
      mclass: "mclose",
      size: 3
    },
    "\\Biggr": {
      mclass: "mclose",
      size: 4
    },
    "\\bigm": {
      mclass: "mrel",
      size: 1
    },
    "\\Bigm": {
      mclass: "mrel",
      size: 2
    },
    "\\biggm": {
      mclass: "mrel",
      size: 3
    },
    "\\Biggm": {
      mclass: "mrel",
      size: 4
    },
    "\\big": {
      mclass: "mord",
      size: 1
    },
    "\\Big": {
      mclass: "mord",
      size: 2
    },
    "\\bigg": {
      mclass: "mord",
      size: 3
    },
    "\\Bigg": {
      mclass: "mord",
      size: 4
    }
  };
  var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
  function checkDelimiter(delim, context) {
    var symDelim = checkSymbolNodeType(delim);
    if (symDelim && utils.contains(delimiters, symDelim.text)) {
      return symDelim;
    } else if (symDelim) {
      throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
    } else {
      throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
    }
  }
  defineFunction({
    type: "delimsizing",
    names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
    props: {
      numArgs: 1,
      argTypes: ["primitive"]
    },
    handler: (context, args) => {
      var delim = checkDelimiter(args[0], context);
      return {
        type: "delimsizing",
        mode: context.parser.mode,
        size: delimiterSizes[context.funcName].size,
        mclass: delimiterSizes[context.funcName].mclass,
        delim: delim.text
      };
    },
    htmlBuilder: (group, options) => {
      if (group.delim === ".") {
        return buildCommon.makeSpan([group.mclass]);
      }
      return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
    },
    mathmlBuilder: (group) => {
      var children = [];
      if (group.delim !== ".") {
        children.push(makeText(group.delim, group.mode));
      }
      var node = new mathMLTree.MathNode("mo", children);
      if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.setAttribute("fence", "true");
      } else {
        node.setAttribute("fence", "false");
      }
      node.setAttribute("stretchy", "true");
      var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
      node.setAttribute("minsize", size);
      node.setAttribute("maxsize", size);
      return node;
    }
  });
  function assertParsed(group) {
    if (!group.body) {
      throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
    }
  }
  defineFunction({
    type: "leftright-right",
    names: ["\\right"],
    props: {
      numArgs: 1,
      primitive: true
    },
    handler: (context, args) => {
      var color = context.parser.gullet.macros.get("\\current@color");
      if (color && typeof color !== "string") {
        throw new ParseError("\\current@color set to non-string in \\right");
      }
      return {
        type: "leftright-right",
        mode: context.parser.mode,
        delim: checkDelimiter(args[0], context).text,
        color
        // undefined if not set via \color
      };
    }
  });
  defineFunction({
    type: "leftright",
    names: ["\\left"],
    props: {
      numArgs: 1,
      primitive: true
    },
    handler: (context, args) => {
      var delim = checkDelimiter(args[0], context);
      var parser = context.parser;
      ++parser.leftrightDepth;
      var body = parser.parseExpression(false);
      --parser.leftrightDepth;
      parser.expect("\\right", false);
      var right = assertNodeType(parser.parseFunction(), "leftright-right");
      return {
        type: "leftright",
        mode: parser.mode,
        body,
        left: delim.text,
        right: right.delim,
        rightColor: right.color
      };
    },
    htmlBuilder: (group, options) => {
      assertParsed(group);
      var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
      var innerHeight = 0;
      var innerDepth = 0;
      var hadMiddle = false;
      for (var i4 = 0; i4 < inner2.length; i4++) {
        if (inner2[i4].isMiddle) {
          hadMiddle = true;
        } else {
          innerHeight = Math.max(inner2[i4].height, innerHeight);
          innerDepth = Math.max(inner2[i4].depth, innerDepth);
        }
      }
      innerHeight *= options.sizeMultiplier;
      innerDepth *= options.sizeMultiplier;
      var leftDelim;
      if (group.left === ".") {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
      } else {
        leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
      }
      inner2.unshift(leftDelim);
      if (hadMiddle) {
        for (var _i = 1; _i < inner2.length; _i++) {
          var middleDelim = inner2[_i];
          var isMiddle = middleDelim.isMiddle;
          if (isMiddle) {
            inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
          }
        }
      }
      var rightDelim;
      if (group.right === ".") {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
      } else {
        var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
        rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
      }
      inner2.push(rightDelim);
      return buildCommon.makeSpan(["minner"], inner2, options);
    },
    mathmlBuilder: (group, options) => {
      assertParsed(group);
      var inner2 = buildExpression2(group.body, options);
      if (group.left !== ".") {
        var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
        leftNode.setAttribute("fence", "true");
        inner2.unshift(leftNode);
      }
      if (group.right !== ".") {
        var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
        rightNode.setAttribute("fence", "true");
        if (group.rightColor) {
          rightNode.setAttribute("mathcolor", group.rightColor);
        }
        inner2.push(rightNode);
      }
      return makeRow(inner2);
    }
  });
  defineFunction({
    type: "middle",
    names: ["\\middle"],
    props: {
      numArgs: 1,
      primitive: true
    },
    handler: (context, args) => {
      var delim = checkDelimiter(args[0], context);
      if (!context.parser.leftrightDepth) {
        throw new ParseError("\\middle without preceding \\left", delim);
      }
      return {
        type: "middle",
        mode: context.parser.mode,
        delim: delim.text
      };
    },
    htmlBuilder: (group, options) => {
      var middleDelim;
      if (group.delim === ".") {
        middleDelim = makeNullDelimiter(options, []);
      } else {
        middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
        var isMiddle = {
          delim: group.delim,
          options
        };
        middleDelim.isMiddle = isMiddle;
      }
      return middleDelim;
    },
    mathmlBuilder: (group, options) => {
      var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
      var middleNode = new mathMLTree.MathNode("mo", [textNode]);
      middleNode.setAttribute("fence", "true");
      middleNode.setAttribute("lspace", "0.05em");
      middleNode.setAttribute("rspace", "0.05em");
      return middleNode;
    }
  });
  var htmlBuilder$7 = (group, options) => {
    var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
    var label = group.label.slice(1);
    var scale = options.sizeMultiplier;
    var img;
    var imgShift = 0;
    var isSingleChar = utils.isCharacterBox(group.body);
    if (label === "sout") {
      img = buildCommon.makeSpan(["stretchy", "sout"]);
      img.height = options.fontMetrics().defaultRuleThickness / scale;
      imgShift = -0.5 * options.fontMetrics().xHeight;
    } else if (label === "phase") {
      var lineWeight = calculateSize({
        number: 0.6,
        unit: "pt"
      }, options);
      var clearance = calculateSize({
        number: 0.35,
        unit: "ex"
      }, options);
      var newOptions = options.havingBaseSizing();
      scale = scale / newOptions.sizeMultiplier;
      var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
      inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
      var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
      var path2 = phasePath(viewBoxHeight);
      var svgNode = new SvgNode([new PathNode("phase", path2)], {
        "width": "400em",
        "height": makeEm(viewBoxHeight / 1e3),
        "viewBox": "0 0 400000 " + viewBoxHeight,
        "preserveAspectRatio": "xMinYMin slice"
      });
      img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
      img.style.height = makeEm(angleHeight);
      imgShift = inner2.depth + lineWeight + clearance;
    } else {
      if (/cancel/.test(label)) {
        if (!isSingleChar) {
          inner2.classes.push("cancel-pad");
        }
      } else if (label === "angl") {
        inner2.classes.push("anglpad");
      } else {
        inner2.classes.push("boxpad");
      }
      var topPad = 0;
      var bottomPad = 0;
      var ruleThickness = 0;
      if (/box/.test(label)) {
        ruleThickness = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // User override.
        );
        topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
        bottomPad = topPad;
      } else if (label === "angl") {
        ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        topPad = 4 * ruleThickness;
        bottomPad = Math.max(0, 0.25 - inner2.depth);
      } else {
        topPad = isSingleChar ? 0.2 : 0;
        bottomPad = topPad;
      }
      img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
      if (/fbox|boxed|fcolorbox/.test(label)) {
        img.style.borderStyle = "solid";
        img.style.borderWidth = makeEm(ruleThickness);
      } else if (label === "angl" && ruleThickness !== 0.049) {
        img.style.borderTopWidth = makeEm(ruleThickness);
        img.style.borderRightWidth = makeEm(ruleThickness);
      }
      imgShift = inner2.depth + bottomPad;
      if (group.backgroundColor) {
        img.style.backgroundColor = group.backgroundColor;
        if (group.borderColor) {
          img.style.borderColor = group.borderColor;
        }
      }
    }
    var vlist;
    if (group.backgroundColor) {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [
          // Put the color background behind inner;
          {
            type: "elem",
            elem: img,
            shift: imgShift
          },
          {
            type: "elem",
            elem: inner2,
            shift: 0
          }
        ]
      }, options);
    } else {
      var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [
          // Write the \cancel stroke on top of inner.
          {
            type: "elem",
            elem: inner2,
            shift: 0
          },
          {
            type: "elem",
            elem: img,
            shift: imgShift,
            wrapperClasses: classes
          }
        ]
      }, options);
    }
    if (/cancel/.test(label)) {
      vlist.height = inner2.height;
      vlist.depth = inner2.depth;
    }
    if (/cancel/.test(label) && !isSingleChar) {
      return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
    } else {
      return buildCommon.makeSpan(["mord"], [vlist], options);
    }
  };
  var mathmlBuilder$6 = (group, options) => {
    var fboxsep = 0;
    var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
    switch (group.label) {
      case "\\cancel":
        node.setAttribute("notation", "updiagonalstrike");
        break;
      case "\\bcancel":
        node.setAttribute("notation", "downdiagonalstrike");
        break;
      case "\\phase":
        node.setAttribute("notation", "phasorangle");
        break;
      case "\\sout":
        node.setAttribute("notation", "horizontalstrike");
        break;
      case "\\fbox":
        node.setAttribute("notation", "box");
        break;
      case "\\angl":
        node.setAttribute("notation", "actuarial");
        break;
      case "\\fcolorbox":
      case "\\colorbox":
        fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
        node.setAttribute("width", "+" + 2 * fboxsep + "pt");
        node.setAttribute("height", "+" + 2 * fboxsep + "pt");
        node.setAttribute("lspace", fboxsep + "pt");
        node.setAttribute("voffset", fboxsep + "pt");
        if (group.label === "\\fcolorbox") {
          var thk = Math.max(
            options.fontMetrics().fboxrule,
            // default
            options.minRuleThickness
            // user override
          );
          node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
        }
        break;
      case "\\xcancel":
        node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
        break;
    }
    if (group.backgroundColor) {
      node.setAttribute("mathbackground", group.backgroundColor);
    }
    return node;
  };
  defineFunction({
    type: "enclose",
    names: ["\\colorbox"],
    props: {
      numArgs: 2,
      allowedInText: true,
      argTypes: ["color", "text"]
    },
    handler(_ref, args, optArgs) {
      var {
        parser,
        funcName
      } = _ref;
      var color = assertNodeType(args[0], "color-token").color;
      var body = args[1];
      return {
        type: "enclose",
        mode: parser.mode,
        label: funcName,
        backgroundColor: color,
        body
      };
    },
    htmlBuilder: htmlBuilder$7,
    mathmlBuilder: mathmlBuilder$6
  });
  defineFunction({
    type: "enclose",
    names: ["\\fcolorbox"],
    props: {
      numArgs: 3,
      allowedInText: true,
      argTypes: ["color", "color", "text"]
    },
    handler(_ref2, args, optArgs) {
      var {
        parser,
        funcName
      } = _ref2;
      var borderColor = assertNodeType(args[0], "color-token").color;
      var backgroundColor = assertNodeType(args[1], "color-token").color;
      var body = args[2];
      return {
        type: "enclose",
        mode: parser.mode,
        label: funcName,
        backgroundColor,
        borderColor,
        body
      };
    },
    htmlBuilder: htmlBuilder$7,
    mathmlBuilder: mathmlBuilder$6
  });
  defineFunction({
    type: "enclose",
    names: ["\\fbox"],
    props: {
      numArgs: 1,
      argTypes: ["hbox"],
      allowedInText: true
    },
    handler(_ref3, args) {
      var {
        parser
      } = _ref3;
      return {
        type: "enclose",
        mode: parser.mode,
        label: "\\fbox",
        body: args[0]
      };
    }
  });
  defineFunction({
    type: "enclose",
    names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
    props: {
      numArgs: 1
    },
    handler(_ref4, args) {
      var {
        parser,
        funcName
      } = _ref4;
      var body = args[0];
      return {
        type: "enclose",
        mode: parser.mode,
        label: funcName,
        body
      };
    },
    htmlBuilder: htmlBuilder$7,
    mathmlBuilder: mathmlBuilder$6
  });
  defineFunction({
    type: "enclose",
    names: ["\\angl"],
    props: {
      numArgs: 1,
      argTypes: ["hbox"],
      allowedInText: false
    },
    handler(_ref5, args) {
      var {
        parser
      } = _ref5;
      return {
        type: "enclose",
        mode: parser.mode,
        label: "\\angl",
        body: args[0]
      };
    }
  });
  var _environments = {};
  function defineEnvironment(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs || 0,
      allowedInText: false,
      numOptionalArgs: 0,
      handler
    };
    for (var i4 = 0; i4 < names.length; ++i4) {
      _environments[names[i4]] = data;
    }
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
  var _macros = {};
  function defineMacro(name, body) {
    _macros[name] = body;
  }
  function getHLines(parser) {
    var hlineInfo = [];
    parser.consumeSpaces();
    var nxt = parser.fetch().text;
    if (nxt === "\\relax") {
      parser.consume();
      parser.consumeSpaces();
      nxt = parser.fetch().text;
    }
    while (nxt === "\\hline" || nxt === "\\hdashline") {
      parser.consume();
      hlineInfo.push(nxt === "\\hdashline");
      parser.consumeSpaces();
      nxt = parser.fetch().text;
    }
    return hlineInfo;
  }
  var validateAmsEnvironmentContext = (context) => {
    var settings = context.parser.settings;
    if (!settings.displayMode) {
      throw new ParseError("{" + context.envName + "} can be used only in display mode.");
    }
  };
  function getAutoTag(name) {
    if (name.indexOf("ed") === -1) {
      return name.indexOf("*") === -1;
    }
  }
  function parseArray(parser, _ref, style) {
    var {
      hskipBeforeAndAfter,
      addJot,
      cols,
      arraystretch,
      colSeparationType,
      autoTag,
      singleRow,
      emptySingleRow,
      maxNumCols,
      leqno
    } = _ref;
    parser.gullet.beginGroup();
    if (!singleRow) {
      parser.gullet.macros.set("\\cr", "\\\\\\relax");
    }
    if (!arraystretch) {
      var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
      if (stretch == null) {
        arraystretch = 1;
      } else {
        arraystretch = parseFloat(stretch);
        if (!arraystretch || arraystretch < 0) {
          throw new ParseError("Invalid \\arraystretch: " + stretch);
        }
      }
    }
    parser.gullet.beginGroup();
    var row = [];
    var body = [row];
    var rowGaps = [];
    var hLinesBeforeRow = [];
    var tags = autoTag != null ? [] : void 0;
    function beginRow() {
      if (autoTag) {
        parser.gullet.macros.set("\\@eqnsw", "1", true);
      }
    }
    function endRow() {
      if (tags) {
        if (parser.gullet.macros.get("\\df@tag")) {
          tags.push(parser.subparse([new Token("\\df@tag")]));
          parser.gullet.macros.set("\\df@tag", void 0, true);
        } else {
          tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
        }
      }
    }
    beginRow();
    hLinesBeforeRow.push(getHLines(parser));
    while (true) {
      var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
      parser.gullet.endGroup();
      parser.gullet.beginGroup();
      cell = {
        type: "ordgroup",
        mode: parser.mode,
        body: cell
      };
      if (style) {
        cell = {
          type: "styling",
          mode: parser.mode,
          style,
          body: [cell]
        };
      }
      row.push(cell);
      var next = parser.fetch().text;
      if (next === "&") {
        if (maxNumCols && row.length === maxNumCols) {
          if (singleRow || colSeparationType) {
            throw new ParseError("Too many tab characters: &", parser.nextToken);
          } else {
            parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
          }
        }
        parser.consume();
      } else if (next === "\\end") {
        endRow();
        if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
          body.pop();
        }
        if (hLinesBeforeRow.length < body.length + 1) {
          hLinesBeforeRow.push([]);
        }
        break;
      } else if (next === "\\\\") {
        parser.consume();
        var size = void 0;
        if (parser.gullet.future().text !== " ") {
          size = parser.parseSizeGroup(true);
        }
        rowGaps.push(size ? size.value : null);
        endRow();
        hLinesBeforeRow.push(getHLines(parser));
        row = [];
        body.push(row);
        beginRow();
      } else {
        throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
      }
    }
    parser.gullet.endGroup();
    parser.gullet.endGroup();
    return {
      type: "array",
      mode: parser.mode,
      addJot,
      arraystretch,
      body,
      cols,
      rowGaps,
      hskipBeforeAndAfter,
      hLinesBeforeRow,
      colSeparationType,
      tags,
      leqno
    };
  }
  function dCellStyle(envName) {
    if (envName.slice(0, 1) === "d") {
      return "display";
    } else {
      return "text";
    }
  }
  var htmlBuilder$6 = function htmlBuilder(group, options) {
    var r3;
    var c3;
    var nr2 = group.body.length;
    var hLinesBeforeRow = group.hLinesBeforeRow;
    var nc = 0;
    var body = new Array(nr2);
    var hlines = [];
    var ruleThickness = Math.max(
      // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
      options.fontMetrics().arrayRuleWidth,
      options.minRuleThickness
      // User override.
    );
    var pt2 = 1 / options.fontMetrics().ptPerEm;
    var arraycolsep = 5 * pt2;
    if (group.colSeparationType && group.colSeparationType === "small") {
      var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
      arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
    }
    var baselineskip = group.colSeparationType === "CD" ? calculateSize({
      number: 3,
      unit: "ex"
    }, options) : 12 * pt2;
    var jot = 3 * pt2;
    var arrayskip = group.arraystretch * baselineskip;
    var arstrutHeight = 0.7 * arrayskip;
    var arstrutDepth = 0.3 * arrayskip;
    var totalHeight = 0;
    function setHLinePos(hlinesInGap) {
      for (var i4 = 0; i4 < hlinesInGap.length; ++i4) {
        if (i4 > 0) {
          totalHeight += 0.25;
        }
        hlines.push({
          pos: totalHeight,
          isDashed: hlinesInGap[i4]
        });
      }
    }
    setHLinePos(hLinesBeforeRow[0]);
    for (r3 = 0; r3 < group.body.length; ++r3) {
      var inrow = group.body[r3];
      var height = arstrutHeight;
      var depth = arstrutDepth;
      if (nc < inrow.length) {
        nc = inrow.length;
      }
      var outrow = new Array(inrow.length);
      for (c3 = 0; c3 < inrow.length; ++c3) {
        var elt = buildGroup$1(inrow[c3], options);
        if (depth < elt.depth) {
          depth = elt.depth;
        }
        if (height < elt.height) {
          height = elt.height;
        }
        outrow[c3] = elt;
      }
      var rowGap = group.rowGaps[r3];
      var gap = 0;
      if (rowGap) {
        gap = calculateSize(rowGap, options);
        if (gap > 0) {
          gap += arstrutDepth;
          if (depth < gap) {
            depth = gap;
          }
          gap = 0;
        }
      }
      if (group.addJot) {
        depth += jot;
      }
      outrow.height = height;
      outrow.depth = depth;
      totalHeight += height;
      outrow.pos = totalHeight;
      totalHeight += depth + gap;
      body[r3] = outrow;
      setHLinePos(hLinesBeforeRow[r3 + 1]);
    }
    var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
    var colDescriptions = group.cols || [];
    var cols = [];
    var colSep;
    var colDescrNum;
    var tagSpans = [];
    if (group.tags && group.tags.some((tag2) => tag2)) {
      for (r3 = 0; r3 < nr2; ++r3) {
        var rw = body[r3];
        var shift = rw.pos - offset;
        var tag = group.tags[r3];
        var tagSpan = void 0;
        if (tag === true) {
          tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
        } else if (tag === false) {
          tagSpan = buildCommon.makeSpan([], [], options);
        } else {
          tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
        }
        tagSpan.depth = rw.depth;
        tagSpan.height = rw.height;
        tagSpans.push({
          type: "elem",
          elem: tagSpan,
          shift
        });
      }
    }
    for (
      c3 = 0, colDescrNum = 0;
      // Continue while either there are more columns or more column
      // descriptions, so trailing separators don't get lost.
      c3 < nc || colDescrNum < colDescriptions.length;
      ++c3, ++colDescrNum
    ) {
      var colDescr = colDescriptions[colDescrNum] || {};
      var firstSeparator = true;
      while (colDescr.type === "separator") {
        if (!firstSeparator) {
          colSep = buildCommon.makeSpan(["arraycolsep"], []);
          colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
          cols.push(colSep);
        }
        if (colDescr.separator === "|" || colDescr.separator === ":") {
          var lineType = colDescr.separator === "|" ? "solid" : "dashed";
          var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
          separator.style.height = makeEm(totalHeight);
          separator.style.borderRightWidth = makeEm(ruleThickness);
          separator.style.borderRightStyle = lineType;
          separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
          var _shift = totalHeight - offset;
          if (_shift) {
            separator.style.verticalAlign = makeEm(-_shift);
          }
          cols.push(separator);
        } else {
          throw new ParseError("Invalid separator type: " + colDescr.separator);
        }
        colDescrNum++;
        colDescr = colDescriptions[colDescrNum] || {};
        firstSeparator = false;
      }
      if (c3 >= nc) {
        continue;
      }
      var sepwidth = void 0;
      if (c3 > 0 || group.hskipBeforeAndAfter) {
        sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
        if (sepwidth !== 0) {
          colSep = buildCommon.makeSpan(["arraycolsep"], []);
          colSep.style.width = makeEm(sepwidth);
          cols.push(colSep);
        }
      }
      var col = [];
      for (r3 = 0; r3 < nr2; ++r3) {
        var row = body[r3];
        var elem = row[c3];
        if (!elem) {
          continue;
        }
        var _shift2 = row.pos - offset;
        elem.depth = row.depth;
        elem.height = row.height;
        col.push({
          type: "elem",
          elem,
          shift: _shift2
        });
      }
      col = buildCommon.makeVList({
        positionType: "individualShift",
        children: col
      }, options);
      col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
      cols.push(col);
      if (c3 < nc - 1 || group.hskipBeforeAndAfter) {
        sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
        if (sepwidth !== 0) {
          colSep = buildCommon.makeSpan(["arraycolsep"], []);
          colSep.style.width = makeEm(sepwidth);
          cols.push(colSep);
        }
      }
    }
    body = buildCommon.makeSpan(["mtable"], cols);
    if (hlines.length > 0) {
      var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
      var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
      var vListElems = [{
        type: "elem",
        elem: body,
        shift: 0
      }];
      while (hlines.length > 0) {
        var hline = hlines.pop();
        var lineShift = hline.pos - offset;
        if (hline.isDashed) {
          vListElems.push({
            type: "elem",
            elem: dashes,
            shift: lineShift
          });
        } else {
          vListElems.push({
            type: "elem",
            elem: line,
            shift: lineShift
          });
        }
      }
      body = buildCommon.makeVList({
        positionType: "individualShift",
        children: vListElems
      }, options);
    }
    if (tagSpans.length === 0) {
      return buildCommon.makeSpan(["mord"], [body], options);
    } else {
      var eqnNumCol = buildCommon.makeVList({
        positionType: "individualShift",
        children: tagSpans
      }, options);
      eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
      return buildCommon.makeFragment([body, eqnNumCol]);
    }
  };
  var alignMap = {
    c: "center ",
    l: "left ",
    r: "right "
  };
  var mathmlBuilder$5 = function mathmlBuilder(group, options) {
    var tbl = [];
    var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
    var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
    for (var i4 = 0; i4 < group.body.length; i4++) {
      var rw = group.body[i4];
      var row = [];
      for (var j3 = 0; j3 < rw.length; j3++) {
        row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j3], options)]));
      }
      if (group.tags && group.tags[i4]) {
        row.unshift(glue);
        row.push(glue);
        if (group.leqno) {
          row.unshift(tag);
        } else {
          row.push(tag);
        }
      }
      tbl.push(new mathMLTree.MathNode("mtr", row));
    }
    var table = new mathMLTree.MathNode("mtable", tbl);
    var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
    table.setAttribute("rowspacing", makeEm(gap));
    var menclose = "";
    var align = "";
    if (group.cols && group.cols.length > 0) {
      var cols = group.cols;
      var columnLines = "";
      var prevTypeWasAlign = false;
      var iStart = 0;
      var iEnd = cols.length;
      if (cols[0].type === "separator") {
        menclose += "top ";
        iStart = 1;
      }
      if (cols[cols.length - 1].type === "separator") {
        menclose += "bottom ";
        iEnd -= 1;
      }
      for (var _i = iStart; _i < iEnd; _i++) {
        if (cols[_i].type === "align") {
          align += alignMap[cols[_i].align];
          if (prevTypeWasAlign) {
            columnLines += "none ";
          }
          prevTypeWasAlign = true;
        } else if (cols[_i].type === "separator") {
          if (prevTypeWasAlign) {
            columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
            prevTypeWasAlign = false;
          }
        }
      }
      table.setAttribute("columnalign", align.trim());
      if (/[sd]/.test(columnLines)) {
        table.setAttribute("columnlines", columnLines.trim());
      }
    }
    if (group.colSeparationType === "align") {
      var _cols = group.cols || [];
      var spacing2 = "";
      for (var _i2 = 1; _i2 < _cols.length; _i2++) {
        spacing2 += _i2 % 2 ? "0em " : "1em ";
      }
      table.setAttribute("columnspacing", spacing2.trim());
    } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
      table.setAttribute("columnspacing", "0em");
    } else if (group.colSeparationType === "small") {
      table.setAttribute("columnspacing", "0.2778em");
    } else if (group.colSeparationType === "CD") {
      table.setAttribute("columnspacing", "0.5em");
    } else {
      table.setAttribute("columnspacing", "1em");
    }
    var rowLines = "";
    var hlines = group.hLinesBeforeRow;
    menclose += hlines[0].length > 0 ? "left " : "";
    menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
    for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
      rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
    }
    if (/[sd]/.test(rowLines)) {
      table.setAttribute("rowlines", rowLines.trim());
    }
    if (menclose !== "") {
      table = new mathMLTree.MathNode("menclose", [table]);
      table.setAttribute("notation", menclose.trim());
    }
    if (group.arraystretch && group.arraystretch < 1) {
      table = new mathMLTree.MathNode("mstyle", [table]);
      table.setAttribute("scriptlevel", "1");
    }
    return table;
  };
  var alignedHandler = function alignedHandler2(context, args) {
    if (context.envName.indexOf("ed") === -1) {
      validateAmsEnvironmentContext(context);
    }
    var cols = [];
    var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
    var isSplit = context.envName === "split";
    var res = parseArray(context.parser, {
      cols,
      addJot: true,
      autoTag: isSplit ? void 0 : getAutoTag(context.envName),
      emptySingleRow: true,
      colSeparationType: separationType,
      maxNumCols: isSplit ? 2 : void 0,
      leqno: context.parser.settings.leqno
    }, "display");
    var numMaths;
    var numCols = 0;
    var emptyGroup = {
      type: "ordgroup",
      mode: context.mode,
      body: []
    };
    if (args[0] && args[0].type === "ordgroup") {
      var arg0 = "";
      for (var i4 = 0; i4 < args[0].body.length; i4++) {
        var textord2 = assertNodeType(args[0].body[i4], "textord");
        arg0 += textord2.text;
      }
      numMaths = Number(arg0);
      numCols = numMaths * 2;
    }
    var isAligned = !numCols;
    res.body.forEach(function(row) {
      for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
        var styling = assertNodeType(row[_i4], "styling");
        var ordgroup = assertNodeType(styling.body[0], "ordgroup");
        ordgroup.body.unshift(emptyGroup);
      }
      if (!isAligned) {
        var curMaths = row.length / 2;
        if (numMaths < curMaths) {
          throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
        }
      } else if (numCols < row.length) {
        numCols = row.length;
      }
    });
    for (var _i5 = 0; _i5 < numCols; ++_i5) {
      var align = "r";
      var pregap = 0;
      if (_i5 % 2 === 1) {
        align = "l";
      } else if (_i5 > 0 && isAligned) {
        pregap = 1;
      }
      cols[_i5] = {
        type: "align",
        align,
        pregap,
        postgap: 0
      };
    }
    res.colSeparationType = isAligned ? "align" : "alignat";
    return res;
  };
  defineEnvironment({
    type: "array",
    names: ["array", "darray"],
    props: {
      numArgs: 1
    },
    handler(context, args) {
      var symNode = checkSymbolNodeType(args[0]);
      var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
      var cols = colalign.map(function(nde) {
        var node = assertSymbolNodeType(nde);
        var ca = node.text;
        if ("lcr".indexOf(ca) !== -1) {
          return {
            type: "align",
            align: ca
          };
        } else if (ca === "|") {
          return {
            type: "separator",
            separator: "|"
          };
        } else if (ca === ":") {
          return {
            type: "separator",
            separator: ":"
          };
        }
        throw new ParseError("Unknown column alignment: " + ca, nde);
      });
      var res = {
        cols,
        hskipBeforeAndAfter: true,
        // \@preamble in lttab.dtx
        maxNumCols: cols.length
      };
      return parseArray(context.parser, res, dCellStyle(context.envName));
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
    props: {
      numArgs: 0
    },
    handler(context) {
      var delimiters2 = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
      }[context.envName.replace("*", "")];
      var colAlign = "c";
      var payload = {
        hskipBeforeAndAfter: false,
        cols: [{
          type: "align",
          align: colAlign
        }]
      };
      if (context.envName.charAt(context.envName.length - 1) === "*") {
        var parser = context.parser;
        parser.consumeSpaces();
        if (parser.fetch().text === "[") {
          parser.consume();
          parser.consumeSpaces();
          colAlign = parser.fetch().text;
          if ("lcr".indexOf(colAlign) === -1) {
            throw new ParseError("Expected l or c or r", parser.nextToken);
          }
          parser.consume();
          parser.consumeSpaces();
          parser.expect("]");
          parser.consume();
          payload.cols = [{
            type: "align",
            align: colAlign
          }];
        }
      }
      var res = parseArray(context.parser, payload, dCellStyle(context.envName));
      var numCols = Math.max(0, ...res.body.map((row) => row.length));
      res.cols = new Array(numCols).fill({
        type: "align",
        align: colAlign
      });
      return delimiters2 ? {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: delimiters2[0],
        right: delimiters2[1],
        rightColor: void 0
        // \right uninfluenced by \color in array
      } : res;
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["smallmatrix"],
    props: {
      numArgs: 0
    },
    handler(context) {
      var payload = {
        arraystretch: 0.5
      };
      var res = parseArray(context.parser, payload, "script");
      res.colSeparationType = "small";
      return res;
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["subarray"],
    props: {
      numArgs: 1
    },
    handler(context, args) {
      var symNode = checkSymbolNodeType(args[0]);
      var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
      var cols = colalign.map(function(nde) {
        var node = assertSymbolNodeType(nde);
        var ca = node.text;
        if ("lc".indexOf(ca) !== -1) {
          return {
            type: "align",
            align: ca
          };
        }
        throw new ParseError("Unknown column alignment: " + ca, nde);
      });
      if (cols.length > 1) {
        throw new ParseError("{subarray} can contain only one column");
      }
      var res = {
        cols,
        hskipBeforeAndAfter: false,
        arraystretch: 0.5
      };
      res = parseArray(context.parser, res, "script");
      if (res.body.length > 0 && res.body[0].length > 1) {
        throw new ParseError("{subarray} can contain only one column");
      }
      return res;
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["cases", "dcases", "rcases", "drcases"],
    props: {
      numArgs: 0
    },
    handler(context) {
      var payload = {
        arraystretch: 1.2,
        cols: [{
          type: "align",
          align: "l",
          pregap: 0,
          // TODO(kevinb) get the current style.
          // For now we use the metrics for TEXT style which is what we were
          // doing before.  Before attempting to get the current style we
          // should look at TeX's behavior especially for \over and matrices.
          postgap: 1
          /* 1em quad */
        }, {
          type: "align",
          align: "l",
          pregap: 0,
          postgap: 0
        }]
      };
      var res = parseArray(context.parser, payload, dCellStyle(context.envName));
      return {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: context.envName.indexOf("r") > -1 ? "." : "\\{",
        right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
        rightColor: void 0
      };
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["align", "align*", "aligned", "split"],
    props: {
      numArgs: 0
    },
    handler: alignedHandler,
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["gathered", "gather", "gather*"],
    props: {
      numArgs: 0
    },
    handler(context) {
      if (utils.contains(["gather", "gather*"], context.envName)) {
        validateAmsEnvironmentContext(context);
      }
      var res = {
        cols: [{
          type: "align",
          align: "c"
        }],
        addJot: true,
        colSeparationType: "gather",
        autoTag: getAutoTag(context.envName),
        emptySingleRow: true,
        leqno: context.parser.settings.leqno
      };
      return parseArray(context.parser, res, "display");
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["alignat", "alignat*", "alignedat"],
    props: {
      numArgs: 1
    },
    handler: alignedHandler,
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["equation", "equation*"],
    props: {
      numArgs: 0
    },
    handler(context) {
      validateAmsEnvironmentContext(context);
      var res = {
        autoTag: getAutoTag(context.envName),
        emptySingleRow: true,
        singleRow: true,
        maxNumCols: 1,
        leqno: context.parser.settings.leqno
      };
      return parseArray(context.parser, res, "display");
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineEnvironment({
    type: "array",
    names: ["CD"],
    props: {
      numArgs: 0
    },
    handler(context) {
      validateAmsEnvironmentContext(context);
      return parseCD(context.parser);
    },
    htmlBuilder: htmlBuilder$6,
    mathmlBuilder: mathmlBuilder$5
  });
  defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
  defineMacro("\\notag", "\\nonumber");
  defineFunction({
    type: "text",
    // Doesn't matter what this is.
    names: ["\\hline", "\\hdashline"],
    props: {
      numArgs: 0,
      allowedInText: true,
      allowedInMath: true
    },
    handler(context, args) {
      throw new ParseError(context.funcName + " valid only within array environment");
    }
  });
  var environments = _environments;
  defineFunction({
    type: "environment",
    names: ["\\begin", "\\end"],
    props: {
      numArgs: 1,
      argTypes: ["text"]
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      var nameGroup = args[0];
      if (nameGroup.type !== "ordgroup") {
        throw new ParseError("Invalid environment name", nameGroup);
      }
      var envName = "";
      for (var i4 = 0; i4 < nameGroup.body.length; ++i4) {
        envName += assertNodeType(nameGroup.body[i4], "textord").text;
      }
      if (funcName === "\\begin") {
        if (!environments.hasOwnProperty(envName)) {
          throw new ParseError("No such environment: " + envName, nameGroup);
        }
        var env = environments[envName];
        var {
          args: _args,
          optArgs
        } = parser.parseArguments("\\begin{" + envName + "}", env);
        var context = {
          mode: parser.mode,
          envName,
          parser
        };
        var result = env.handler(context, _args, optArgs);
        parser.expect("\\end", false);
        var endNameToken = parser.nextToken;
        var end = assertNodeType(parser.parseFunction(), "environment");
        if (end.name !== envName) {
          throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
        }
        return result;
      }
      return {
        type: "environment",
        mode: parser.mode,
        name: envName,
        nameGroup
      };
    }
  });
  var htmlBuilder$5 = (group, options) => {
    var font = group.font;
    var newOptions = options.withFont(font);
    return buildGroup$1(group.body, newOptions);
  };
  var mathmlBuilder$4 = (group, options) => {
    var font = group.font;
    var newOptions = options.withFont(font);
    return buildGroup2(group.body, newOptions);
  };
  var fontAliases = {
    "\\Bbb": "\\mathbb",
    "\\bold": "\\mathbf",
    "\\frak": "\\mathfrak",
    "\\bm": "\\boldsymbol"
  };
  defineFunction({
    type: "font",
    names: [
      // styles, except \boldsymbol defined below
      "\\mathrm",
      "\\mathit",
      "\\mathbf",
      "\\mathnormal",
      "\\mathsfit",
      // families
      "\\mathbb",
      "\\mathcal",
      "\\mathfrak",
      "\\mathscr",
      "\\mathsf",
      "\\mathtt",
      // aliases, except \bm defined below
      "\\Bbb",
      "\\bold",
      "\\frak"
    ],
    props: {
      numArgs: 1,
      allowedInArgument: true
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var body = normalizeArgument(args[0]);
      var func = funcName;
      if (func in fontAliases) {
        func = fontAliases[func];
      }
      return {
        type: "font",
        mode: parser.mode,
        font: func.slice(1),
        body
      };
    },
    htmlBuilder: htmlBuilder$5,
    mathmlBuilder: mathmlBuilder$4
  });
  defineFunction({
    type: "mclass",
    names: ["\\boldsymbol", "\\bm"],
    props: {
      numArgs: 1
    },
    handler: (_ref2, args) => {
      var {
        parser
      } = _ref2;
      var body = args[0];
      var isCharacterBox3 = utils.isCharacterBox(body);
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: binrelClass(body),
        body: [{
          type: "font",
          mode: parser.mode,
          font: "boldsymbol",
          body
        }],
        isCharacterBox: isCharacterBox3
      };
    }
  });
  defineFunction({
    type: "font",
    names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
    props: {
      numArgs: 0,
      allowedInText: true
    },
    handler: (_ref3, args) => {
      var {
        parser,
        funcName,
        breakOnTokenText
      } = _ref3;
      var {
        mode
      } = parser;
      var body = parser.parseExpression(true, breakOnTokenText);
      var style = "math" + funcName.slice(1);
      return {
        type: "font",
        mode,
        font: style,
        body: {
          type: "ordgroup",
          mode: parser.mode,
          body
        }
      };
    },
    htmlBuilder: htmlBuilder$5,
    mathmlBuilder: mathmlBuilder$4
  });
  var adjustStyle = (size, originalStyle) => {
    var style = originalStyle;
    if (size === "display") {
      style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
    } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
      style = Style$1.TEXT;
    } else if (size === "script") {
      style = Style$1.SCRIPT;
    } else if (size === "scriptscript") {
      style = Style$1.SCRIPTSCRIPT;
    }
    return style;
  };
  var htmlBuilder$4 = (group, options) => {
    var style = adjustStyle(group.size, options.style);
    var nstyle = style.fracNum();
    var dstyle = style.fracDen();
    var newOptions;
    newOptions = options.havingStyle(nstyle);
    var numerm = buildGroup$1(group.numer, newOptions, options);
    if (group.continued) {
      var hStrut = 8.5 / options.fontMetrics().ptPerEm;
      var dStrut = 3.5 / options.fontMetrics().ptPerEm;
      numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
      numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
    }
    newOptions = options.havingStyle(dstyle);
    var denomm = buildGroup$1(group.denom, newOptions, options);
    var rule;
    var ruleWidth;
    var ruleSpacing;
    if (group.hasBarLine) {
      if (group.barSize) {
        ruleWidth = calculateSize(group.barSize, options);
        rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
      } else {
        rule = buildCommon.makeLineSpan("frac-line", options);
      }
      ruleWidth = rule.height;
      ruleSpacing = rule.height;
    } else {
      rule = null;
      ruleWidth = 0;
      ruleSpacing = options.fontMetrics().defaultRuleThickness;
    }
    var numShift;
    var clearance;
    var denomShift;
    if (style.size === Style$1.DISPLAY.size || group.size === "display") {
      numShift = options.fontMetrics().num1;
      if (ruleWidth > 0) {
        clearance = 3 * ruleSpacing;
      } else {
        clearance = 7 * ruleSpacing;
      }
      denomShift = options.fontMetrics().denom1;
    } else {
      if (ruleWidth > 0) {
        numShift = options.fontMetrics().num2;
        clearance = ruleSpacing;
      } else {
        numShift = options.fontMetrics().num3;
        clearance = 3 * ruleSpacing;
      }
      denomShift = options.fontMetrics().denom2;
    }
    var frac;
    if (!rule) {
      var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
      if (candidateClearance < clearance) {
        numShift += 0.5 * (clearance - candidateClearance);
        denomShift += 0.5 * (clearance - candidateClearance);
      }
      frac = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: denomm,
          shift: denomShift
        }, {
          type: "elem",
          elem: numerm,
          shift: -numShift
        }]
      }, options);
    } else {
      var axisHeight = options.fontMetrics().axisHeight;
      if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
        numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
      }
      if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
        denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
      }
      var midShift = -(axisHeight - 0.5 * ruleWidth);
      frac = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: denomm,
          shift: denomShift
        }, {
          type: "elem",
          elem: rule,
          shift: midShift
        }, {
          type: "elem",
          elem: numerm,
          shift: -numShift
        }]
      }, options);
    }
    newOptions = options.havingStyle(style);
    frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
    frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
    var delimSize;
    if (style.size === Style$1.DISPLAY.size) {
      delimSize = options.fontMetrics().delim1;
    } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
      delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
    } else {
      delimSize = options.fontMetrics().delim2;
    }
    var leftDelim;
    var rightDelim;
    if (group.leftDelim == null) {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
    }
    if (group.continued) {
      rightDelim = buildCommon.makeSpan([]);
    } else if (group.rightDelim == null) {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
    }
    return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
  };
  var mathmlBuilder$3 = (group, options) => {
    var node = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
    if (!group.hasBarLine) {
      node.setAttribute("linethickness", "0px");
    } else if (group.barSize) {
      var ruleWidth = calculateSize(group.barSize, options);
      node.setAttribute("linethickness", makeEm(ruleWidth));
    }
    var style = adjustStyle(group.size, options.style);
    if (style.size !== options.style.size) {
      node = new mathMLTree.MathNode("mstyle", [node]);
      var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
      node.setAttribute("displaystyle", isDisplay);
      node.setAttribute("scriptlevel", "0");
    }
    if (group.leftDelim != null || group.rightDelim != null) {
      var withDelims = [];
      if (group.leftDelim != null) {
        var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
        leftOp.setAttribute("fence", "true");
        withDelims.push(leftOp);
      }
      withDelims.push(node);
      if (group.rightDelim != null) {
        var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
        rightOp.setAttribute("fence", "true");
        withDelims.push(rightOp);
      }
      return makeRow(withDelims);
    }
    return node;
  };
  defineFunction({
    type: "genfrac",
    names: [
      "\\dfrac",
      "\\frac",
      "\\tfrac",
      "\\dbinom",
      "\\binom",
      "\\tbinom",
      "\\\\atopfrac",
      // cant be entered directly
      "\\\\bracefrac",
      "\\\\brackfrac"
      // ditto
    ],
    props: {
      numArgs: 2,
      allowedInArgument: true
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var numer = args[0];
      var denom = args[1];
      var hasBarLine;
      var leftDelim = null;
      var rightDelim = null;
      var size = "auto";
      switch (funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
          hasBarLine = true;
          break;
        case "\\\\atopfrac":
          hasBarLine = false;
          break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
          hasBarLine = false;
          leftDelim = "(";
          rightDelim = ")";
          break;
        case "\\\\bracefrac":
          hasBarLine = false;
          leftDelim = "\\{";
          rightDelim = "\\}";
          break;
        case "\\\\brackfrac":
          hasBarLine = false;
          leftDelim = "[";
          rightDelim = "]";
          break;
        default:
          throw new Error("Unrecognized genfrac command");
      }
      switch (funcName) {
        case "\\dfrac":
        case "\\dbinom":
          size = "display";
          break;
        case "\\tfrac":
        case "\\tbinom":
          size = "text";
          break;
      }
      return {
        type: "genfrac",
        mode: parser.mode,
        continued: false,
        numer,
        denom,
        hasBarLine,
        leftDelim,
        rightDelim,
        size,
        barSize: null
      };
    },
    htmlBuilder: htmlBuilder$4,
    mathmlBuilder: mathmlBuilder$3
  });
  defineFunction({
    type: "genfrac",
    names: ["\\cfrac"],
    props: {
      numArgs: 2
    },
    handler: (_ref2, args) => {
      var {
        parser,
        funcName
      } = _ref2;
      var numer = args[0];
      var denom = args[1];
      return {
        type: "genfrac",
        mode: parser.mode,
        continued: true,
        numer,
        denom,
        hasBarLine: true,
        leftDelim: null,
        rightDelim: null,
        size: "display",
        barSize: null
      };
    }
  });
  defineFunction({
    type: "infix",
    names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
    props: {
      numArgs: 0,
      infix: true
    },
    handler(_ref3) {
      var {
        parser,
        funcName,
        token
      } = _ref3;
      var replaceWith;
      switch (funcName) {
        case "\\over":
          replaceWith = "\\frac";
          break;
        case "\\choose":
          replaceWith = "\\binom";
          break;
        case "\\atop":
          replaceWith = "\\\\atopfrac";
          break;
        case "\\brace":
          replaceWith = "\\\\bracefrac";
          break;
        case "\\brack":
          replaceWith = "\\\\brackfrac";
          break;
        default:
          throw new Error("Unrecognized infix genfrac command");
      }
      return {
        type: "infix",
        mode: parser.mode,
        replaceWith,
        token
      };
    }
  });
  var stylArray = ["display", "text", "script", "scriptscript"];
  var delimFromValue = function delimFromValue2(delimString) {
    var delim = null;
    if (delimString.length > 0) {
      delim = delimString;
      delim = delim === "." ? null : delim;
    }
    return delim;
  };
  defineFunction({
    type: "genfrac",
    names: ["\\genfrac"],
    props: {
      numArgs: 6,
      allowedInArgument: true,
      argTypes: ["math", "math", "size", "text", "math", "math"]
    },
    handler(_ref4, args) {
      var {
        parser
      } = _ref4;
      var numer = args[4];
      var denom = args[5];
      var leftNode = normalizeArgument(args[0]);
      var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
      var rightNode = normalizeArgument(args[1]);
      var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
      var barNode = assertNodeType(args[2], "size");
      var hasBarLine;
      var barSize = null;
      if (barNode.isBlank) {
        hasBarLine = true;
      } else {
        barSize = barNode.value;
        hasBarLine = barSize.number > 0;
      }
      var size = "auto";
      var styl = args[3];
      if (styl.type === "ordgroup") {
        if (styl.body.length > 0) {
          var textOrd = assertNodeType(styl.body[0], "textord");
          size = stylArray[Number(textOrd.text)];
        }
      } else {
        styl = assertNodeType(styl, "textord");
        size = stylArray[Number(styl.text)];
      }
      return {
        type: "genfrac",
        mode: parser.mode,
        numer,
        denom,
        continued: false,
        hasBarLine,
        barSize,
        leftDelim,
        rightDelim,
        size
      };
    },
    htmlBuilder: htmlBuilder$4,
    mathmlBuilder: mathmlBuilder$3
  });
  defineFunction({
    type: "infix",
    names: ["\\above"],
    props: {
      numArgs: 1,
      argTypes: ["size"],
      infix: true
    },
    handler(_ref5, args) {
      var {
        parser,
        funcName,
        token
      } = _ref5;
      return {
        type: "infix",
        mode: parser.mode,
        replaceWith: "\\\\abovefrac",
        size: assertNodeType(args[0], "size").value,
        token
      };
    }
  });
  defineFunction({
    type: "genfrac",
    names: ["\\\\abovefrac"],
    props: {
      numArgs: 3,
      argTypes: ["math", "size", "math"]
    },
    handler: (_ref6, args) => {
      var {
        parser,
        funcName
      } = _ref6;
      var numer = args[0];
      var barSize = assert(assertNodeType(args[1], "infix").size);
      var denom = args[2];
      var hasBarLine = barSize.number > 0;
      return {
        type: "genfrac",
        mode: parser.mode,
        numer,
        denom,
        continued: false,
        hasBarLine,
        barSize,
        leftDelim: null,
        rightDelim: null,
        size: "auto"
      };
    },
    htmlBuilder: htmlBuilder$4,
    mathmlBuilder: mathmlBuilder$3
  });
  var htmlBuilder$3 = (grp, options) => {
    var style = options.style;
    var supSubGroup;
    var group;
    if (grp.type === "supsub") {
      supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
      group = assertNodeType(grp.base, "horizBrace");
    } else {
      group = assertNodeType(grp, "horizBrace");
    }
    var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
    var braceBody = stretchy.svgSpan(group, options);
    var vlist;
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: body
        }, {
          type: "kern",
          size: 0.1
        }, {
          type: "elem",
          elem: braceBody
        }]
      }, options);
      vlist.children[0].children[0].children[1].classes.push("svg-align");
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: body.depth + 0.1 + braceBody.height,
        children: [{
          type: "elem",
          elem: braceBody
        }, {
          type: "kern",
          size: 0.1
        }, {
          type: "elem",
          elem: body
        }]
      }, options);
      vlist.children[0].children[0].children[0].classes.push("svg-align");
    }
    if (supSubGroup) {
      var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
      if (group.isOver) {
        vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: vSpan
          }, {
            type: "kern",
            size: 0.2
          }, {
            type: "elem",
            elem: supSubGroup
          }]
        }, options);
      } else {
        vlist = buildCommon.makeVList({
          positionType: "bottom",
          positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
          children: [{
            type: "elem",
            elem: supSubGroup
          }, {
            type: "kern",
            size: 0.2
          }, {
            type: "elem",
            elem: vSpan
          }]
        }, options);
      }
    }
    return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
  };
  var mathmlBuilder$2 = (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
  };
  defineFunction({
    type: "horizBrace",
    names: ["\\overbrace", "\\underbrace"],
    props: {
      numArgs: 1
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      return {
        type: "horizBrace",
        mode: parser.mode,
        label: funcName,
        isOver: /^\\over/.test(funcName),
        base: args[0]
      };
    },
    htmlBuilder: htmlBuilder$3,
    mathmlBuilder: mathmlBuilder$2
  });
  defineFunction({
    type: "href",
    names: ["\\href"],
    props: {
      numArgs: 2,
      argTypes: ["url", "original"],
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        parser
      } = _ref;
      var body = args[1];
      var href = assertNodeType(args[0], "url").url;
      if (!parser.settings.isTrusted({
        command: "\\href",
        url: href
      })) {
        return parser.formatUnsupportedCmd("\\href");
      }
      return {
        type: "href",
        mode: parser.mode,
        href,
        body: ordargument(body)
      };
    },
    htmlBuilder: (group, options) => {
      var elements = buildExpression$1(group.body, options, false);
      return buildCommon.makeAnchor(group.href, [], elements, options);
    },
    mathmlBuilder: (group, options) => {
      var math2 = buildExpressionRow(group.body, options);
      if (!(math2 instanceof MathNode)) {
        math2 = new MathNode("mrow", [math2]);
      }
      math2.setAttribute("href", group.href);
      return math2;
    }
  });
  defineFunction({
    type: "href",
    names: ["\\url"],
    props: {
      numArgs: 1,
      argTypes: ["url"],
      allowedInText: true
    },
    handler: (_ref2, args) => {
      var {
        parser
      } = _ref2;
      var href = assertNodeType(args[0], "url").url;
      if (!parser.settings.isTrusted({
        command: "\\url",
        url: href
      })) {
        return parser.formatUnsupportedCmd("\\url");
      }
      var chars = [];
      for (var i4 = 0; i4 < href.length; i4++) {
        var c3 = href[i4];
        if (c3 === "~") {
          c3 = "\\textasciitilde";
        }
        chars.push({
          type: "textord",
          mode: "text",
          text: c3
        });
      }
      var body = {
        type: "text",
        mode: parser.mode,
        font: "\\texttt",
        body: chars
      };
      return {
        type: "href",
        mode: parser.mode,
        href,
        body: ordargument(body)
      };
    }
  });
  defineFunction({
    type: "hbox",
    names: ["\\hbox"],
    props: {
      numArgs: 1,
      argTypes: ["text"],
      allowedInText: true,
      primitive: true
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      return {
        type: "hbox",
        mode: parser.mode,
        body: ordargument(args[0])
      };
    },
    htmlBuilder(group, options) {
      var elements = buildExpression$1(group.body, options, false);
      return buildCommon.makeFragment(elements);
    },
    mathmlBuilder(group, options) {
      return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
    }
  });
  defineFunction({
    type: "html",
    names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
    props: {
      numArgs: 2,
      argTypes: ["raw", "original"],
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName,
        token
      } = _ref;
      var value = assertNodeType(args[0], "raw").string;
      var body = args[1];
      if (parser.settings.strict) {
        parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
      }
      var trustContext;
      var attributes = {};
      switch (funcName) {
        case "\\htmlClass":
          attributes.class = value;
          trustContext = {
            command: "\\htmlClass",
            class: value
          };
          break;
        case "\\htmlId":
          attributes.id = value;
          trustContext = {
            command: "\\htmlId",
            id: value
          };
          break;
        case "\\htmlStyle":
          attributes.style = value;
          trustContext = {
            command: "\\htmlStyle",
            style: value
          };
          break;
        case "\\htmlData": {
          var data = value.split(",");
          for (var i4 = 0; i4 < data.length; i4++) {
            var keyVal = data[i4].split("=");
            if (keyVal.length !== 2) {
              throw new ParseError("Error parsing key-value for \\htmlData");
            }
            attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
          }
          trustContext = {
            command: "\\htmlData",
            attributes
          };
          break;
        }
        default:
          throw new Error("Unrecognized html command");
      }
      if (!parser.settings.isTrusted(trustContext)) {
        return parser.formatUnsupportedCmd(funcName);
      }
      return {
        type: "html",
        mode: parser.mode,
        attributes,
        body: ordargument(body)
      };
    },
    htmlBuilder: (group, options) => {
      var elements = buildExpression$1(group.body, options, false);
      var classes = ["enclosing"];
      if (group.attributes.class) {
        classes.push(...group.attributes.class.trim().split(/\s+/));
      }
      var span = buildCommon.makeSpan(classes, elements, options);
      for (var attr in group.attributes) {
        if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
          span.setAttribute(attr, group.attributes[attr]);
        }
      }
      return span;
    },
    mathmlBuilder: (group, options) => {
      return buildExpressionRow(group.body, options);
    }
  });
  defineFunction({
    type: "htmlmathml",
    names: ["\\html@mathml"],
    props: {
      numArgs: 2,
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        parser
      } = _ref;
      return {
        type: "htmlmathml",
        mode: parser.mode,
        html: ordargument(args[0]),
        mathml: ordargument(args[1])
      };
    },
    htmlBuilder: (group, options) => {
      var elements = buildExpression$1(group.html, options, false);
      return buildCommon.makeFragment(elements);
    },
    mathmlBuilder: (group, options) => {
      return buildExpressionRow(group.mathml, options);
    }
  });
  var sizeData = function sizeData2(str) {
    if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
      return {
        number: +str,
        unit: "bp"
      };
    } else {
      var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
      if (!match) {
        throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
      }
      var data = {
        number: +(match[1] + match[2]),
        // sign + magnitude, cast to number
        unit: match[3]
      };
      if (!validUnit(data)) {
        throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
      }
      return data;
    }
  };
  defineFunction({
    type: "includegraphics",
    names: ["\\includegraphics"],
    props: {
      numArgs: 1,
      numOptionalArgs: 1,
      argTypes: ["raw", "url"],
      allowedInText: false
    },
    handler: (_ref, args, optArgs) => {
      var {
        parser
      } = _ref;
      var width = {
        number: 0,
        unit: "em"
      };
      var height = {
        number: 0.9,
        unit: "em"
      };
      var totalheight = {
        number: 0,
        unit: "em"
      };
      var alt = "";
      if (optArgs[0]) {
        var attributeStr = assertNodeType(optArgs[0], "raw").string;
        var attributes = attributeStr.split(",");
        for (var i4 = 0; i4 < attributes.length; i4++) {
          var keyVal = attributes[i4].split("=");
          if (keyVal.length === 2) {
            var str = keyVal[1].trim();
            switch (keyVal[0].trim()) {
              case "alt":
                alt = str;
                break;
              case "width":
                width = sizeData(str);
                break;
              case "height":
                height = sizeData(str);
                break;
              case "totalheight":
                totalheight = sizeData(str);
                break;
              default:
                throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
            }
          }
        }
      }
      var src = assertNodeType(args[0], "url").url;
      if (alt === "") {
        alt = src;
        alt = alt.replace(/^.*[\\/]/, "");
        alt = alt.substring(0, alt.lastIndexOf("."));
      }
      if (!parser.settings.isTrusted({
        command: "\\includegraphics",
        url: src
      })) {
        return parser.formatUnsupportedCmd("\\includegraphics");
      }
      return {
        type: "includegraphics",
        mode: parser.mode,
        alt,
        width,
        height,
        totalheight,
        src
      };
    },
    htmlBuilder: (group, options) => {
      var height = calculateSize(group.height, options);
      var depth = 0;
      if (group.totalheight.number > 0) {
        depth = calculateSize(group.totalheight, options) - height;
      }
      var width = 0;
      if (group.width.number > 0) {
        width = calculateSize(group.width, options);
      }
      var style = {
        height: makeEm(height + depth)
      };
      if (width > 0) {
        style.width = makeEm(width);
      }
      if (depth > 0) {
        style.verticalAlign = makeEm(-depth);
      }
      var node = new Img(group.src, group.alt, style);
      node.height = height;
      node.depth = depth;
      return node;
    },
    mathmlBuilder: (group, options) => {
      var node = new mathMLTree.MathNode("mglyph", []);
      node.setAttribute("alt", group.alt);
      var height = calculateSize(group.height, options);
      var depth = 0;
      if (group.totalheight.number > 0) {
        depth = calculateSize(group.totalheight, options) - height;
        node.setAttribute("valign", makeEm(-depth));
      }
      node.setAttribute("height", makeEm(height + depth));
      if (group.width.number > 0) {
        var width = calculateSize(group.width, options);
        node.setAttribute("width", makeEm(width));
      }
      node.setAttribute("src", group.src);
      return node;
    }
  });
  defineFunction({
    type: "kern",
    names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
    props: {
      numArgs: 1,
      argTypes: ["size"],
      primitive: true,
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      var size = assertNodeType(args[0], "size");
      if (parser.settings.strict) {
        var mathFunction = funcName[1] === "m";
        var muUnit = size.value.unit === "mu";
        if (mathFunction) {
          if (!muUnit) {
            parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
          }
          if (parser.mode !== "math") {
            parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
          }
        } else {
          if (muUnit) {
            parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
          }
        }
      }
      return {
        type: "kern",
        mode: parser.mode,
        dimension: size.value
      };
    },
    htmlBuilder(group, options) {
      return buildCommon.makeGlue(group.dimension, options);
    },
    mathmlBuilder(group, options) {
      var dimension = calculateSize(group.dimension, options);
      return new mathMLTree.SpaceNode(dimension);
    }
  });
  defineFunction({
    type: "lap",
    names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var body = args[0];
      return {
        type: "lap",
        mode: parser.mode,
        alignment: funcName.slice(5),
        body
      };
    },
    htmlBuilder: (group, options) => {
      var inner2;
      if (group.alignment === "clap") {
        inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
        inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
      } else {
        inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
      }
      var fix = buildCommon.makeSpan(["fix"], []);
      var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
      var strut = buildCommon.makeSpan(["strut"]);
      strut.style.height = makeEm(node.height + node.depth);
      if (node.depth) {
        strut.style.verticalAlign = makeEm(-node.depth);
      }
      node.children.unshift(strut);
      node = buildCommon.makeSpan(["thinbox"], [node], options);
      return buildCommon.makeSpan(["mord", "vbox"], [node], options);
    },
    mathmlBuilder: (group, options) => {
      var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
      if (group.alignment !== "rlap") {
        var offset = group.alignment === "llap" ? "-1" : "-0.5";
        node.setAttribute("lspace", offset + "width");
      }
      node.setAttribute("width", "0px");
      return node;
    }
  });
  defineFunction({
    type: "styling",
    names: ["\\(", "$"],
    props: {
      numArgs: 0,
      allowedInText: true,
      allowedInMath: false
    },
    handler(_ref, args) {
      var {
        funcName,
        parser
      } = _ref;
      var outerMode = parser.mode;
      parser.switchMode("math");
      var close2 = funcName === "\\(" ? "\\)" : "$";
      var body = parser.parseExpression(false, close2);
      parser.expect(close2);
      parser.switchMode(outerMode);
      return {
        type: "styling",
        mode: parser.mode,
        style: "text",
        body
      };
    }
  });
  defineFunction({
    type: "text",
    // Doesn't matter what this is.
    names: ["\\)", "\\]"],
    props: {
      numArgs: 0,
      allowedInText: true,
      allowedInMath: false
    },
    handler(context, args) {
      throw new ParseError("Mismatched " + context.funcName);
    }
  });
  var chooseMathStyle = (group, options) => {
    switch (options.style.size) {
      case Style$1.DISPLAY.size:
        return group.display;
      case Style$1.TEXT.size:
        return group.text;
      case Style$1.SCRIPT.size:
        return group.script;
      case Style$1.SCRIPTSCRIPT.size:
        return group.scriptscript;
      default:
        return group.text;
    }
  };
  defineFunction({
    type: "mathchoice",
    names: ["\\mathchoice"],
    props: {
      numArgs: 4,
      primitive: true
    },
    handler: (_ref, args) => {
      var {
        parser
      } = _ref;
      return {
        type: "mathchoice",
        mode: parser.mode,
        display: ordargument(args[0]),
        text: ordargument(args[1]),
        script: ordargument(args[2]),
        scriptscript: ordargument(args[3])
      };
    },
    htmlBuilder: (group, options) => {
      var body = chooseMathStyle(group, options);
      var elements = buildExpression$1(body, options, false);
      return buildCommon.makeFragment(elements);
    },
    mathmlBuilder: (group, options) => {
      var body = chooseMathStyle(group, options);
      return buildExpressionRow(body, options);
    }
  });
  var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
    base = buildCommon.makeSpan([], [base]);
    var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
    var sub2;
    var sup2;
    if (supGroup) {
      var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
      sup2 = {
        elem,
        kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
      };
    }
    if (subGroup) {
      var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);
      sub2 = {
        elem: _elem,
        kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
      };
    }
    var finalGroup;
    if (sup2 && sub2) {
      var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
      finalGroup = buildCommon.makeVList({
        positionType: "bottom",
        positionData: bottom,
        children: [{
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }, {
          type: "elem",
          elem: sub2.elem,
          marginLeft: makeEm(-slant)
        }, {
          type: "kern",
          size: sub2.kern
        }, {
          type: "elem",
          elem: base
        }, {
          type: "kern",
          size: sup2.kern
        }, {
          type: "elem",
          elem: sup2.elem,
          marginLeft: makeEm(slant)
        }, {
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }]
      }, options);
    } else if (sub2) {
      var top = base.height - baseShift;
      finalGroup = buildCommon.makeVList({
        positionType: "top",
        positionData: top,
        children: [{
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }, {
          type: "elem",
          elem: sub2.elem,
          marginLeft: makeEm(-slant)
        }, {
          type: "kern",
          size: sub2.kern
        }, {
          type: "elem",
          elem: base
        }]
      }, options);
    } else if (sup2) {
      var _bottom = base.depth + baseShift;
      finalGroup = buildCommon.makeVList({
        positionType: "bottom",
        positionData: _bottom,
        children: [{
          type: "elem",
          elem: base
        }, {
          type: "kern",
          size: sup2.kern
        }, {
          type: "elem",
          elem: sup2.elem,
          marginLeft: makeEm(slant)
        }, {
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }]
      }, options);
    } else {
      return base;
    }
    var parts = [finalGroup];
    if (sub2 && slant !== 0 && !subIsSingleCharacter) {
      var spacer = buildCommon.makeSpan(["mspace"], [], options);
      spacer.style.marginRight = makeEm(slant);
      parts.unshift(spacer);
    }
    return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
  };
  var noSuccessor = ["\\smallint"];
  var htmlBuilder$2 = (grp, options) => {
    var supGroup;
    var subGroup;
    var hasLimits = false;
    var group;
    if (grp.type === "supsub") {
      supGroup = grp.sup;
      subGroup = grp.sub;
      group = assertNodeType(grp.base, "op");
      hasLimits = true;
    } else {
      group = assertNodeType(grp, "op");
    }
    var style = options.style;
    var large = false;
    if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
      large = true;
    }
    var base;
    if (group.symbol) {
      var fontName = large ? "Size2-Regular" : "Size1-Regular";
      var stash = "";
      if (group.name === "\\oiint" || group.name === "\\oiiint") {
        stash = group.name.slice(1);
        group.name = stash === "oiint" ? "\\iint" : "\\iiint";
      }
      base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
      if (stash.length > 0) {
        var italic = base.italic;
        var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
        base = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: base,
            shift: 0
          }, {
            type: "elem",
            elem: oval,
            shift: large ? 0.08 : 0
          }]
        }, options);
        group.name = "\\" + stash;
        base.classes.unshift("mop");
        base.italic = italic;
      }
    } else if (group.body) {
      var inner2 = buildExpression$1(group.body, options, true);
      if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
        base = inner2[0];
        base.classes[0] = "mop";
      } else {
        base = buildCommon.makeSpan(["mop"], inner2, options);
      }
    } else {
      var output = [];
      for (var i4 = 1; i4 < group.name.length; i4++) {
        output.push(buildCommon.mathsym(group.name[i4], group.mode, options));
      }
      base = buildCommon.makeSpan(["mop"], output, options);
    }
    var baseShift = 0;
    var slant = 0;
    if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
      baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
      slant = base.italic;
    }
    if (hasLimits) {
      return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
    } else {
      if (baseShift) {
        base.style.position = "relative";
        base.style.top = makeEm(baseShift);
      }
      return base;
    }
  };
  var mathmlBuilder$1 = (group, options) => {
    var node;
    if (group.symbol) {
      node = new MathNode("mo", [makeText(group.name, group.mode)]);
      if (utils.contains(noSuccessor, group.name)) {
        node.setAttribute("largeop", "false");
      }
    } else if (group.body) {
      node = new MathNode("mo", buildExpression2(group.body, options));
    } else {
      node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
      var operator = new MathNode("mo", [makeText("\u2061", "text")]);
      if (group.parentIsSupSub) {
        node = new MathNode("mrow", [node, operator]);
      } else {
        node = newDocumentFragment([node, operator]);
      }
    }
    return node;
  };
  var singleCharBigOps = {
    "\u220F": "\\prod",
    "\u2210": "\\coprod",
    "\u2211": "\\sum",
    "\u22C0": "\\bigwedge",
    "\u22C1": "\\bigvee",
    "\u22C2": "\\bigcap",
    "\u22C3": "\\bigcup",
    "\u2A00": "\\bigodot",
    "\u2A01": "\\bigoplus",
    "\u2A02": "\\bigotimes",
    "\u2A04": "\\biguplus",
    "\u2A06": "\\bigsqcup"
  };
  defineFunction({
    type: "op",
    names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
    props: {
      numArgs: 0
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var fName = funcName;
      if (fName.length === 1) {
        fName = singleCharBigOps[fName];
      }
      return {
        type: "op",
        mode: parser.mode,
        limits: true,
        parentIsSupSub: false,
        symbol: true,
        name: fName
      };
    },
    htmlBuilder: htmlBuilder$2,
    mathmlBuilder: mathmlBuilder$1
  });
  defineFunction({
    type: "op",
    names: ["\\mathop"],
    props: {
      numArgs: 1,
      primitive: true
    },
    handler: (_ref2, args) => {
      var {
        parser
      } = _ref2;
      var body = args[0];
      return {
        type: "op",
        mode: parser.mode,
        limits: false,
        parentIsSupSub: false,
        symbol: false,
        body: ordargument(body)
      };
    },
    htmlBuilder: htmlBuilder$2,
    mathmlBuilder: mathmlBuilder$1
  });
  var singleCharIntegrals = {
    "\u222B": "\\int",
    "\u222C": "\\iint",
    "\u222D": "\\iiint",
    "\u222E": "\\oint",
    "\u222F": "\\oiint",
    "\u2230": "\\oiiint"
  };
  defineFunction({
    type: "op",
    names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
    props: {
      numArgs: 0
    },
    handler(_ref3) {
      var {
        parser,
        funcName
      } = _ref3;
      return {
        type: "op",
        mode: parser.mode,
        limits: false,
        parentIsSupSub: false,
        symbol: false,
        name: funcName
      };
    },
    htmlBuilder: htmlBuilder$2,
    mathmlBuilder: mathmlBuilder$1
  });
  defineFunction({
    type: "op",
    names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
    props: {
      numArgs: 0
    },
    handler(_ref4) {
      var {
        parser,
        funcName
      } = _ref4;
      return {
        type: "op",
        mode: parser.mode,
        limits: true,
        parentIsSupSub: false,
        symbol: false,
        name: funcName
      };
    },
    htmlBuilder: htmlBuilder$2,
    mathmlBuilder: mathmlBuilder$1
  });
  defineFunction({
    type: "op",
    names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
    props: {
      numArgs: 0
    },
    handler(_ref5) {
      var {
        parser,
        funcName
      } = _ref5;
      var fName = funcName;
      if (fName.length === 1) {
        fName = singleCharIntegrals[fName];
      }
      return {
        type: "op",
        mode: parser.mode,
        limits: false,
        parentIsSupSub: false,
        symbol: true,
        name: fName
      };
    },
    htmlBuilder: htmlBuilder$2,
    mathmlBuilder: mathmlBuilder$1
  });
  var htmlBuilder$1 = (grp, options) => {
    var supGroup;
    var subGroup;
    var hasLimits = false;
    var group;
    if (grp.type === "supsub") {
      supGroup = grp.sup;
      subGroup = grp.sub;
      group = assertNodeType(grp.base, "operatorname");
      hasLimits = true;
    } else {
      group = assertNodeType(grp, "operatorname");
    }
    var base;
    if (group.body.length > 0) {
      var body = group.body.map((child2) => {
        var childText = child2.text;
        if (typeof childText === "string") {
          return {
            type: "textord",
            mode: child2.mode,
            text: childText
          };
        } else {
          return child2;
        }
      });
      var expression = buildExpression$1(body, options.withFont("mathrm"), true);
      for (var i4 = 0; i4 < expression.length; i4++) {
        var child = expression[i4];
        if (child instanceof SymbolNode) {
          child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
        }
      }
      base = buildCommon.makeSpan(["mop"], expression, options);
    } else {
      base = buildCommon.makeSpan(["mop"], [], options);
    }
    if (hasLimits) {
      return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
    } else {
      return base;
    }
  };
  var mathmlBuilder2 = (group, options) => {
    var expression = buildExpression2(group.body, options.withFont("mathrm"));
    var isAllString = true;
    for (var i4 = 0; i4 < expression.length; i4++) {
      var node = expression[i4];
      if (node instanceof mathMLTree.SpaceNode)
        ;
      else if (node instanceof mathMLTree.MathNode) {
        switch (node.type) {
          case "mi":
          case "mn":
          case "ms":
          case "mspace":
          case "mtext":
            break;
          case "mo": {
            var child = node.children[0];
            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            } else {
              isAllString = false;
            }
            break;
          }
          default:
            isAllString = false;
        }
      } else {
        isAllString = false;
      }
    }
    if (isAllString) {
      var word = expression.map((node2) => node2.toText()).join("");
      expression = [new mathMLTree.TextNode(word)];
    }
    var identifier = new mathMLTree.MathNode("mi", expression);
    identifier.setAttribute("mathvariant", "normal");
    var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
    if (group.parentIsSupSub) {
      return new mathMLTree.MathNode("mrow", [identifier, operator]);
    } else {
      return mathMLTree.newDocumentFragment([identifier, operator]);
    }
  };
  defineFunction({
    type: "operatorname",
    names: ["\\operatorname@", "\\operatornamewithlimits"],
    props: {
      numArgs: 1
    },
    handler: (_ref, args) => {
      var {
        parser,
        funcName
      } = _ref;
      var body = args[0];
      return {
        type: "operatorname",
        mode: parser.mode,
        body: ordargument(body),
        alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
        limits: false,
        parentIsSupSub: false
      };
    },
    htmlBuilder: htmlBuilder$1,
    mathmlBuilder: mathmlBuilder2
  });
  defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
  defineFunctionBuilders({
    type: "ordgroup",
    htmlBuilder(group, options) {
      if (group.semisimple) {
        return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
      }
      return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
    },
    mathmlBuilder(group, options) {
      return buildExpressionRow(group.body, options, true);
    }
  });
  defineFunction({
    type: "overline",
    names: ["\\overline"],
    props: {
      numArgs: 1
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      var body = args[0];
      return {
        type: "overline",
        mode: parser.mode,
        body
      };
    },
    htmlBuilder(group, options) {
      var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
      var line = buildCommon.makeLineSpan("overline-line", options);
      var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
      var vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: innerGroup
        }, {
          type: "kern",
          size: 3 * defaultRuleThickness
        }, {
          type: "elem",
          elem: line
        }, {
          type: "kern",
          size: defaultRuleThickness
        }]
      }, options);
      return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
    },
    mathmlBuilder(group, options) {
      var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
      operator.setAttribute("stretchy", "true");
      var node = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
      node.setAttribute("accent", "true");
      return node;
    }
  });
  defineFunction({
    type: "phantom",
    names: ["\\phantom"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        parser
      } = _ref;
      var body = args[0];
      return {
        type: "phantom",
        mode: parser.mode,
        body: ordargument(body)
      };
    },
    htmlBuilder: (group, options) => {
      var elements = buildExpression$1(group.body, options.withPhantom(), false);
      return buildCommon.makeFragment(elements);
    },
    mathmlBuilder: (group, options) => {
      var inner2 = buildExpression2(group.body, options);
      return new mathMLTree.MathNode("mphantom", inner2);
    }
  });
  defineFunction({
    type: "hphantom",
    names: ["\\hphantom"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler: (_ref2, args) => {
      var {
        parser
      } = _ref2;
      var body = args[0];
      return {
        type: "hphantom",
        mode: parser.mode,
        body
      };
    },
    htmlBuilder: (group, options) => {
      var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
      node.height = 0;
      node.depth = 0;
      if (node.children) {
        for (var i4 = 0; i4 < node.children.length; i4++) {
          node.children[i4].height = 0;
          node.children[i4].depth = 0;
        }
      }
      node = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: node
        }]
      }, options);
      return buildCommon.makeSpan(["mord"], [node], options);
    },
    mathmlBuilder: (group, options) => {
      var inner2 = buildExpression2(ordargument(group.body), options);
      var phantom = new mathMLTree.MathNode("mphantom", inner2);
      var node = new mathMLTree.MathNode("mpadded", [phantom]);
      node.setAttribute("height", "0px");
      node.setAttribute("depth", "0px");
      return node;
    }
  });
  defineFunction({
    type: "vphantom",
    names: ["\\vphantom"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler: (_ref3, args) => {
      var {
        parser
      } = _ref3;
      var body = args[0];
      return {
        type: "vphantom",
        mode: parser.mode,
        body
      };
    },
    htmlBuilder: (group, options) => {
      var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
      var fix = buildCommon.makeSpan(["fix"], []);
      return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
    },
    mathmlBuilder: (group, options) => {
      var inner2 = buildExpression2(ordargument(group.body), options);
      var phantom = new mathMLTree.MathNode("mphantom", inner2);
      var node = new mathMLTree.MathNode("mpadded", [phantom]);
      node.setAttribute("width", "0px");
      return node;
    }
  });
  defineFunction({
    type: "raisebox",
    names: ["\\raisebox"],
    props: {
      numArgs: 2,
      argTypes: ["size", "hbox"],
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      var amount = assertNodeType(args[0], "size").value;
      var body = args[1];
      return {
        type: "raisebox",
        mode: parser.mode,
        dy: amount,
        body
      };
    },
    htmlBuilder(group, options) {
      var body = buildGroup$1(group.body, options);
      var dy = calculateSize(group.dy, options);
      return buildCommon.makeVList({
        positionType: "shift",
        positionData: -dy,
        children: [{
          type: "elem",
          elem: body
        }]
      }, options);
    },
    mathmlBuilder(group, options) {
      var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
      var dy = group.dy.number + group.dy.unit;
      node.setAttribute("voffset", dy);
      return node;
    }
  });
  defineFunction({
    type: "internal",
    names: ["\\relax"],
    props: {
      numArgs: 0,
      allowedInText: true,
      allowedInArgument: true
    },
    handler(_ref) {
      var {
        parser
      } = _ref;
      return {
        type: "internal",
        mode: parser.mode
      };
    }
  });
  defineFunction({
    type: "rule",
    names: ["\\rule"],
    props: {
      numArgs: 2,
      numOptionalArgs: 1,
      allowedInText: true,
      allowedInMath: true,
      argTypes: ["size", "size", "size"]
    },
    handler(_ref, args, optArgs) {
      var {
        parser
      } = _ref;
      var shift = optArgs[0];
      var width = assertNodeType(args[0], "size");
      var height = assertNodeType(args[1], "size");
      return {
        type: "rule",
        mode: parser.mode,
        shift: shift && assertNodeType(shift, "size").value,
        width: width.value,
        height: height.value
      };
    },
    htmlBuilder(group, options) {
      var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
      var width = calculateSize(group.width, options);
      var height = calculateSize(group.height, options);
      var shift = group.shift ? calculateSize(group.shift, options) : 0;
      rule.style.borderRightWidth = makeEm(width);
      rule.style.borderTopWidth = makeEm(height);
      rule.style.bottom = makeEm(shift);
      rule.width = width;
      rule.height = height + shift;
      rule.depth = -shift;
      rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
      return rule;
    },
    mathmlBuilder(group, options) {
      var width = calculateSize(group.width, options);
      var height = calculateSize(group.height, options);
      var shift = group.shift ? calculateSize(group.shift, options) : 0;
      var color = options.color && options.getColor() || "black";
      var rule = new mathMLTree.MathNode("mspace");
      rule.setAttribute("mathbackground", color);
      rule.setAttribute("width", makeEm(width));
      rule.setAttribute("height", makeEm(height));
      var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
      if (shift >= 0) {
        wrapper.setAttribute("height", makeEm(shift));
      } else {
        wrapper.setAttribute("height", makeEm(shift));
        wrapper.setAttribute("depth", makeEm(-shift));
      }
      wrapper.setAttribute("voffset", makeEm(shift));
      return wrapper;
    }
  });
  function sizingGroup(value, options, baseOptions) {
    var inner2 = buildExpression$1(value, options, false);
    var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
    for (var i4 = 0; i4 < inner2.length; i4++) {
      var pos = inner2[i4].classes.indexOf("sizing");
      if (pos < 0) {
        Array.prototype.push.apply(inner2[i4].classes, options.sizingClasses(baseOptions));
      } else if (inner2[i4].classes[pos + 1] === "reset-size" + options.size) {
        inner2[i4].classes[pos + 1] = "reset-size" + baseOptions.size;
      }
      inner2[i4].height *= multiplier;
      inner2[i4].depth *= multiplier;
    }
    return buildCommon.makeFragment(inner2);
  }
  var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
  var htmlBuilder2 = (group, options) => {
    var newOptions = options.havingSize(group.size);
    return sizingGroup(group.body, newOptions, options);
  };
  defineFunction({
    type: "sizing",
    names: sizeFuncs,
    props: {
      numArgs: 0,
      allowedInText: true
    },
    handler: (_ref, args) => {
      var {
        breakOnTokenText,
        funcName,
        parser
      } = _ref;
      var body = parser.parseExpression(false, breakOnTokenText);
      return {
        type: "sizing",
        mode: parser.mode,
        // Figure out what size to use based on the list of functions above
        size: sizeFuncs.indexOf(funcName) + 1,
        body
      };
    },
    htmlBuilder: htmlBuilder2,
    mathmlBuilder: (group, options) => {
      var newOptions = options.havingSize(group.size);
      var inner2 = buildExpression2(group.body, newOptions);
      var node = new mathMLTree.MathNode("mstyle", inner2);
      node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
      return node;
    }
  });
  defineFunction({
    type: "smash",
    names: ["\\smash"],
    props: {
      numArgs: 1,
      numOptionalArgs: 1,
      allowedInText: true
    },
    handler: (_ref, args, optArgs) => {
      var {
        parser
      } = _ref;
      var smashHeight = false;
      var smashDepth = false;
      var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
      if (tbArg) {
        var letter = "";
        for (var i4 = 0; i4 < tbArg.body.length; ++i4) {
          var node = tbArg.body[i4];
          letter = node.text;
          if (letter === "t") {
            smashHeight = true;
          } else if (letter === "b") {
            smashDepth = true;
          } else {
            smashHeight = false;
            smashDepth = false;
            break;
          }
        }
      } else {
        smashHeight = true;
        smashDepth = true;
      }
      var body = args[0];
      return {
        type: "smash",
        mode: parser.mode,
        body,
        smashHeight,
        smashDepth
      };
    },
    htmlBuilder: (group, options) => {
      var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      if (!group.smashHeight && !group.smashDepth) {
        return node;
      }
      if (group.smashHeight) {
        node.height = 0;
        if (node.children) {
          for (var i4 = 0; i4 < node.children.length; i4++) {
            node.children[i4].height = 0;
          }
        }
      }
      if (group.smashDepth) {
        node.depth = 0;
        if (node.children) {
          for (var _i = 0; _i < node.children.length; _i++) {
            node.children[_i].depth = 0;
          }
        }
      }
      var smashedNode = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: node
        }]
      }, options);
      return buildCommon.makeSpan(["mord"], [smashedNode], options);
    },
    mathmlBuilder: (group, options) => {
      var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
      if (group.smashHeight) {
        node.setAttribute("height", "0px");
      }
      if (group.smashDepth) {
        node.setAttribute("depth", "0px");
      }
      return node;
    }
  });
  defineFunction({
    type: "sqrt",
    names: ["\\sqrt"],
    props: {
      numArgs: 1,
      numOptionalArgs: 1
    },
    handler(_ref, args, optArgs) {
      var {
        parser
      } = _ref;
      var index = optArgs[0];
      var body = args[0];
      return {
        type: "sqrt",
        mode: parser.mode,
        body,
        index
      };
    },
    htmlBuilder(group, options) {
      var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
      if (inner2.height === 0) {
        inner2.height = options.fontMetrics().xHeight;
      }
      inner2 = buildCommon.wrapFragment(inner2, options);
      var metrics = options.fontMetrics();
      var theta = metrics.defaultRuleThickness;
      var phi = theta;
      if (options.style.id < Style$1.TEXT.id) {
        phi = options.fontMetrics().xHeight;
      }
      var lineClearance = theta + phi / 4;
      var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
      var {
        span: img,
        ruleWidth,
        advanceWidth
      } = delimiter.sqrtImage(minDelimiterHeight, options);
      var delimDepth = img.height - ruleWidth;
      if (delimDepth > inner2.height + inner2.depth + lineClearance) {
        lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
      }
      var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
      inner2.style.paddingLeft = makeEm(advanceWidth);
      var body = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: inner2,
          wrapperClasses: ["svg-align"]
        }, {
          type: "kern",
          size: -(inner2.height + imgShift)
        }, {
          type: "elem",
          elem: img
        }, {
          type: "kern",
          size: ruleWidth
        }]
      }, options);
      if (!group.index) {
        return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
      } else {
        var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
        var rootm = buildGroup$1(group.index, newOptions, options);
        var toShift = 0.6 * (body.height - body.depth);
        var rootVList = buildCommon.makeVList({
          positionType: "shift",
          positionData: -toShift,
          children: [{
            type: "elem",
            elem: rootm
          }]
        }, options);
        var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
        return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
      }
    },
    mathmlBuilder(group, options) {
      var {
        body,
        index
      } = group;
      return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
    }
  });
  var styleMap = {
    "display": Style$1.DISPLAY,
    "text": Style$1.TEXT,
    "script": Style$1.SCRIPT,
    "scriptscript": Style$1.SCRIPTSCRIPT
  };
  defineFunction({
    type: "styling",
    names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
    props: {
      numArgs: 0,
      allowedInText: true,
      primitive: true
    },
    handler(_ref, args) {
      var {
        breakOnTokenText,
        funcName,
        parser
      } = _ref;
      var body = parser.parseExpression(true, breakOnTokenText);
      var style = funcName.slice(1, funcName.length - 5);
      return {
        type: "styling",
        mode: parser.mode,
        // Figure out what style to use by pulling out the style from
        // the function name
        style,
        body
      };
    },
    htmlBuilder(group, options) {
      var newStyle = styleMap[group.style];
      var newOptions = options.havingStyle(newStyle).withFont("");
      return sizingGroup(group.body, newOptions, options);
    },
    mathmlBuilder(group, options) {
      var newStyle = styleMap[group.style];
      var newOptions = options.havingStyle(newStyle);
      var inner2 = buildExpression2(group.body, newOptions);
      var node = new mathMLTree.MathNode("mstyle", inner2);
      var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
      };
      var attr = styleAttributes[group.style];
      node.setAttribute("scriptlevel", attr[0]);
      node.setAttribute("displaystyle", attr[1]);
      return node;
    }
  });
  var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
    var base = group.base;
    if (!base) {
      return null;
    } else if (base.type === "op") {
      var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
      return delegate ? htmlBuilder$2 : null;
    } else if (base.type === "operatorname") {
      var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
      return _delegate ? htmlBuilder$1 : null;
    } else if (base.type === "accent") {
      return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
    } else if (base.type === "horizBrace") {
      var isSup = !group.sub;
      return isSup === base.isOver ? htmlBuilder$3 : null;
    } else {
      return null;
    }
  };
  defineFunctionBuilders({
    type: "supsub",
    htmlBuilder(group, options) {
      var builderDelegate = htmlBuilderDelegate(group, options);
      if (builderDelegate) {
        return builderDelegate(group, options);
      }
      var {
        base: valueBase,
        sup: valueSup,
        sub: valueSub
      } = group;
      var base = buildGroup$1(valueBase, options);
      var supm;
      var subm;
      var metrics = options.fontMetrics();
      var supShift = 0;
      var subShift = 0;
      var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
      if (valueSup) {
        var newOptions = options.havingStyle(options.style.sup());
        supm = buildGroup$1(valueSup, newOptions, options);
        if (!isCharacterBox3) {
          supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
        }
      }
      if (valueSub) {
        var _newOptions = options.havingStyle(options.style.sub());
        subm = buildGroup$1(valueSub, _newOptions, options);
        if (!isCharacterBox3) {
          subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
        }
      }
      var minSupShift;
      if (options.style === Style$1.DISPLAY) {
        minSupShift = metrics.sup1;
      } else if (options.style.cramped) {
        minSupShift = metrics.sup3;
      } else {
        minSupShift = metrics.sup2;
      }
      var multiplier = options.sizeMultiplier;
      var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
      var marginLeft = null;
      if (subm) {
        var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
        if (base instanceof SymbolNode || isOiint) {
          marginLeft = makeEm(-base.italic);
        }
      }
      var supsub;
      if (supm && subm) {
        supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
        subShift = Math.max(subShift, metrics.sub2);
        var ruleWidth = metrics.defaultRuleThickness;
        var maxWidth = 4 * ruleWidth;
        if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
          subShift = maxWidth - (supShift - supm.depth) + subm.height;
          var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
          if (psi > 0) {
            supShift += psi;
            subShift -= psi;
          }
        }
        var vlistElem = [{
          type: "elem",
          elem: subm,
          shift: subShift,
          marginRight,
          marginLeft
        }, {
          type: "elem",
          elem: supm,
          shift: -supShift,
          marginRight
        }];
        supsub = buildCommon.makeVList({
          positionType: "individualShift",
          children: vlistElem
        }, options);
      } else if (subm) {
        subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
        var _vlistElem = [{
          type: "elem",
          elem: subm,
          marginLeft,
          marginRight
        }];
        supsub = buildCommon.makeVList({
          positionType: "shift",
          positionData: subShift,
          children: _vlistElem
        }, options);
      } else if (supm) {
        supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
        supsub = buildCommon.makeVList({
          positionType: "shift",
          positionData: -supShift,
          children: [{
            type: "elem",
            elem: supm,
            marginRight
          }]
        }, options);
      } else {
        throw new Error("supsub must have either sup or sub.");
      }
      var mclass = getTypeOfDomTree(base, "right") || "mord";
      return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
    },
    mathmlBuilder(group, options) {
      var isBrace = false;
      var isOver;
      var isSup;
      if (group.base && group.base.type === "horizBrace") {
        isSup = !!group.sup;
        if (isSup === group.base.isOver) {
          isBrace = true;
          isOver = group.base.isOver;
        }
      }
      if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
        group.base.parentIsSupSub = true;
      }
      var children = [buildGroup2(group.base, options)];
      if (group.sub) {
        children.push(buildGroup2(group.sub, options));
      }
      if (group.sup) {
        children.push(buildGroup2(group.sup, options));
      }
      var nodeType;
      if (isBrace) {
        nodeType = isOver ? "mover" : "munder";
      } else if (!group.sub) {
        var base = group.base;
        if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
          nodeType = "mover";
        } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
          nodeType = "mover";
        } else {
          nodeType = "msup";
        }
      } else if (!group.sup) {
        var _base = group.base;
        if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
          nodeType = "munder";
        } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
          nodeType = "munder";
        } else {
          nodeType = "msub";
        }
      } else {
        var _base2 = group.base;
        if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
          nodeType = "munderover";
        } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
          nodeType = "munderover";
        } else {
          nodeType = "msubsup";
        }
      }
      return new mathMLTree.MathNode(nodeType, children);
    }
  });
  defineFunctionBuilders({
    type: "atom",
    htmlBuilder(group, options) {
      return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
    },
    mathmlBuilder(group, options) {
      var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
      if (group.family === "bin") {
        var variant = getVariant(group, options);
        if (variant === "bold-italic") {
          node.setAttribute("mathvariant", variant);
        }
      } else if (group.family === "punct") {
        node.setAttribute("separator", "true");
      } else if (group.family === "open" || group.family === "close") {
        node.setAttribute("stretchy", "false");
      }
      return node;
    }
  });
  var defaultVariant = {
    "mi": "italic",
    "mn": "normal",
    "mtext": "normal"
  };
  defineFunctionBuilders({
    type: "mathord",
    htmlBuilder(group, options) {
      return buildCommon.makeOrd(group, options, "mathord");
    },
    mathmlBuilder(group, options) {
      var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
      var variant = getVariant(group, options) || "italic";
      if (variant !== defaultVariant[node.type]) {
        node.setAttribute("mathvariant", variant);
      }
      return node;
    }
  });
  defineFunctionBuilders({
    type: "textord",
    htmlBuilder(group, options) {
      return buildCommon.makeOrd(group, options, "textord");
    },
    mathmlBuilder(group, options) {
      var text2 = makeText(group.text, group.mode, options);
      var variant = getVariant(group, options) || "normal";
      var node;
      if (group.mode === "text") {
        node = new mathMLTree.MathNode("mtext", [text2]);
      } else if (/[0-9]/.test(group.text)) {
        node = new mathMLTree.MathNode("mn", [text2]);
      } else if (group.text === "\\prime") {
        node = new mathMLTree.MathNode("mo", [text2]);
      } else {
        node = new mathMLTree.MathNode("mi", [text2]);
      }
      if (variant !== defaultVariant[node.type]) {
        node.setAttribute("mathvariant", variant);
      }
      return node;
    }
  });
  var cssSpace = {
    "\\nobreak": "nobreak",
    "\\allowbreak": "allowbreak"
  };
  var regularSpace = {
    " ": {},
    "\\ ": {},
    "~": {
      className: "nobreak"
    },
    "\\space": {},
    "\\nobreakspace": {
      className: "nobreak"
    }
  };
  defineFunctionBuilders({
    type: "spacing",
    htmlBuilder(group, options) {
      if (regularSpace.hasOwnProperty(group.text)) {
        var className = regularSpace[group.text].className || "";
        if (group.mode === "text") {
          var ord = buildCommon.makeOrd(group, options, "textord");
          ord.classes.push(className);
          return ord;
        } else {
          return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
        }
      } else if (cssSpace.hasOwnProperty(group.text)) {
        return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
      } else {
        throw new ParseError('Unknown type of space "' + group.text + '"');
      }
    },
    mathmlBuilder(group, options) {
      var node;
      if (regularSpace.hasOwnProperty(group.text)) {
        node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
      } else if (cssSpace.hasOwnProperty(group.text)) {
        return new mathMLTree.MathNode("mspace");
      } else {
        throw new ParseError('Unknown type of space "' + group.text + '"');
      }
      return node;
    }
  });
  var pad = () => {
    var padNode = new mathMLTree.MathNode("mtd", []);
    padNode.setAttribute("width", "50%");
    return padNode;
  };
  defineFunctionBuilders({
    type: "tag",
    mathmlBuilder(group, options) {
      var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
      table.setAttribute("width", "100%");
      return table;
    }
  });
  var textFontFamilies = {
    "\\text": void 0,
    "\\textrm": "textrm",
    "\\textsf": "textsf",
    "\\texttt": "texttt",
    "\\textnormal": "textrm"
  };
  var textFontWeights = {
    "\\textbf": "textbf",
    "\\textmd": "textmd"
  };
  var textFontShapes = {
    "\\textit": "textit",
    "\\textup": "textup"
  };
  var optionsWithFont = (group, options) => {
    var font = group.font;
    if (!font) {
      return options;
    } else if (textFontFamilies[font]) {
      return options.withTextFontFamily(textFontFamilies[font]);
    } else if (textFontWeights[font]) {
      return options.withTextFontWeight(textFontWeights[font]);
    } else if (font === "\\emph") {
      return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
    }
    return options.withTextFontShape(textFontShapes[font]);
  };
  defineFunction({
    type: "text",
    names: [
      // Font families
      "\\text",
      "\\textrm",
      "\\textsf",
      "\\texttt",
      "\\textnormal",
      // Font weights
      "\\textbf",
      "\\textmd",
      // Font Shapes
      "\\textit",
      "\\textup",
      "\\emph"
    ],
    props: {
      numArgs: 1,
      argTypes: ["text"],
      allowedInArgument: true,
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser,
        funcName
      } = _ref;
      var body = args[0];
      return {
        type: "text",
        mode: parser.mode,
        body: ordargument(body),
        font: funcName
      };
    },
    htmlBuilder(group, options) {
      var newOptions = optionsWithFont(group, options);
      var inner2 = buildExpression$1(group.body, newOptions, true);
      return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
    },
    mathmlBuilder(group, options) {
      var newOptions = optionsWithFont(group, options);
      return buildExpressionRow(group.body, newOptions);
    }
  });
  defineFunction({
    type: "underline",
    names: ["\\underline"],
    props: {
      numArgs: 1,
      allowedInText: true
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      return {
        type: "underline",
        mode: parser.mode,
        body: args[0]
      };
    },
    htmlBuilder(group, options) {
      var innerGroup = buildGroup$1(group.body, options);
      var line = buildCommon.makeLineSpan("underline-line", options);
      var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
      var vlist = buildCommon.makeVList({
        positionType: "top",
        positionData: innerGroup.height,
        children: [{
          type: "kern",
          size: defaultRuleThickness
        }, {
          type: "elem",
          elem: line
        }, {
          type: "kern",
          size: 3 * defaultRuleThickness
        }, {
          type: "elem",
          elem: innerGroup
        }]
      }, options);
      return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
    },
    mathmlBuilder(group, options) {
      var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
      operator.setAttribute("stretchy", "true");
      var node = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
      node.setAttribute("accentunder", "true");
      return node;
    }
  });
  defineFunction({
    type: "vcenter",
    names: ["\\vcenter"],
    props: {
      numArgs: 1,
      argTypes: ["original"],
      // In LaTeX, \vcenter can act only on a box.
      allowedInText: false
    },
    handler(_ref, args) {
      var {
        parser
      } = _ref;
      return {
        type: "vcenter",
        mode: parser.mode,
        body: args[0]
      };
    },
    htmlBuilder(group, options) {
      var body = buildGroup$1(group.body, options);
      var axisHeight = options.fontMetrics().axisHeight;
      var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
      return buildCommon.makeVList({
        positionType: "shift",
        positionData: dy,
        children: [{
          type: "elem",
          elem: body
        }]
      }, options);
    },
    mathmlBuilder(group, options) {
      return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
    }
  });
  defineFunction({
    type: "verb",
    names: ["\\verb"],
    props: {
      numArgs: 0,
      allowedInText: true
    },
    handler(context, args, optArgs) {
      throw new ParseError("\\verb ended by end of line instead of matching delimiter");
    },
    htmlBuilder(group, options) {
      var text2 = makeVerb(group);
      var body = [];
      var newOptions = options.havingStyle(options.style.text());
      for (var i4 = 0; i4 < text2.length; i4++) {
        var c3 = text2[i4];
        if (c3 === "~") {
          c3 = "\\textasciitilde";
        }
        body.push(buildCommon.makeSymbol(c3, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
      }
      return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
    },
    mathmlBuilder(group, options) {
      var text2 = new mathMLTree.TextNode(makeVerb(group));
      var node = new mathMLTree.MathNode("mtext", [text2]);
      node.setAttribute("mathvariant", "monospace");
      return node;
    }
  });
  var makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
  var functions = _functions;
  var spaceRegexString = "[ \r\n	]";
  var controlWordRegexString = "\\\\[a-zA-Z@]+";
  var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
  var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
  var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
  var combiningDiacriticalMarkString = "[\u0300-\u036F]";
  var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
  var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
  (controlSpaceRegexString + "|") + // \whitespace
  "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
  (combiningDiacriticalMarkString + "*") + // ...plus accents
  "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
  (combiningDiacriticalMarkString + "*") + // ...plus accents
  "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
  ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
  ("|" + controlSymbolRegexString + ")");
  var Lexer = class {
    // Category codes. The lexer only supports comment characters (14) for now.
    // MacroExpander additionally distinguishes active (13).
    constructor(input, settings) {
      this.input = void 0;
      this.settings = void 0;
      this.tokenRegex = void 0;
      this.catcodes = void 0;
      this.input = input;
      this.settings = settings;
      this.tokenRegex = new RegExp(tokenRegexString, "g");
      this.catcodes = {
        "%": 14,
        // comment character
        "~": 13
        // active character
      };
    }
    setCatcode(char, code) {
      this.catcodes[char] = code;
    }
    /**
     * This function lexes a single token.
     */
    lex() {
      var input = this.input;
      var pos = this.tokenRegex.lastIndex;
      if (pos === input.length) {
        return new Token("EOF", new SourceLocation(this, pos, pos));
      }
      var match = this.tokenRegex.exec(input);
      if (match === null || match.index !== pos) {
        throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
      }
      var text2 = match[6] || match[3] || (match[2] ? "\\ " : " ");
      if (this.catcodes[text2] === 14) {
        var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
        if (nlIndex === -1) {
          this.tokenRegex.lastIndex = input.length;
          this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
        } else {
          this.tokenRegex.lastIndex = nlIndex + 1;
        }
        return this.lex();
      }
      return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
    }
  };
  var Namespace = class {
    /**
     * Both arguments are optional.  The first argument is an object of
     * built-in mappings which never change.  The second argument is an object
     * of initial (global-level) mappings, which will constantly change
     * according to any global/top-level `set`s done.
     */
    constructor(builtins, globalMacros) {
      if (builtins === void 0) {
        builtins = {};
      }
      if (globalMacros === void 0) {
        globalMacros = {};
      }
      this.current = void 0;
      this.builtins = void 0;
      this.undefStack = void 0;
      this.current = globalMacros;
      this.builtins = builtins;
      this.undefStack = [];
    }
    /**
     * Start a new nested group, affecting future local `set`s.
     */
    beginGroup() {
      this.undefStack.push({});
    }
    /**
     * End current nested group, restoring values before the group began.
     */
    endGroup() {
      if (this.undefStack.length === 0) {
        throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
      }
      var undefs = this.undefStack.pop();
      for (var undef in undefs) {
        if (undefs.hasOwnProperty(undef)) {
          if (undefs[undef] == null) {
            delete this.current[undef];
          } else {
            this.current[undef] = undefs[undef];
          }
        }
      }
    }
    /**
     * Ends all currently nested groups (if any), restoring values before the
     * groups began.  Useful in case of an error in the middle of parsing.
     */
    endGroups() {
      while (this.undefStack.length > 0) {
        this.endGroup();
      }
    }
    /**
     * Detect whether `name` has a definition.  Equivalent to
     * `get(name) != null`.
     */
    has(name) {
      return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
    }
    /**
     * Get the current value of a name, or `undefined` if there is no value.
     *
     * Note: Do not use `if (namespace.get(...))` to detect whether a macro
     * is defined, as the definition may be the empty string which evaluates
     * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
     * `if (namespace.has(...))`.
     */
    get(name) {
      if (this.current.hasOwnProperty(name)) {
        return this.current[name];
      } else {
        return this.builtins[name];
      }
    }
    /**
     * Set the current value of a name, and optionally set it globally too.
     * Local set() sets the current value and (when appropriate) adds an undo
     * operation to the undo stack.  Global set() may change the undo
     * operation at every level, so takes time linear in their number.
     * A value of undefined means to delete existing definitions.
     */
    set(name, value, global) {
      if (global === void 0) {
        global = false;
      }
      if (global) {
        for (var i4 = 0; i4 < this.undefStack.length; i4++) {
          delete this.undefStack[i4][name];
        }
        if (this.undefStack.length > 0) {
          this.undefStack[this.undefStack.length - 1][name] = value;
        }
      } else {
        var top = this.undefStack[this.undefStack.length - 1];
        if (top && !top.hasOwnProperty(name)) {
          top[name] = this.current[name];
        }
      }
      if (value == null) {
        delete this.current[name];
      } else {
        this.current[name] = value;
      }
    }
  };
  var macros = _macros;
  defineMacro("\\noexpand", function(context) {
    var t3 = context.popToken();
    if (context.isExpandable(t3.text)) {
      t3.noexpand = true;
      t3.treatAsRelax = true;
    }
    return {
      tokens: [t3],
      numArgs: 0
    };
  });
  defineMacro("\\expandafter", function(context) {
    var t3 = context.popToken();
    context.expandOnce(true);
    return {
      tokens: [t3],
      numArgs: 0
    };
  });
  defineMacro("\\@firstoftwo", function(context) {
    var args = context.consumeArgs(2);
    return {
      tokens: args[0],
      numArgs: 0
    };
  });
  defineMacro("\\@secondoftwo", function(context) {
    var args = context.consumeArgs(2);
    return {
      tokens: args[1],
      numArgs: 0
    };
  });
  defineMacro("\\@ifnextchar", function(context) {
    var args = context.consumeArgs(3);
    context.consumeSpaces();
    var nextToken = context.future();
    if (args[0].length === 1 && args[0][0].text === nextToken.text) {
      return {
        tokens: args[1],
        numArgs: 0
      };
    } else {
      return {
        tokens: args[2],
        numArgs: 0
      };
    }
  });
  defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
  defineMacro("\\TextOrMath", function(context) {
    var args = context.consumeArgs(2);
    if (context.mode === "text") {
      return {
        tokens: args[0],
        numArgs: 0
      };
    } else {
      return {
        tokens: args[1],
        numArgs: 0
      };
    }
  });
  var digitToNumber = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    "a": 10,
    "A": 10,
    "b": 11,
    "B": 11,
    "c": 12,
    "C": 12,
    "d": 13,
    "D": 13,
    "e": 14,
    "E": 14,
    "f": 15,
    "F": 15
  };
  defineMacro("\\char", function(context) {
    var token = context.popToken();
    var base;
    var number = "";
    if (token.text === "'") {
      base = 8;
      token = context.popToken();
    } else if (token.text === '"') {
      base = 16;
      token = context.popToken();
    } else if (token.text === "`") {
      token = context.popToken();
      if (token.text[0] === "\\") {
        number = token.text.charCodeAt(1);
      } else if (token.text === "EOF") {
        throw new ParseError("\\char` missing argument");
      } else {
        number = token.text.charCodeAt(0);
      }
    } else {
      base = 10;
    }
    if (base) {
      number = digitToNumber[token.text];
      if (number == null || number >= base) {
        throw new ParseError("Invalid base-" + base + " digit " + token.text);
      }
      var digit;
      while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
        number *= base;
        number += digit;
        context.popToken();
      }
    }
    return "\\@char{" + number + "}";
  });
  var newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
    var arg = context.consumeArg().tokens;
    if (arg.length !== 1) {
      throw new ParseError("\\newcommand's first argument must be a macro name");
    }
    var name = arg[0].text;
    var exists = context.isDefined(name);
    if (exists && !existsOK) {
      throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
    }
    if (!exists && !nonexistsOK) {
      throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
    }
    var numArgs = 0;
    arg = context.consumeArg().tokens;
    if (arg.length === 1 && arg[0].text === "[") {
      var argText = "";
      var token = context.expandNextToken();
      while (token.text !== "]" && token.text !== "EOF") {
        argText += token.text;
        token = context.expandNextToken();
      }
      if (!argText.match(/^\s*[0-9]+\s*$/)) {
        throw new ParseError("Invalid number of arguments: " + argText);
      }
      numArgs = parseInt(argText);
      arg = context.consumeArg().tokens;
    }
    if (!(exists && skipIfExists)) {
      context.macros.set(name, {
        tokens: arg,
        numArgs
      });
    }
    return "";
  };
  defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
  defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
  defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
  defineMacro("\\message", (context) => {
    var arg = context.consumeArgs(1)[0];
    console.log(arg.reverse().map((token) => token.text).join(""));
    return "";
  });
  defineMacro("\\errmessage", (context) => {
    var arg = context.consumeArgs(1)[0];
    console.error(arg.reverse().map((token) => token.text).join(""));
    return "";
  });
  defineMacro("\\show", (context) => {
    var tok = context.popToken();
    var name = tok.text;
    console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
    return "";
  });
  defineMacro("\\bgroup", "{");
  defineMacro("\\egroup", "}");
  defineMacro("~", "\\nobreakspace");
  defineMacro("\\lq", "`");
  defineMacro("\\rq", "'");
  defineMacro("\\aa", "\\r a");
  defineMacro("\\AA", "\\r A");
  defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
  defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
  defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
  defineMacro("\u212C", "\\mathscr{B}");
  defineMacro("\u2130", "\\mathscr{E}");
  defineMacro("\u2131", "\\mathscr{F}");
  defineMacro("\u210B", "\\mathscr{H}");
  defineMacro("\u2110", "\\mathscr{I}");
  defineMacro("\u2112", "\\mathscr{L}");
  defineMacro("\u2133", "\\mathscr{M}");
  defineMacro("\u211B", "\\mathscr{R}");
  defineMacro("\u212D", "\\mathfrak{C}");
  defineMacro("\u210C", "\\mathfrak{H}");
  defineMacro("\u2128", "\\mathfrak{Z}");
  defineMacro("\\Bbbk", "\\Bbb{k}");
  defineMacro("\xB7", "\\cdotp");
  defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
  defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
  defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
  defineMacro("\\mathstrut", "\\vphantom{(}");
  defineMacro("\\underbar", "\\underline{\\text{#1}}");
  defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
  defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
  defineMacro("\\ne", "\\neq");
  defineMacro("\u2260", "\\neq");
  defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
  defineMacro("\u2209", "\\notin");
  defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
  defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
  defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
  defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
  defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
  defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
  defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
  defineMacro("\u27C2", "\\perp");
  defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
  defineMacro("\u220C", "\\notni");
  defineMacro("\u231C", "\\ulcorner");
  defineMacro("\u231D", "\\urcorner");
  defineMacro("\u231E", "\\llcorner");
  defineMacro("\u231F", "\\lrcorner");
  defineMacro("\xA9", "\\copyright");
  defineMacro("\xAE", "\\textregistered");
  defineMacro("\uFE0F", "\\textregistered");
  defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
  defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
  defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
  defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
  defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
  defineMacro("\u22EE", "\\vdots");
  defineMacro("\\varGamma", "\\mathit{\\Gamma}");
  defineMacro("\\varDelta", "\\mathit{\\Delta}");
  defineMacro("\\varTheta", "\\mathit{\\Theta}");
  defineMacro("\\varLambda", "\\mathit{\\Lambda}");
  defineMacro("\\varXi", "\\mathit{\\Xi}");
  defineMacro("\\varPi", "\\mathit{\\Pi}");
  defineMacro("\\varSigma", "\\mathit{\\Sigma}");
  defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
  defineMacro("\\varPhi", "\\mathit{\\Phi}");
  defineMacro("\\varPsi", "\\mathit{\\Psi}");
  defineMacro("\\varOmega", "\\mathit{\\Omega}");
  defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
  defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
  defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
  defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
  defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
  defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
  defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
  defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
  var dotsByToken = {
    ",": "\\dotsc",
    "\\not": "\\dotsb",
    // \keybin@ checks for the following:
    "+": "\\dotsb",
    "=": "\\dotsb",
    "<": "\\dotsb",
    ">": "\\dotsb",
    "-": "\\dotsb",
    "*": "\\dotsb",
    ":": "\\dotsb",
    // Symbols whose definition starts with \DOTSB:
    "\\DOTSB": "\\dotsb",
    "\\coprod": "\\dotsb",
    "\\bigvee": "\\dotsb",
    "\\bigwedge": "\\dotsb",
    "\\biguplus": "\\dotsb",
    "\\bigcap": "\\dotsb",
    "\\bigcup": "\\dotsb",
    "\\prod": "\\dotsb",
    "\\sum": "\\dotsb",
    "\\bigotimes": "\\dotsb",
    "\\bigoplus": "\\dotsb",
    "\\bigodot": "\\dotsb",
    "\\bigsqcup": "\\dotsb",
    "\\And": "\\dotsb",
    "\\longrightarrow": "\\dotsb",
    "\\Longrightarrow": "\\dotsb",
    "\\longleftarrow": "\\dotsb",
    "\\Longleftarrow": "\\dotsb",
    "\\longleftrightarrow": "\\dotsb",
    "\\Longleftrightarrow": "\\dotsb",
    "\\mapsto": "\\dotsb",
    "\\longmapsto": "\\dotsb",
    "\\hookrightarrow": "\\dotsb",
    "\\doteq": "\\dotsb",
    // Symbols whose definition starts with \mathbin:
    "\\mathbin": "\\dotsb",
    // Symbols whose definition starts with \mathrel:
    "\\mathrel": "\\dotsb",
    "\\relbar": "\\dotsb",
    "\\Relbar": "\\dotsb",
    "\\xrightarrow": "\\dotsb",
    "\\xleftarrow": "\\dotsb",
    // Symbols whose definition starts with \DOTSI:
    "\\DOTSI": "\\dotsi",
    "\\int": "\\dotsi",
    "\\oint": "\\dotsi",
    "\\iint": "\\dotsi",
    "\\iiint": "\\dotsi",
    "\\iiiint": "\\dotsi",
    "\\idotsint": "\\dotsi",
    // Symbols whose definition starts with \DOTSX:
    "\\DOTSX": "\\dotsx"
  };
  defineMacro("\\dots", function(context) {
    var thedots = "\\dotso";
    var next = context.expandAfterFuture().text;
    if (next in dotsByToken) {
      thedots = dotsByToken[next];
    } else if (next.slice(0, 4) === "\\not") {
      thedots = "\\dotsb";
    } else if (next in symbols.math) {
      if (utils.contains(["bin", "rel"], symbols.math[next].group)) {
        thedots = "\\dotsb";
      }
    }
    return thedots;
  });
  var spaceAfterDots = {
    // \rightdelim@ checks for the following:
    ")": true,
    "]": true,
    "\\rbrack": true,
    "\\}": true,
    "\\rbrace": true,
    "\\rangle": true,
    "\\rceil": true,
    "\\rfloor": true,
    "\\rgroup": true,
    "\\rmoustache": true,
    "\\right": true,
    "\\bigr": true,
    "\\biggr": true,
    "\\Bigr": true,
    "\\Biggr": true,
    // \extra@ also tests for the following:
    "$": true,
    // \extrap@ checks for the following:
    ";": true,
    ".": true,
    ",": true
  };
  defineMacro("\\dotso", function(context) {
    var next = context.future().text;
    if (next in spaceAfterDots) {
      return "\\ldots\\,";
    } else {
      return "\\ldots";
    }
  });
  defineMacro("\\dotsc", function(context) {
    var next = context.future().text;
    if (next in spaceAfterDots && next !== ",") {
      return "\\ldots\\,";
    } else {
      return "\\ldots";
    }
  });
  defineMacro("\\cdots", function(context) {
    var next = context.future().text;
    if (next in spaceAfterDots) {
      return "\\@cdots\\,";
    } else {
      return "\\@cdots";
    }
  });
  defineMacro("\\dotsb", "\\cdots");
  defineMacro("\\dotsm", "\\cdots");
  defineMacro("\\dotsi", "\\!\\cdots");
  defineMacro("\\dotsx", "\\ldots\\,");
  defineMacro("\\DOTSI", "\\relax");
  defineMacro("\\DOTSB", "\\relax");
  defineMacro("\\DOTSX", "\\relax");
  defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
  defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
  defineMacro("\\thinspace", "\\,");
  defineMacro("\\>", "\\mskip{4mu}");
  defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
  defineMacro("\\medspace", "\\:");
  defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
  defineMacro("\\thickspace", "\\;");
  defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
  defineMacro("\\negthinspace", "\\!");
  defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
  defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
  defineMacro("\\enspace", "\\kern.5em ");
  defineMacro("\\enskip", "\\hskip.5em\\relax");
  defineMacro("\\quad", "\\hskip1em\\relax");
  defineMacro("\\qquad", "\\hskip2em\\relax");
  defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
  defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
  defineMacro("\\tag@literal", (context) => {
    if (context.macros.get("\\df@tag")) {
      throw new ParseError("Multiple \\tag");
    }
    return "\\gdef\\df@tag{\\text{#1}}";
  });
  defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
  defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
  defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
  defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
  defineMacro("\\newline", "\\\\\\relax");
  defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
  var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
  defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
  defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
  defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
  defineMacro("\\@hspace", "\\hskip #1\\relax");
  defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
  defineMacro("\\ordinarycolon", ":");
  defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
  defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
  defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
  defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
  defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
  defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
  defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
  defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
  defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
  defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
  defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
  defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
  defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
  defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
  defineMacro("\u2237", "\\dblcolon");
  defineMacro("\u2239", "\\eqcolon");
  defineMacro("\u2254", "\\coloneqq");
  defineMacro("\u2255", "\\eqqcolon");
  defineMacro("\u2A74", "\\Coloneqq");
  defineMacro("\\ratio", "\\vcentcolon");
  defineMacro("\\coloncolon", "\\dblcolon");
  defineMacro("\\colonequals", "\\coloneqq");
  defineMacro("\\coloncolonequals", "\\Coloneqq");
  defineMacro("\\equalscolon", "\\eqqcolon");
  defineMacro("\\equalscoloncolon", "\\Eqqcolon");
  defineMacro("\\colonminus", "\\coloneq");
  defineMacro("\\coloncolonminus", "\\Coloneq");
  defineMacro("\\minuscolon", "\\eqcolon");
  defineMacro("\\minuscoloncolon", "\\Eqcolon");
  defineMacro("\\coloncolonapprox", "\\Colonapprox");
  defineMacro("\\coloncolonsim", "\\Colonsim");
  defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
  defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
  defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
  defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
  defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
  defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
  defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
  defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
  defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
  defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
  defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
  defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
  defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
  defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
  defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
  defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
  defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
  defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
  defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
  defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
  defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
  defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
  defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
  defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
  defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
  defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
  defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
  defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
  defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
  defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
  defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
  defineMacro("\u27E6", "\\llbracket");
  defineMacro("\u27E7", "\\rrbracket");
  defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
  defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
  defineMacro("\u2983", "\\lBrace");
  defineMacro("\u2984", "\\rBrace");
  defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
  defineMacro("\u29B5", "\\minuso");
  defineMacro("\\darr", "\\downarrow");
  defineMacro("\\dArr", "\\Downarrow");
  defineMacro("\\Darr", "\\Downarrow");
  defineMacro("\\lang", "\\langle");
  defineMacro("\\rang", "\\rangle");
  defineMacro("\\uarr", "\\uparrow");
  defineMacro("\\uArr", "\\Uparrow");
  defineMacro("\\Uarr", "\\Uparrow");
  defineMacro("\\N", "\\mathbb{N}");
  defineMacro("\\R", "\\mathbb{R}");
  defineMacro("\\Z", "\\mathbb{Z}");
  defineMacro("\\alef", "\\aleph");
  defineMacro("\\alefsym", "\\aleph");
  defineMacro("\\Alpha", "\\mathrm{A}");
  defineMacro("\\Beta", "\\mathrm{B}");
  defineMacro("\\bull", "\\bullet");
  defineMacro("\\Chi", "\\mathrm{X}");
  defineMacro("\\clubs", "\\clubsuit");
  defineMacro("\\cnums", "\\mathbb{C}");
  defineMacro("\\Complex", "\\mathbb{C}");
  defineMacro("\\Dagger", "\\ddagger");
  defineMacro("\\diamonds", "\\diamondsuit");
  defineMacro("\\empty", "\\emptyset");
  defineMacro("\\Epsilon", "\\mathrm{E}");
  defineMacro("\\Eta", "\\mathrm{H}");
  defineMacro("\\exist", "\\exists");
  defineMacro("\\harr", "\\leftrightarrow");
  defineMacro("\\hArr", "\\Leftrightarrow");
  defineMacro("\\Harr", "\\Leftrightarrow");
  defineMacro("\\hearts", "\\heartsuit");
  defineMacro("\\image", "\\Im");
  defineMacro("\\infin", "\\infty");
  defineMacro("\\Iota", "\\mathrm{I}");
  defineMacro("\\isin", "\\in");
  defineMacro("\\Kappa", "\\mathrm{K}");
  defineMacro("\\larr", "\\leftarrow");
  defineMacro("\\lArr", "\\Leftarrow");
  defineMacro("\\Larr", "\\Leftarrow");
  defineMacro("\\lrarr", "\\leftrightarrow");
  defineMacro("\\lrArr", "\\Leftrightarrow");
  defineMacro("\\Lrarr", "\\Leftrightarrow");
  defineMacro("\\Mu", "\\mathrm{M}");
  defineMacro("\\natnums", "\\mathbb{N}");
  defineMacro("\\Nu", "\\mathrm{N}");
  defineMacro("\\Omicron", "\\mathrm{O}");
  defineMacro("\\plusmn", "\\pm");
  defineMacro("\\rarr", "\\rightarrow");
  defineMacro("\\rArr", "\\Rightarrow");
  defineMacro("\\Rarr", "\\Rightarrow");
  defineMacro("\\real", "\\Re");
  defineMacro("\\reals", "\\mathbb{R}");
  defineMacro("\\Reals", "\\mathbb{R}");
  defineMacro("\\Rho", "\\mathrm{P}");
  defineMacro("\\sdot", "\\cdot");
  defineMacro("\\sect", "\\S");
  defineMacro("\\spades", "\\spadesuit");
  defineMacro("\\sub", "\\subset");
  defineMacro("\\sube", "\\subseteq");
  defineMacro("\\supe", "\\supseteq");
  defineMacro("\\Tau", "\\mathrm{T}");
  defineMacro("\\thetasym", "\\vartheta");
  defineMacro("\\weierp", "\\wp");
  defineMacro("\\Zeta", "\\mathrm{Z}");
  defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
  defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
  defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
  defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
  defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
  defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
  defineMacro("\\Bra", "\\left\\langle#1\\right|");
  defineMacro("\\Ket", "\\left|#1\\right\\rangle");
  var braketHelper = (one) => (context) => {
    var left = context.consumeArg().tokens;
    var middle = context.consumeArg().tokens;
    var middleDouble = context.consumeArg().tokens;
    var right = context.consumeArg().tokens;
    var oldMiddle = context.macros.get("|");
    var oldMiddleDouble = context.macros.get("\\|");
    context.macros.beginGroup();
    var midMacro = (double) => (context2) => {
      if (one) {
        context2.macros.set("|", oldMiddle);
        if (middleDouble.length) {
          context2.macros.set("\\|", oldMiddleDouble);
        }
      }
      var doubled = double;
      if (!double && middleDouble.length) {
        var nextToken = context2.future();
        if (nextToken.text === "|") {
          context2.popToken();
          doubled = true;
        }
      }
      return {
        tokens: doubled ? middleDouble : middle,
        numArgs: 0
      };
    };
    context.macros.set("|", midMacro(false));
    if (middleDouble.length) {
      context.macros.set("\\|", midMacro(true));
    }
    var arg = context.consumeArg().tokens;
    var expanded = context.expandTokens([
      ...right,
      ...arg,
      ...left
      // reversed
    ]);
    context.macros.endGroup();
    return {
      tokens: expanded.reverse(),
      numArgs: 0
    };
  };
  defineMacro("\\bra@ket", braketHelper(false));
  defineMacro("\\bra@set", braketHelper(true));
  defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
  defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
  defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
  defineMacro("\\angln", "{\\angl n}");
  defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
  defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
  defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
  defineMacro("\\red", "\\textcolor{##df0030}{#1}");
  defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
  defineMacro("\\gray", "\\textcolor{gray}{#1}");
  defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
  defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
  defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
  defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
  defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
  defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
  defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
  defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
  defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
  defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
  defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
  defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
  defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
  defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
  defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
  defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
  defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
  defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
  defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
  defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
  defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
  defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
  defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
  defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
  defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
  defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
  defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
  defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
  defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
  defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
  defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
  defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
  defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
  defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
  defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
  defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
  defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
  defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
  defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
  defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
  defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
  defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
  defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
  defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
  defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
  defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
  defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
  defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
  defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
  defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
  var implicitCommands = {
    "^": true,
    // Parser.js
    "_": true,
    // Parser.js
    "\\limits": true,
    // Parser.js
    "\\nolimits": true
    // Parser.js
  };
  var MacroExpander = class {
    constructor(input, settings, mode) {
      this.settings = void 0;
      this.expansionCount = void 0;
      this.lexer = void 0;
      this.macros = void 0;
      this.stack = void 0;
      this.mode = void 0;
      this.settings = settings;
      this.expansionCount = 0;
      this.feed(input);
      this.macros = new Namespace(macros, settings.macros);
      this.mode = mode;
      this.stack = [];
    }
    /**
     * Feed a new input string to the same MacroExpander
     * (with existing macros etc.).
     */
    feed(input) {
      this.lexer = new Lexer(input, this.settings);
    }
    /**
     * Switches between "text" and "math" modes.
     */
    switchMode(newMode) {
      this.mode = newMode;
    }
    /**
     * Start a new group nesting within all namespaces.
     */
    beginGroup() {
      this.macros.beginGroup();
    }
    /**
     * End current group nesting within all namespaces.
     */
    endGroup() {
      this.macros.endGroup();
    }
    /**
     * Ends all currently nested groups (if any), restoring values before the
     * groups began.  Useful in case of an error in the middle of parsing.
     */
    endGroups() {
      this.macros.endGroups();
    }
    /**
     * Returns the topmost token on the stack, without expanding it.
     * Similar in behavior to TeX's `\futurelet`.
     */
    future() {
      if (this.stack.length === 0) {
        this.pushToken(this.lexer.lex());
      }
      return this.stack[this.stack.length - 1];
    }
    /**
     * Remove and return the next unexpanded token.
     */
    popToken() {
      this.future();
      return this.stack.pop();
    }
    /**
     * Add a given token to the token stack.  In particular, this get be used
     * to put back a token returned from one of the other methods.
     */
    pushToken(token) {
      this.stack.push(token);
    }
    /**
     * Append an array of tokens to the token stack.
     */
    pushTokens(tokens) {
      this.stack.push(...tokens);
    }
    /**
     * Find an macro argument without expanding tokens and append the array of
     * tokens to the token stack. Uses Token as a container for the result.
     */
    scanArgument(isOptional) {
      var start;
      var end;
      var tokens;
      if (isOptional) {
        this.consumeSpaces();
        if (this.future().text !== "[") {
          return null;
        }
        start = this.popToken();
        ({
          tokens,
          end
        } = this.consumeArg(["]"]));
      } else {
        ({
          tokens,
          start,
          end
        } = this.consumeArg());
      }
      this.pushToken(new Token("EOF", end.loc));
      this.pushTokens(tokens);
      return start.range(end, "");
    }
    /**
     * Consume all following space tokens, without expansion.
     */
    consumeSpaces() {
      for (; ; ) {
        var token = this.future();
        if (token.text === " ") {
          this.stack.pop();
        } else {
          break;
        }
      }
    }
    /**
     * Consume an argument from the token stream, and return the resulting array
     * of tokens and start/end token.
     */
    consumeArg(delims) {
      var tokens = [];
      var isDelimited = delims && delims.length > 0;
      if (!isDelimited) {
        this.consumeSpaces();
      }
      var start = this.future();
      var tok;
      var depth = 0;
      var match = 0;
      do {
        tok = this.popToken();
        tokens.push(tok);
        if (tok.text === "{") {
          ++depth;
        } else if (tok.text === "}") {
          --depth;
          if (depth === -1) {
            throw new ParseError("Extra }", tok);
          }
        } else if (tok.text === "EOF") {
          throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
        }
        if (delims && isDelimited) {
          if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
            ++match;
            if (match === delims.length) {
              tokens.splice(-match, match);
              break;
            }
          } else {
            match = 0;
          }
        }
      } while (depth !== 0 || isDelimited);
      if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
        tokens.pop();
        tokens.shift();
      }
      tokens.reverse();
      return {
        tokens,
        start,
        end: tok
      };
    }
    /**
     * Consume the specified number of (delimited) arguments from the token
     * stream and return the resulting array of arguments.
     */
    consumeArgs(numArgs, delimiters2) {
      if (delimiters2) {
        if (delimiters2.length !== numArgs + 1) {
          throw new ParseError("The length of delimiters doesn't match the number of args!");
        }
        var delims = delimiters2[0];
        for (var i4 = 0; i4 < delims.length; i4++) {
          var tok = this.popToken();
          if (delims[i4] !== tok.text) {
            throw new ParseError("Use of the macro doesn't match its definition", tok);
          }
        }
      }
      var args = [];
      for (var _i = 0; _i < numArgs; _i++) {
        args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
      }
      return args;
    }
    /**
     * Increment `expansionCount` by the specified amount.
     * Throw an error if it exceeds `maxExpand`.
     */
    countExpansion(amount) {
      this.expansionCount += amount;
      if (this.expansionCount > this.settings.maxExpand) {
        throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
      }
    }
    /**
     * Expand the next token only once if possible.
     *
     * If the token is expanded, the resulting tokens will be pushed onto
     * the stack in reverse order, and the number of such tokens will be
     * returned.  This number might be zero or positive.
     *
     * If not, the return value is `false`, and the next token remains at the
     * top of the stack.
     *
     * In either case, the next token will be on the top of the stack,
     * or the stack will be empty (in case of empty expansion
     * and no other tokens).
     *
     * Used to implement `expandAfterFuture` and `expandNextToken`.
     *
     * If expandableOnly, only expandable tokens are expanded and
     * an undefined control sequence results in an error.
     */
    expandOnce(expandableOnly) {
      var topToken = this.popToken();
      var name = topToken.text;
      var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
      if (expansion == null || expandableOnly && expansion.unexpandable) {
        if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
          throw new ParseError("Undefined control sequence: " + name);
        }
        this.pushToken(topToken);
        return false;
      }
      this.countExpansion(1);
      var tokens = expansion.tokens;
      var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
      if (expansion.numArgs) {
        tokens = tokens.slice();
        for (var i4 = tokens.length - 1; i4 >= 0; --i4) {
          var tok = tokens[i4];
          if (tok.text === "#") {
            if (i4 === 0) {
              throw new ParseError("Incomplete placeholder at end of macro body", tok);
            }
            tok = tokens[--i4];
            if (tok.text === "#") {
              tokens.splice(i4 + 1, 1);
            } else if (/^[1-9]$/.test(tok.text)) {
              tokens.splice(i4, 2, ...args[+tok.text - 1]);
            } else {
              throw new ParseError("Not a valid argument number", tok);
            }
          }
        }
      }
      this.pushTokens(tokens);
      return tokens.length;
    }
    /**
     * Expand the next token only once (if possible), and return the resulting
     * top token on the stack (without removing anything from the stack).
     * Similar in behavior to TeX's `\expandafter\futurelet`.
     * Equivalent to expandOnce() followed by future().
     */
    expandAfterFuture() {
      this.expandOnce();
      return this.future();
    }
    /**
     * Recursively expand first token, then return first non-expandable token.
     */
    expandNextToken() {
      for (; ; ) {
        if (this.expandOnce() === false) {
          var token = this.stack.pop();
          if (token.treatAsRelax) {
            token.text = "\\relax";
          }
          return token;
        }
      }
      throw new Error();
    }
    /**
     * Fully expand the given macro name and return the resulting list of
     * tokens, or return `undefined` if no such macro is defined.
     */
    expandMacro(name) {
      return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
    }
    /**
     * Fully expand the given token stream and return the resulting list of
     * tokens.  Note that the input tokens are in reverse order, but the
     * output tokens are in forward order.
     */
    expandTokens(tokens) {
      var output = [];
      var oldStackLength = this.stack.length;
      this.pushTokens(tokens);
      while (this.stack.length > oldStackLength) {
        if (this.expandOnce(true) === false) {
          var token = this.stack.pop();
          if (token.treatAsRelax) {
            token.noexpand = false;
            token.treatAsRelax = false;
          }
          output.push(token);
        }
      }
      this.countExpansion(output.length);
      return output;
    }
    /**
     * Fully expand the given macro name and return the result as a string,
     * or return `undefined` if no such macro is defined.
     */
    expandMacroAsText(name) {
      var tokens = this.expandMacro(name);
      if (tokens) {
        return tokens.map((token) => token.text).join("");
      } else {
        return tokens;
      }
    }
    /**
     * Returns the expanded macro as a reversed array of tokens and a macro
     * argument count.  Or returns `null` if no such macro.
     */
    _getExpansion(name) {
      var definition = this.macros.get(name);
      if (definition == null) {
        return definition;
      }
      if (name.length === 1) {
        var catcode = this.lexer.catcodes[name];
        if (catcode != null && catcode !== 13) {
          return;
        }
      }
      var expansion = typeof definition === "function" ? definition(this) : definition;
      if (typeof expansion === "string") {
        var numArgs = 0;
        if (expansion.indexOf("#") !== -1) {
          var stripped = expansion.replace(/##/g, "");
          while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
            ++numArgs;
          }
        }
        var bodyLexer = new Lexer(expansion, this.settings);
        var tokens = [];
        var tok = bodyLexer.lex();
        while (tok.text !== "EOF") {
          tokens.push(tok);
          tok = bodyLexer.lex();
        }
        tokens.reverse();
        var expanded = {
          tokens,
          numArgs
        };
        return expanded;
      }
      return expansion;
    }
    /**
     * Determine whether a command is currently "defined" (has some
     * functionality), meaning that it's a macro (in the current group),
     * a function, a symbol, or one of the special commands listed in
     * `implicitCommands`.
     */
    isDefined(name) {
      return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
    }
    /**
     * Determine whether a command is expandable.
     */
    isExpandable(name) {
      var macro = this.macros.get(name);
      return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
    }
  };
  var unicodeSubRegEx = /^[]/;
  var uSubsAndSups = Object.freeze({
    "\u208A": "+",
    "\u208B": "-",
    "\u208C": "=",
    "\u208D": "(",
    "\u208E": ")",
    "\u2080": "0",
    "\u2081": "1",
    "\u2082": "2",
    "\u2083": "3",
    "\u2084": "4",
    "\u2085": "5",
    "\u2086": "6",
    "\u2087": "7",
    "\u2088": "8",
    "\u2089": "9",
    "\u2090": "a",
    "\u2091": "e",
    "\u2095": "h",
    "\u1D62": "i",
    "\u2C7C": "j",
    "\u2096": "k",
    "\u2097": "l",
    "\u2098": "m",
    "\u2099": "n",
    "\u2092": "o",
    "\u209A": "p",
    "\u1D63": "r",
    "\u209B": "s",
    "\u209C": "t",
    "\u1D64": "u",
    "\u1D65": "v",
    "\u2093": "x",
    "\u1D66": "\u03B2",
    "\u1D67": "\u03B3",
    "\u1D68": "\u03C1",
    "\u1D69": "\u03D5",
    "\u1D6A": "\u03C7",
    "\u207A": "+",
    "\u207B": "-",
    "\u207C": "=",
    "\u207D": "(",
    "\u207E": ")",
    "\u2070": "0",
    "\xB9": "1",
    "\xB2": "2",
    "\xB3": "3",
    "\u2074": "4",
    "\u2075": "5",
    "\u2076": "6",
    "\u2077": "7",
    "\u2078": "8",
    "\u2079": "9",
    "\u1D2C": "A",
    "\u1D2E": "B",
    "\u1D30": "D",
    "\u1D31": "E",
    "\u1D33": "G",
    "\u1D34": "H",
    "\u1D35": "I",
    "\u1D36": "J",
    "\u1D37": "K",
    "\u1D38": "L",
    "\u1D39": "M",
    "\u1D3A": "N",
    "\u1D3C": "O",
    "\u1D3E": "P",
    "\u1D3F": "R",
    "\u1D40": "T",
    "\u1D41": "U",
    "\u2C7D": "V",
    "\u1D42": "W",
    "\u1D43": "a",
    "\u1D47": "b",
    "\u1D9C": "c",
    "\u1D48": "d",
    "\u1D49": "e",
    "\u1DA0": "f",
    "\u1D4D": "g",
    "\u02B0": "h",
    "\u2071": "i",
    "\u02B2": "j",
    "\u1D4F": "k",
    "\u02E1": "l",
    "\u1D50": "m",
    "\u207F": "n",
    "\u1D52": "o",
    "\u1D56": "p",
    "\u02B3": "r",
    "\u02E2": "s",
    "\u1D57": "t",
    "\u1D58": "u",
    "\u1D5B": "v",
    "\u02B7": "w",
    "\u02E3": "x",
    "\u02B8": "y",
    "\u1DBB": "z",
    "\u1D5D": "\u03B2",
    "\u1D5E": "\u03B3",
    "\u1D5F": "\u03B4",
    "\u1D60": "\u03D5",
    "\u1D61": "\u03C7",
    "\u1DBF": "\u03B8"
  });
  var unicodeAccents = {
    "\u0301": {
      "text": "\\'",
      "math": "\\acute"
    },
    "\u0300": {
      "text": "\\`",
      "math": "\\grave"
    },
    "\u0308": {
      "text": '\\"',
      "math": "\\ddot"
    },
    "\u0303": {
      "text": "\\~",
      "math": "\\tilde"
    },
    "\u0304": {
      "text": "\\=",
      "math": "\\bar"
    },
    "\u0306": {
      "text": "\\u",
      "math": "\\breve"
    },
    "\u030C": {
      "text": "\\v",
      "math": "\\check"
    },
    "\u0302": {
      "text": "\\^",
      "math": "\\hat"
    },
    "\u0307": {
      "text": "\\.",
      "math": "\\dot"
    },
    "\u030A": {
      "text": "\\r",
      "math": "\\mathring"
    },
    "\u030B": {
      "text": "\\H"
    },
    "\u0327": {
      "text": "\\c"
    }
  };
  var unicodeSymbols = {
    "\xE1": "a\u0301",
    "\xE0": "a\u0300",
    "\xE4": "a\u0308",
    "\u01DF": "a\u0308\u0304",
    "\xE3": "a\u0303",
    "\u0101": "a\u0304",
    "\u0103": "a\u0306",
    "\u1EAF": "a\u0306\u0301",
    "\u1EB1": "a\u0306\u0300",
    "\u1EB5": "a\u0306\u0303",
    "\u01CE": "a\u030C",
    "\xE2": "a\u0302",
    "\u1EA5": "a\u0302\u0301",
    "\u1EA7": "a\u0302\u0300",
    "\u1EAB": "a\u0302\u0303",
    "\u0227": "a\u0307",
    "\u01E1": "a\u0307\u0304",
    "\xE5": "a\u030A",
    "\u01FB": "a\u030A\u0301",
    "\u1E03": "b\u0307",
    "\u0107": "c\u0301",
    "\u1E09": "c\u0327\u0301",
    "\u010D": "c\u030C",
    "\u0109": "c\u0302",
    "\u010B": "c\u0307",
    "\xE7": "c\u0327",
    "\u010F": "d\u030C",
    "\u1E0B": "d\u0307",
    "\u1E11": "d\u0327",
    "\xE9": "e\u0301",
    "\xE8": "e\u0300",
    "\xEB": "e\u0308",
    "\u1EBD": "e\u0303",
    "\u0113": "e\u0304",
    "\u1E17": "e\u0304\u0301",
    "\u1E15": "e\u0304\u0300",
    "\u0115": "e\u0306",
    "\u1E1D": "e\u0327\u0306",
    "\u011B": "e\u030C",
    "\xEA": "e\u0302",
    "\u1EBF": "e\u0302\u0301",
    "\u1EC1": "e\u0302\u0300",
    "\u1EC5": "e\u0302\u0303",
    "\u0117": "e\u0307",
    "\u0229": "e\u0327",
    "\u1E1F": "f\u0307",
    "\u01F5": "g\u0301",
    "\u1E21": "g\u0304",
    "\u011F": "g\u0306",
    "\u01E7": "g\u030C",
    "\u011D": "g\u0302",
    "\u0121": "g\u0307",
    "\u0123": "g\u0327",
    "\u1E27": "h\u0308",
    "\u021F": "h\u030C",
    "\u0125": "h\u0302",
    "\u1E23": "h\u0307",
    "\u1E29": "h\u0327",
    "\xED": "i\u0301",
    "\xEC": "i\u0300",
    "\xEF": "i\u0308",
    "\u1E2F": "i\u0308\u0301",
    "\u0129": "i\u0303",
    "\u012B": "i\u0304",
    "\u012D": "i\u0306",
    "\u01D0": "i\u030C",
    "\xEE": "i\u0302",
    "\u01F0": "j\u030C",
    "\u0135": "j\u0302",
    "\u1E31": "k\u0301",
    "\u01E9": "k\u030C",
    "\u0137": "k\u0327",
    "\u013A": "l\u0301",
    "\u013E": "l\u030C",
    "\u013C": "l\u0327",
    "\u1E3F": "m\u0301",
    "\u1E41": "m\u0307",
    "\u0144": "n\u0301",
    "\u01F9": "n\u0300",
    "\xF1": "n\u0303",
    "\u0148": "n\u030C",
    "\u1E45": "n\u0307",
    "\u0146": "n\u0327",
    "\xF3": "o\u0301",
    "\xF2": "o\u0300",
    "\xF6": "o\u0308",
    "\u022B": "o\u0308\u0304",
    "\xF5": "o\u0303",
    "\u1E4D": "o\u0303\u0301",
    "\u1E4F": "o\u0303\u0308",
    "\u022D": "o\u0303\u0304",
    "\u014D": "o\u0304",
    "\u1E53": "o\u0304\u0301",
    "\u1E51": "o\u0304\u0300",
    "\u014F": "o\u0306",
    "\u01D2": "o\u030C",
    "\xF4": "o\u0302",
    "\u1ED1": "o\u0302\u0301",
    "\u1ED3": "o\u0302\u0300",
    "\u1ED7": "o\u0302\u0303",
    "\u022F": "o\u0307",
    "\u0231": "o\u0307\u0304",
    "\u0151": "o\u030B",
    "\u1E55": "p\u0301",
    "\u1E57": "p\u0307",
    "\u0155": "r\u0301",
    "\u0159": "r\u030C",
    "\u1E59": "r\u0307",
    "\u0157": "r\u0327",
    "\u015B": "s\u0301",
    "\u1E65": "s\u0301\u0307",
    "\u0161": "s\u030C",
    "\u1E67": "s\u030C\u0307",
    "\u015D": "s\u0302",
    "\u1E61": "s\u0307",
    "\u015F": "s\u0327",
    "\u1E97": "t\u0308",
    "\u0165": "t\u030C",
    "\u1E6B": "t\u0307",
    "\u0163": "t\u0327",
    "\xFA": "u\u0301",
    "\xF9": "u\u0300",
    "\xFC": "u\u0308",
    "\u01D8": "u\u0308\u0301",
    "\u01DC": "u\u0308\u0300",
    "\u01D6": "u\u0308\u0304",
    "\u01DA": "u\u0308\u030C",
    "\u0169": "u\u0303",
    "\u1E79": "u\u0303\u0301",
    "\u016B": "u\u0304",
    "\u1E7B": "u\u0304\u0308",
    "\u016D": "u\u0306",
    "\u01D4": "u\u030C",
    "\xFB": "u\u0302",
    "\u016F": "u\u030A",
    "\u0171": "u\u030B",
    "\u1E7D": "v\u0303",
    "\u1E83": "w\u0301",
    "\u1E81": "w\u0300",
    "\u1E85": "w\u0308",
    "\u0175": "w\u0302",
    "\u1E87": "w\u0307",
    "\u1E98": "w\u030A",
    "\u1E8D": "x\u0308",
    "\u1E8B": "x\u0307",
    "\xFD": "y\u0301",
    "\u1EF3": "y\u0300",
    "\xFF": "y\u0308",
    "\u1EF9": "y\u0303",
    "\u0233": "y\u0304",
    "\u0177": "y\u0302",
    "\u1E8F": "y\u0307",
    "\u1E99": "y\u030A",
    "\u017A": "z\u0301",
    "\u017E": "z\u030C",
    "\u1E91": "z\u0302",
    "\u017C": "z\u0307",
    "\xC1": "A\u0301",
    "\xC0": "A\u0300",
    "\xC4": "A\u0308",
    "\u01DE": "A\u0308\u0304",
    "\xC3": "A\u0303",
    "\u0100": "A\u0304",
    "\u0102": "A\u0306",
    "\u1EAE": "A\u0306\u0301",
    "\u1EB0": "A\u0306\u0300",
    "\u1EB4": "A\u0306\u0303",
    "\u01CD": "A\u030C",
    "\xC2": "A\u0302",
    "\u1EA4": "A\u0302\u0301",
    "\u1EA6": "A\u0302\u0300",
    "\u1EAA": "A\u0302\u0303",
    "\u0226": "A\u0307",
    "\u01E0": "A\u0307\u0304",
    "\xC5": "A\u030A",
    "\u01FA": "A\u030A\u0301",
    "\u1E02": "B\u0307",
    "\u0106": "C\u0301",
    "\u1E08": "C\u0327\u0301",
    "\u010C": "C\u030C",
    "\u0108": "C\u0302",
    "\u010A": "C\u0307",
    "\xC7": "C\u0327",
    "\u010E": "D\u030C",
    "\u1E0A": "D\u0307",
    "\u1E10": "D\u0327",
    "\xC9": "E\u0301",
    "\xC8": "E\u0300",
    "\xCB": "E\u0308",
    "\u1EBC": "E\u0303",
    "\u0112": "E\u0304",
    "\u1E16": "E\u0304\u0301",
    "\u1E14": "E\u0304\u0300",
    "\u0114": "E\u0306",
    "\u1E1C": "E\u0327\u0306",
    "\u011A": "E\u030C",
    "\xCA": "E\u0302",
    "\u1EBE": "E\u0302\u0301",
    "\u1EC0": "E\u0302\u0300",
    "\u1EC4": "E\u0302\u0303",
    "\u0116": "E\u0307",
    "\u0228": "E\u0327",
    "\u1E1E": "F\u0307",
    "\u01F4": "G\u0301",
    "\u1E20": "G\u0304",
    "\u011E": "G\u0306",
    "\u01E6": "G\u030C",
    "\u011C": "G\u0302",
    "\u0120": "G\u0307",
    "\u0122": "G\u0327",
    "\u1E26": "H\u0308",
    "\u021E": "H\u030C",
    "\u0124": "H\u0302",
    "\u1E22": "H\u0307",
    "\u1E28": "H\u0327",
    "\xCD": "I\u0301",
    "\xCC": "I\u0300",
    "\xCF": "I\u0308",
    "\u1E2E": "I\u0308\u0301",
    "\u0128": "I\u0303",
    "\u012A": "I\u0304",
    "\u012C": "I\u0306",
    "\u01CF": "I\u030C",
    "\xCE": "I\u0302",
    "\u0130": "I\u0307",
    "\u0134": "J\u0302",
    "\u1E30": "K\u0301",
    "\u01E8": "K\u030C",
    "\u0136": "K\u0327",
    "\u0139": "L\u0301",
    "\u013D": "L\u030C",
    "\u013B": "L\u0327",
    "\u1E3E": "M\u0301",
    "\u1E40": "M\u0307",
    "\u0143": "N\u0301",
    "\u01F8": "N\u0300",
    "\xD1": "N\u0303",
    "\u0147": "N\u030C",
    "\u1E44": "N\u0307",
    "\u0145": "N\u0327",
    "\xD3": "O\u0301",
    "\xD2": "O\u0300",
    "\xD6": "O\u0308",
    "\u022A": "O\u0308\u0304",
    "\xD5": "O\u0303",
    "\u1E4C": "O\u0303\u0301",
    "\u1E4E": "O\u0303\u0308",
    "\u022C": "O\u0303\u0304",
    "\u014C": "O\u0304",
    "\u1E52": "O\u0304\u0301",
    "\u1E50": "O\u0304\u0300",
    "\u014E": "O\u0306",
    "\u01D1": "O\u030C",
    "\xD4": "O\u0302",
    "\u1ED0": "O\u0302\u0301",
    "\u1ED2": "O\u0302\u0300",
    "\u1ED6": "O\u0302\u0303",
    "\u022E": "O\u0307",
    "\u0230": "O\u0307\u0304",
    "\u0150": "O\u030B",
    "\u1E54": "P\u0301",
    "\u1E56": "P\u0307",
    "\u0154": "R\u0301",
    "\u0158": "R\u030C",
    "\u1E58": "R\u0307",
    "\u0156": "R\u0327",
    "\u015A": "S\u0301",
    "\u1E64": "S\u0301\u0307",
    "\u0160": "S\u030C",
    "\u1E66": "S\u030C\u0307",
    "\u015C": "S\u0302",
    "\u1E60": "S\u0307",
    "\u015E": "S\u0327",
    "\u0164": "T\u030C",
    "\u1E6A": "T\u0307",
    "\u0162": "T\u0327",
    "\xDA": "U\u0301",
    "\xD9": "U\u0300",
    "\xDC": "U\u0308",
    "\u01D7": "U\u0308\u0301",
    "\u01DB": "U\u0308\u0300",
    "\u01D5": "U\u0308\u0304",
    "\u01D9": "U\u0308\u030C",
    "\u0168": "U\u0303",
    "\u1E78": "U\u0303\u0301",
    "\u016A": "U\u0304",
    "\u1E7A": "U\u0304\u0308",
    "\u016C": "U\u0306",
    "\u01D3": "U\u030C",
    "\xDB": "U\u0302",
    "\u016E": "U\u030A",
    "\u0170": "U\u030B",
    "\u1E7C": "V\u0303",
    "\u1E82": "W\u0301",
    "\u1E80": "W\u0300",
    "\u1E84": "W\u0308",
    "\u0174": "W\u0302",
    "\u1E86": "W\u0307",
    "\u1E8C": "X\u0308",
    "\u1E8A": "X\u0307",
    "\xDD": "Y\u0301",
    "\u1EF2": "Y\u0300",
    "\u0178": "Y\u0308",
    "\u1EF8": "Y\u0303",
    "\u0232": "Y\u0304",
    "\u0176": "Y\u0302",
    "\u1E8E": "Y\u0307",
    "\u0179": "Z\u0301",
    "\u017D": "Z\u030C",
    "\u1E90": "Z\u0302",
    "\u017B": "Z\u0307",
    "\u03AC": "\u03B1\u0301",
    "\u1F70": "\u03B1\u0300",
    "\u1FB1": "\u03B1\u0304",
    "\u1FB0": "\u03B1\u0306",
    "\u03AD": "\u03B5\u0301",
    "\u1F72": "\u03B5\u0300",
    "\u03AE": "\u03B7\u0301",
    "\u1F74": "\u03B7\u0300",
    "\u03AF": "\u03B9\u0301",
    "\u1F76": "\u03B9\u0300",
    "\u03CA": "\u03B9\u0308",
    "\u0390": "\u03B9\u0308\u0301",
    "\u1FD2": "\u03B9\u0308\u0300",
    "\u1FD1": "\u03B9\u0304",
    "\u1FD0": "\u03B9\u0306",
    "\u03CC": "\u03BF\u0301",
    "\u1F78": "\u03BF\u0300",
    "\u03CD": "\u03C5\u0301",
    "\u1F7A": "\u03C5\u0300",
    "\u03CB": "\u03C5\u0308",
    "\u03B0": "\u03C5\u0308\u0301",
    "\u1FE2": "\u03C5\u0308\u0300",
    "\u1FE1": "\u03C5\u0304",
    "\u1FE0": "\u03C5\u0306",
    "\u03CE": "\u03C9\u0301",
    "\u1F7C": "\u03C9\u0300",
    "\u038E": "\u03A5\u0301",
    "\u1FEA": "\u03A5\u0300",
    "\u03AB": "\u03A5\u0308",
    "\u1FE9": "\u03A5\u0304",
    "\u1FE8": "\u03A5\u0306",
    "\u038F": "\u03A9\u0301",
    "\u1FFA": "\u03A9\u0300"
  };
  var Parser = class _Parser {
    constructor(input, settings) {
      this.mode = void 0;
      this.gullet = void 0;
      this.settings = void 0;
      this.leftrightDepth = void 0;
      this.nextToken = void 0;
      this.mode = "math";
      this.gullet = new MacroExpander(input, settings, this.mode);
      this.settings = settings;
      this.leftrightDepth = 0;
    }
    /**
     * Checks a result to make sure it has the right type, and throws an
     * appropriate error otherwise.
     */
    expect(text2, consume) {
      if (consume === void 0) {
        consume = true;
      }
      if (this.fetch().text !== text2) {
        throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
      }
      if (consume) {
        this.consume();
      }
    }
    /**
     * Discards the current lookahead token, considering it consumed.
     */
    consume() {
      this.nextToken = null;
    }
    /**
     * Return the current lookahead token, or if there isn't one (at the
     * beginning, or if the previous lookahead token was consume()d),
     * fetch the next token as the new lookahead token and return it.
     */
    fetch() {
      if (this.nextToken == null) {
        this.nextToken = this.gullet.expandNextToken();
      }
      return this.nextToken;
    }
    /**
     * Switches between "text" and "math" modes.
     */
    switchMode(newMode) {
      this.mode = newMode;
      this.gullet.switchMode(newMode);
    }
    /**
     * Main parsing function, which parses an entire input.
     */
    parse() {
      if (!this.settings.globalGroup) {
        this.gullet.beginGroup();
      }
      if (this.settings.colorIsTextColor) {
        this.gullet.macros.set("\\color", "\\textcolor");
      }
      try {
        var parse = this.parseExpression(false);
        this.expect("EOF");
        if (!this.settings.globalGroup) {
          this.gullet.endGroup();
        }
        return parse;
      } finally {
        this.gullet.endGroups();
      }
    }
    /**
     * Fully parse a separate sequence of tokens as a separate job.
     * Tokens should be specified in reverse order, as in a MacroDefinition.
     */
    subparse(tokens) {
      var oldToken = this.nextToken;
      this.consume();
      this.gullet.pushToken(new Token("}"));
      this.gullet.pushTokens(tokens);
      var parse = this.parseExpression(false);
      this.expect("}");
      this.nextToken = oldToken;
      return parse;
    }
    /**
     * Parses an "expression", which is a list of atoms.
     *
     * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
     *                 happens when functions have higher precedence han infix
     *                 nodes in implicit parses.
     *
     * `breakOnTokenText`: The text of the token that the expression should end
     *                     with, or `null` if something else should end the
     *                     expression.
     */
    parseExpression(breakOnInfix, breakOnTokenText) {
      var body = [];
      while (true) {
        if (this.mode === "math") {
          this.consumeSpaces();
        }
        var lex = this.fetch();
        if (_Parser.endOfExpression.indexOf(lex.text) !== -1) {
          break;
        }
        if (breakOnTokenText && lex.text === breakOnTokenText) {
          break;
        }
        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
          break;
        }
        var atom = this.parseAtom(breakOnTokenText);
        if (!atom) {
          break;
        } else if (atom.type === "internal") {
          continue;
        }
        body.push(atom);
      }
      if (this.mode === "text") {
        this.formLigatures(body);
      }
      return this.handleInfixNodes(body);
    }
    /**
     * Rewrites infix operators such as \over with corresponding commands such
     * as \frac.
     *
     * There can only be one infix operator per group.  If there's more than one
     * then the expression is ambiguous.  This can be resolved by adding {}.
     */
    handleInfixNodes(body) {
      var overIndex = -1;
      var funcName;
      for (var i4 = 0; i4 < body.length; i4++) {
        if (body[i4].type === "infix") {
          if (overIndex !== -1) {
            throw new ParseError("only one infix operator per group", body[i4].token);
          }
          overIndex = i4;
          funcName = body[i4].replaceWith;
        }
      }
      if (overIndex !== -1 && funcName) {
        var numerNode;
        var denomNode;
        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);
        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
          numerNode = numerBody[0];
        } else {
          numerNode = {
            type: "ordgroup",
            mode: this.mode,
            body: numerBody
          };
        }
        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
          denomNode = denomBody[0];
        } else {
          denomNode = {
            type: "ordgroup",
            mode: this.mode,
            body: denomBody
          };
        }
        var node;
        if (funcName === "\\\\abovefrac") {
          node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
        } else {
          node = this.callFunction(funcName, [numerNode, denomNode], []);
        }
        return [node];
      } else {
        return body;
      }
    }
    /**
     * Handle a subscript or superscript with nice errors.
     */
    handleSupSubscript(name) {
      var symbolToken = this.fetch();
      var symbol = symbolToken.text;
      this.consume();
      this.consumeSpaces();
      var group;
      do {
        var _group;
        group = this.parseGroup(name);
      } while (((_group = group) == null ? void 0 : _group.type) === "internal");
      if (!group) {
        throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
      }
      return group;
    }
    /**
     * Converts the textual input of an unsupported command into a text node
     * contained within a color node whose color is determined by errorColor
     */
    formatUnsupportedCmd(text2) {
      var textordArray = [];
      for (var i4 = 0; i4 < text2.length; i4++) {
        textordArray.push({
          type: "textord",
          mode: "text",
          text: text2[i4]
        });
      }
      var textNode = {
        type: "text",
        mode: this.mode,
        body: textordArray
      };
      var colorNode = {
        type: "color",
        mode: this.mode,
        color: this.settings.errorColor,
        body: [textNode]
      };
      return colorNode;
    }
    /**
     * Parses a group with optional super/subscripts.
     */
    parseAtom(breakOnTokenText) {
      var base = this.parseGroup("atom", breakOnTokenText);
      if ((base == null ? void 0 : base.type) === "internal") {
        return base;
      }
      if (this.mode === "text") {
        return base;
      }
      var superscript;
      var subscript;
      while (true) {
        this.consumeSpaces();
        var lex = this.fetch();
        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
          if (base && base.type === "op") {
            var limits = lex.text === "\\limits";
            base.limits = limits;
            base.alwaysHandleSupSub = true;
          } else if (base && base.type === "operatorname") {
            if (base.alwaysHandleSupSub) {
              base.limits = lex.text === "\\limits";
            }
          } else {
            throw new ParseError("Limit controls must follow a math operator", lex);
          }
          this.consume();
        } else if (lex.text === "^") {
          if (superscript) {
            throw new ParseError("Double superscript", lex);
          }
          superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
          if (subscript) {
            throw new ParseError("Double subscript", lex);
          }
          subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
          if (superscript) {
            throw new ParseError("Double superscript", lex);
          }
          var prime = {
            type: "textord",
            mode: this.mode,
            text: "\\prime"
          };
          var primes = [prime];
          this.consume();
          while (this.fetch().text === "'") {
            primes.push(prime);
            this.consume();
          }
          if (this.fetch().text === "^") {
            primes.push(this.handleSupSubscript("superscript"));
          }
          superscript = {
            type: "ordgroup",
            mode: this.mode,
            body: primes
          };
        } else if (uSubsAndSups[lex.text]) {
          var isSub = unicodeSubRegEx.test(lex.text);
          var subsupTokens = [];
          subsupTokens.push(new Token(uSubsAndSups[lex.text]));
          this.consume();
          while (true) {
            var token = this.fetch().text;
            if (!uSubsAndSups[token]) {
              break;
            }
            if (unicodeSubRegEx.test(token) !== isSub) {
              break;
            }
            subsupTokens.unshift(new Token(uSubsAndSups[token]));
            this.consume();
          }
          var body = this.subparse(subsupTokens);
          if (isSub) {
            subscript = {
              type: "ordgroup",
              mode: "math",
              body
            };
          } else {
            superscript = {
              type: "ordgroup",
              mode: "math",
              body
            };
          }
        } else {
          break;
        }
      }
      if (superscript || subscript) {
        return {
          type: "supsub",
          mode: this.mode,
          base,
          sup: superscript,
          sub: subscript
        };
      } else {
        return base;
      }
    }
    /**
     * Parses an entire function, including its base and all of its arguments.
     */
    parseFunction(breakOnTokenText, name) {
      var token = this.fetch();
      var func = token.text;
      var funcData = functions[func];
      if (!funcData) {
        return null;
      }
      this.consume();
      if (name && name !== "atom" && !funcData.allowedInArgument) {
        throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
      } else if (this.mode === "text" && !funcData.allowedInText) {
        throw new ParseError("Can't use function '" + func + "' in text mode", token);
      } else if (this.mode === "math" && funcData.allowedInMath === false) {
        throw new ParseError("Can't use function '" + func + "' in math mode", token);
      }
      var {
        args,
        optArgs
      } = this.parseArguments(func, funcData);
      return this.callFunction(func, args, optArgs, token, breakOnTokenText);
    }
    /**
     * Call a function handler with a suitable context and arguments.
     */
    callFunction(name, args, optArgs, token, breakOnTokenText) {
      var context = {
        funcName: name,
        parser: this,
        token,
        breakOnTokenText
      };
      var func = functions[name];
      if (func && func.handler) {
        return func.handler(context, args, optArgs);
      } else {
        throw new ParseError("No function handler for " + name);
      }
    }
    /**
     * Parses the arguments of a function or environment
     */
    parseArguments(func, funcData) {
      var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
      if (totalArgs === 0) {
        return {
          args: [],
          optArgs: []
        };
      }
      var args = [];
      var optArgs = [];
      for (var i4 = 0; i4 < totalArgs; i4++) {
        var argType = funcData.argTypes && funcData.argTypes[i4];
        var isOptional = i4 < funcData.numOptionalArgs;
        if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
        funcData.type === "sqrt" && i4 === 1 && optArgs[0] == null) {
          argType = "primitive";
        }
        var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
        if (isOptional) {
          optArgs.push(arg);
        } else if (arg != null) {
          args.push(arg);
        } else {
          throw new ParseError("Null argument, please report this as a bug");
        }
      }
      return {
        args,
        optArgs
      };
    }
    /**
     * Parses a group when the mode is changing.
     */
    parseGroupOfType(name, type, optional) {
      switch (type) {
        case "color":
          return this.parseColorGroup(optional);
        case "size":
          return this.parseSizeGroup(optional);
        case "url":
          return this.parseUrlGroup(optional);
        case "math":
        case "text":
          return this.parseArgumentGroup(optional, type);
        case "hbox": {
          var group = this.parseArgumentGroup(optional, "text");
          return group != null ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            style: "text"
            // simulate \textstyle
          } : null;
        }
        case "raw": {
          var token = this.parseStringGroup("raw", optional);
          return token != null ? {
            type: "raw",
            mode: "text",
            string: token.text
          } : null;
        }
        case "primitive": {
          if (optional) {
            throw new ParseError("A primitive argument cannot be optional");
          }
          var _group2 = this.parseGroup(name);
          if (_group2 == null) {
            throw new ParseError("Expected group as " + name, this.fetch());
          }
          return _group2;
        }
        case "original":
        case null:
        case void 0:
          return this.parseArgumentGroup(optional);
        default:
          throw new ParseError("Unknown group type as " + name, this.fetch());
      }
    }
    /**
     * Discard any space tokens, fetching the next non-space token.
     */
    consumeSpaces() {
      while (this.fetch().text === " ") {
        this.consume();
      }
    }
    /**
     * Parses a group, essentially returning the string formed by the
     * brace-enclosed tokens plus some position information.
     */
    parseStringGroup(modeName, optional) {
      var argToken = this.gullet.scanArgument(optional);
      if (argToken == null) {
        return null;
      }
      var str = "";
      var nextToken;
      while ((nextToken = this.fetch()).text !== "EOF") {
        str += nextToken.text;
        this.consume();
      }
      this.consume();
      argToken.text = str;
      return argToken;
    }
    /**
     * Parses a regex-delimited group: the largest sequence of tokens
     * whose concatenated strings match `regex`. Returns the string
     * formed by the tokens plus some position information.
     */
    parseRegexGroup(regex, modeName) {
      var firstToken = this.fetch();
      var lastToken = firstToken;
      var str = "";
      var nextToken;
      while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
        lastToken = nextToken;
        str += lastToken.text;
        this.consume();
      }
      if (str === "") {
        throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
      }
      return firstToken.range(lastToken, str);
    }
    /**
     * Parses a color description.
     */
    parseColorGroup(optional) {
      var res = this.parseStringGroup("color", optional);
      if (res == null) {
        return null;
      }
      var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
      if (!match) {
        throw new ParseError("Invalid color: '" + res.text + "'", res);
      }
      var color = match[0];
      if (/^[0-9a-f]{6}$/i.test(color)) {
        color = "#" + color;
      }
      return {
        type: "color-token",
        mode: this.mode,
        color
      };
    }
    /**
     * Parses a size specification, consisting of magnitude and unit.
     */
    parseSizeGroup(optional) {
      var res;
      var isBlank = false;
      this.gullet.consumeSpaces();
      if (!optional && this.gullet.future().text !== "{") {
        res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
      } else {
        res = this.parseStringGroup("size", optional);
      }
      if (!res) {
        return null;
      }
      if (!optional && res.text.length === 0) {
        res.text = "0pt";
        isBlank = true;
      }
      var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
      if (!match) {
        throw new ParseError("Invalid size: '" + res.text + "'", res);
      }
      var data = {
        number: +(match[1] + match[2]),
        // sign + magnitude, cast to number
        unit: match[3]
      };
      if (!validUnit(data)) {
        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
      }
      return {
        type: "size",
        mode: this.mode,
        value: data,
        isBlank
      };
    }
    /**
     * Parses an URL, checking escaped letters and allowed protocols,
     * and setting the catcode of % as an active character (as in \hyperref).
     */
    parseUrlGroup(optional) {
      this.gullet.lexer.setCatcode("%", 13);
      this.gullet.lexer.setCatcode("~", 12);
      var res = this.parseStringGroup("url", optional);
      this.gullet.lexer.setCatcode("%", 14);
      this.gullet.lexer.setCatcode("~", 13);
      if (res == null) {
        return null;
      }
      var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
      return {
        type: "url",
        mode: this.mode,
        url
      };
    }
    /**
     * Parses an argument with the mode specified.
     */
    parseArgumentGroup(optional, mode) {
      var argToken = this.gullet.scanArgument(optional);
      if (argToken == null) {
        return null;
      }
      var outerMode = this.mode;
      if (mode) {
        this.switchMode(mode);
      }
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, "EOF");
      this.expect("EOF");
      this.gullet.endGroup();
      var result = {
        type: "ordgroup",
        mode: this.mode,
        loc: argToken.loc,
        body: expression
      };
      if (mode) {
        this.switchMode(outerMode);
      }
      return result;
    }
    /**
     * Parses an ordinary group, which is either a single nucleus (like "x")
     * or an expression in braces (like "{x+y}") or an implicit group, a group
     * that starts at the current position, and ends right before a higher explicit
     * group ends, or at EOF.
     */
    parseGroup(name, breakOnTokenText) {
      var firstToken = this.fetch();
      var text2 = firstToken.text;
      var result;
      if (text2 === "{" || text2 === "\\begingroup") {
        this.consume();
        var groupEnd = text2 === "{" ? "}" : "\\endgroup";
        this.gullet.beginGroup();
        var expression = this.parseExpression(false, groupEnd);
        var lastToken = this.fetch();
        this.expect(groupEnd);
        this.gullet.endGroup();
        result = {
          type: "ordgroup",
          mode: this.mode,
          loc: SourceLocation.range(firstToken, lastToken),
          body: expression,
          // A group formed by \begingroup...\endgroup is a semi-simple group
          // which doesn't affect spacing in math mode, i.e., is transparent.
          // https://tex.stackexchange.com/questions/1930/when-should-one-
          // use-begingroup-instead-of-bgroup
          semisimple: text2 === "\\begingroup" || void 0
        };
      } else {
        result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
        if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
          if (this.settings.throwOnError) {
            throw new ParseError("Undefined control sequence: " + text2, firstToken);
          }
          result = this.formatUnsupportedCmd(text2);
          this.consume();
        }
      }
      return result;
    }
    /**
     * Form ligature-like combinations of characters for text mode.
     * This includes inputs like "--", "---", "``" and "''".
     * The result will simply replace multiple textord nodes with a single
     * character in each value by a single textord node having multiple
     * characters in its value.  The representation is still ASCII source.
     * The group will be modified in place.
     */
    formLigatures(group) {
      var n3 = group.length - 1;
      for (var i4 = 0; i4 < n3; ++i4) {
        var a4 = group[i4];
        var v3 = a4.text;
        if (v3 === "-" && group[i4 + 1].text === "-") {
          if (i4 + 1 < n3 && group[i4 + 2].text === "-") {
            group.splice(i4, 3, {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(a4, group[i4 + 2]),
              text: "---"
            });
            n3 -= 2;
          } else {
            group.splice(i4, 2, {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(a4, group[i4 + 1]),
              text: "--"
            });
            n3 -= 1;
          }
        }
        if ((v3 === "'" || v3 === "`") && group[i4 + 1].text === v3) {
          group.splice(i4, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a4, group[i4 + 1]),
            text: v3 + v3
          });
          n3 -= 1;
        }
      }
    }
    /**
     * Parse a single symbol out of the string. Here, we handle single character
     * symbols and special functions like \verb.
     */
    parseSymbol() {
      var nucleus = this.fetch();
      var text2 = nucleus.text;
      if (/^\\verb[^a-zA-Z]/.test(text2)) {
        this.consume();
        var arg = text2.slice(5);
        var star = arg.charAt(0) === "*";
        if (star) {
          arg = arg.slice(1);
        }
        if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
          throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
        }
        arg = arg.slice(1, -1);
        return {
          type: "verb",
          mode: "text",
          body: arg,
          star
        };
      }
      if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
        if (this.settings.strict && this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
        text2 = unicodeSymbols[text2[0]] + text2.slice(1);
      }
      var match = combiningDiacriticalMarksEndRegex.exec(text2);
      if (match) {
        text2 = text2.substring(0, match.index);
        if (text2 === "i") {
          text2 = "\u0131";
        } else if (text2 === "j") {
          text2 = "\u0237";
        }
      }
      var symbol;
      if (symbols[this.mode][text2]) {
        if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
        var group = symbols[this.mode][text2].group;
        var loc = SourceLocation.range(nucleus);
        var s3;
        if (ATOMS.hasOwnProperty(group)) {
          var family = group;
          s3 = {
            type: "atom",
            mode: this.mode,
            family,
            loc,
            text: text2
          };
        } else {
          s3 = {
            type: group,
            mode: this.mode,
            loc,
            text: text2
          };
        }
        symbol = s3;
      } else if (text2.charCodeAt(0) >= 128) {
        if (this.settings.strict) {
          if (!supportedCodepoint(text2.charCodeAt(0))) {
            this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
          } else if (this.mode === "math") {
            this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
          }
        }
        symbol = {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(nucleus),
          text: text2
        };
      } else {
        return null;
      }
      this.consume();
      if (match) {
        for (var i4 = 0; i4 < match[0].length; i4++) {
          var accent2 = match[0][i4];
          if (!unicodeAccents[accent2]) {
            throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
          }
          var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
          if (!command) {
            throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
          }
          symbol = {
            type: "accent",
            mode: this.mode,
            loc: SourceLocation.range(nucleus),
            label: command,
            isStretchy: false,
            isShifty: true,
            // $FlowFixMe
            base: symbol
          };
        }
      }
      return symbol;
    }
  };
  Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
  var parseTree = function parseTree2(toParse, settings) {
    if (!(typeof toParse === "string" || toParse instanceof String)) {
      throw new TypeError("KaTeX can only parse string typed expression");
    }
    var parser = new Parser(toParse, settings);
    delete parser.gullet.macros.current["\\df@tag"];
    var tree = parser.parse();
    delete parser.gullet.macros.current["\\current@color"];
    delete parser.gullet.macros.current["\\color"];
    if (parser.gullet.macros.get("\\df@tag")) {
      if (!settings.displayMode) {
        throw new ParseError("\\tag works only in display equations");
      }
      tree = [{
        type: "tag",
        mode: "text",
        body: tree,
        tag: parser.subparse([new Token("\\df@tag")])
      }];
    }
    return tree;
  };
  var render = function render2(expression, baseNode, options) {
    baseNode.textContent = "";
    var node = renderToDomTree(expression, options).toNode();
    baseNode.appendChild(node);
  };
  if (typeof document !== "undefined") {
    if (document.compatMode !== "CSS1Compat") {
      typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
      render = function render3() {
        throw new ParseError("KaTeX doesn't work in quirks mode.");
      };
    }
  }
  var renderToString = function renderToString2(expression, options) {
    var markup = renderToDomTree(expression, options).toMarkup();
    return markup;
  };
  var generateParseTree = function generateParseTree2(expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
  };
  var renderError = function renderError2(error, expression, options) {
    if (options.throwOnError || !(error instanceof ParseError)) {
      throw error;
    }
    var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
    node.setAttribute("title", error.toString());
    node.setAttribute("style", "color:" + options.errorColor);
    return node;
  };
  var renderToDomTree = function renderToDomTree2(expression, options) {
    var settings = new Settings(options);
    try {
      var tree = parseTree(expression, settings);
      return buildTree(tree, expression, settings);
    } catch (error) {
      return renderError(error, expression, settings);
    }
  };
  var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
    var settings = new Settings(options);
    try {
      var tree = parseTree(expression, settings);
      return buildHTMLTree(tree, expression, settings);
    } catch (error) {
      return renderError(error, expression, settings);
    }
  };
  var version = "0.16.22";
  var __domTree = {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  };
  var katex = {
    /**
     * Current KaTeX version
     */
    version,
    /**
     * Renders the given LaTeX into an HTML+MathML combination, and adds
     * it as a child to the specified DOM node.
     */
    render,
    /**
     * Renders the given LaTeX into an HTML+MathML combination string,
     * for sending to the client.
     */
    renderToString,
    /**
     * KaTeX error, usually during parsing.
     */
    ParseError,
    /**
     * The schema of Settings
     */
    SETTINGS_SCHEMA,
    /**
     * Parses the given LaTeX into KaTeX's internal parse tree structure,
     * without rendering to HTML or MathML.
     *
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __parse: generateParseTree,
    /**
     * Renders the given LaTeX into an HTML+MathML internal DOM tree
     * representation, without flattening that representation to a string.
     *
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __renderToDomTree: renderToDomTree,
    /**
     * Renders the given LaTeX into an HTML internal DOM tree representation,
     * without MathML and without flattening that representation to a string.
     *
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __renderToHTMLTree: renderToHTMLTree,
    /**
     * extends internal font metrics object with a new object
     * each key in the new object represents a font name
    */
    __setFontMetrics: setFontMetrics,
    /**
     * adds a new symbol to builtin symbols table
     */
    __defineSymbol: defineSymbol,
    /**
     * adds a new function to builtin function list,
     * which directly produce parse tree elements
     * and have their own html/mathml builders
     */
    __defineFunction: defineFunction,
    /**
     * adds a new macro to builtin macro list
     */
    __defineMacro: defineMacro,
    /**
     * Expose the dom tree node types, which can be useful for type checking nodes.
     *
     * NOTE: These methods are not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __domTree
  };

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/lib/smd.min.js
  var I3 = 1;
  var k3 = 2;
  var L3 = 4;
  var T4 = 8;
  var f3 = 16;
  function ee3(e3) {
    switch (e3) {
      case I3:
        return "href";
      case k3:
        return "src";
      case L3:
        return "class";
      case T4:
        return "checked";
      case f3:
        return "start";
    }
  }
  var ne3 = (e3) => {
    switch (e3) {
      case 1:
        return 3;
      case 2:
        return 4;
      case 3:
        return 5;
      case 4:
        return 6;
      case 5:
        return 7;
      default:
        return 8;
    }
  };
  var te3 = ne3;
  var O3 = 24;
  function ae3(e3) {
    let c3 = new Uint32Array(O3);
    return c3[0] = 1, { renderer: e3, text: "", pending: "", tokens: c3, len: 0, token: 1, fence_end: 0, blockquote_idx: 0, hr_char: "", hr_chars: 0, fence_start: 0, spaces: new Uint8Array(O3), indent: "", indent_len: 0, table_state: 0 };
  }
  function a3(e3) {
    e3.text.length !== 0 && (e3.renderer.add_text(e3.renderer.data, e3.text), e3.text = "");
  }
  function _3(e3) {
    e3.len -= 1, e3.token = e3.tokens[e3.len], e3.renderer.end_token(e3.renderer.data);
  }
  function i3(e3, c3) {
    (e3.tokens[e3.len] === 24 || e3.tokens[e3.len] === 23) && c3 !== 25 && _3(e3), e3.len += 1, e3.tokens[e3.len] = c3, e3.token = c3, e3.renderer.add_token(e3.renderer.data, c3);
  }
  function re3(e3, c3, n3) {
    for (; n3 <= e3.len; ) {
      if (e3.tokens[n3] === c3)
        return n3;
      n3 += 1;
    }
    return -1;
  }
  function l3(e3, c3) {
    for (e3.fence_start = 0; e3.len > c3; )
      _3(e3);
  }
  function u3(e3, c3) {
    let n3 = 0;
    for (let t3 = 0; t3 <= e3.len && (c3 -= e3.spaces[t3], !(c3 < 0)); t3 += 1)
      switch (e3.tokens[t3]) {
        case 9:
        case 10:
        case 20:
        case 25:
          n3 = t3;
          break;
      }
    for (; e3.len > n3; )
      _3(e3);
    return c3;
  }
  function A3(e3, c3) {
    let n3 = -1, t3 = -1;
    for (let s3 = e3.blockquote_idx + 1; s3 <= e3.len; s3 += 1)
      if (e3.tokens[s3] === 25) {
        if (e3.indent_len < e3.spaces[s3]) {
          t3 = -1;
          break;
        }
        t3 = s3;
      } else
        e3.tokens[s3] === c3 && (n3 = s3);
    return t3 === -1 ? n3 === -1 ? (l3(e3, e3.blockquote_idx), i3(e3, c3), true) : (l3(e3, n3), false) : (l3(e3, t3), i3(e3, c3), true);
  }
  function g3(e3, c3) {
    i3(e3, 25), e3.spaces[e3.len] = e3.indent_len + c3, E3(e3), e3.token = 103;
  }
  function E3(e3) {
    e3.indent = "", e3.indent_len = 0, e3.pending = "";
  }
  function N3(e3) {
    switch (e3) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return true;
      default:
        return false;
    }
  }
  function ie3(e3) {
    switch (e3) {
      case 32:
      case 58:
      case 59:
      case 41:
      case 44:
      case 33:
      case 46:
      case 63:
      case 93:
      case 10:
        return true;
      default:
        return false;
    }
  }
  function se3(e3) {
    return N3(e3) || ie3(e3);
  }
  function o3(e3, c3) {
    for (let n3 of c3) {
      if (e3.token === 101) {
        switch (n3) {
          case " ":
            e3.indent_len += 1;
            continue;
          case "	":
            e3.indent_len += 4;
            continue;
        }
        let s3 = u3(e3, e3.indent_len);
        e3.indent_len = 0, e3.token = e3.tokens[e3.len], s3 > 0 && o3(e3, " ".repeat(s3));
      }
      let t3 = e3.pending + n3;
      switch (e3.token) {
        case 21:
        case 1:
        case 20:
        case 24:
        case 23:
          switch (e3.pending[0]) {
            case void 0:
              e3.pending = n3;
              continue;
            case " ":
              e3.pending = n3, e3.indent += " ", e3.indent_len += 1;
              continue;
            case "	":
              e3.pending = n3, e3.indent += "	", e3.indent_len += 4;
              continue;
            case `
`:
              if (e3.tokens[e3.len] === 25 && e3.token === 21) {
                _3(e3), E3(e3), e3.pending = n3;
                continue;
              }
              l3(e3, e3.blockquote_idx), E3(e3), e3.blockquote_idx = 0, e3.fence_start = 0, e3.pending = n3;
              continue;
            case "#":
              switch (n3) {
                case "#":
                  if (e3.pending.length < 6) {
                    e3.pending = t3;
                    continue;
                  }
                  break;
                case " ":
                  u3(e3, e3.indent_len), i3(e3, te3(e3.pending.length)), E3(e3);
                  continue;
              }
              break;
            case ">": {
              let r3 = re3(e3, 20, e3.blockquote_idx + 1);
              r3 === -1 ? (l3(e3, e3.blockquote_idx), e3.blockquote_idx += 1, e3.fence_start = 0, i3(e3, 20)) : e3.blockquote_idx = r3, E3(e3), e3.pending = n3;
              continue;
            }
            case "-":
            case "*":
            case "_":
              if (e3.hr_chars === 0 && (e3.hr_chars = 1, e3.hr_char = e3.pending), e3.hr_chars > 0) {
                switch (n3) {
                  case e3.hr_char:
                    e3.hr_chars += 1, e3.pending = t3;
                    continue;
                  case " ":
                    e3.pending = t3;
                    continue;
                  case `
`:
                    if (e3.hr_chars < 3)
                      break;
                    u3(e3, e3.indent_len), e3.renderer.add_token(e3.renderer.data, 22), e3.renderer.end_token(e3.renderer.data), E3(e3), e3.hr_chars = 0;
                    continue;
                }
                e3.hr_chars = 0;
              }
              if (e3.pending[0] !== "_" && e3.pending[1] === " ") {
                A3(e3, 23), g3(e3, 2), o3(e3, t3.slice(2));
                continue;
              }
              break;
            case "`":
              if (e3.pending.length < 3) {
                if (n3 === "`") {
                  e3.pending = t3, e3.fence_start = t3.length;
                  continue;
                }
                e3.fence_start = 0;
                break;
              }
              switch (n3) {
                case "`":
                  e3.pending.length === e3.fence_start ? (e3.pending = t3, e3.fence_start = t3.length) : (i3(e3, 2), E3(e3), e3.fence_start = 0, o3(e3, t3));
                  continue;
                case `
`: {
                  u3(e3, e3.indent_len), i3(e3, 10), e3.pending.length > e3.fence_start && e3.renderer.set_attr(e3.renderer.data, L3, e3.pending.slice(e3.fence_start)), E3(e3), e3.token = 101;
                  continue;
                }
                default:
                  e3.pending = t3;
                  continue;
              }
            case "+":
              if (n3 !== " ")
                break;
              A3(e3, 23), g3(e3, 2);
              continue;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              if (e3.pending[e3.pending.length - 1] === ".") {
                if (n3 !== " ")
                  break;
                A3(e3, 24) && e3.pending !== "1." && e3.renderer.set_attr(e3.renderer.data, f3, e3.pending.slice(0, -1)), g3(e3, e3.pending.length + 1);
                continue;
              } else {
                let r3 = n3.charCodeAt(0);
                if (r3 === 46 || N3(r3)) {
                  e3.pending = t3;
                  continue;
                }
              }
              break;
            case "|":
              l3(e3, e3.blockquote_idx), i3(e3, 27), i3(e3, 28), e3.pending = "", o3(e3, n3);
              continue;
          }
          let s3 = t3;
          if (e3.token === 21)
            e3.token = e3.tokens[e3.len], e3.renderer.add_token(e3.renderer.data, 21), e3.renderer.end_token(e3.renderer.data);
          else if (e3.indent_len >= 4) {
            let r3 = 0;
            for (; r3 < 4; r3 += 1)
              if (e3.indent[r3] === "	") {
                r3 = r3 + 1;
                break;
              }
            s3 = e3.indent.slice(r3) + t3, i3(e3, 9);
          } else
            i3(e3, 2);
          E3(e3), o3(e3, s3);
          continue;
        case 27:
          if (e3.table_state === 1)
            switch (n3) {
              case "-":
              case " ":
              case "|":
              case ":":
                e3.pending = t3;
                continue;
              case `
`:
                e3.table_state = 2, e3.pending = "";
                continue;
              default:
                _3(e3), e3.table_state = 0;
                break;
            }
          else
            switch (e3.pending) {
              case "|":
                i3(e3, 28), e3.pending = "", o3(e3, n3);
                continue;
              case `
`:
                _3(e3), e3.pending = "", e3.table_state = 0, o3(e3, n3);
                continue;
            }
          break;
        case 28:
          switch (e3.pending) {
            case "":
              break;
            case "|":
              i3(e3, 29), _3(e3), e3.pending = "", o3(e3, n3);
              continue;
            case `
`:
              _3(e3), e3.table_state = Math.min(e3.table_state + 1, 2), e3.pending = "", o3(e3, n3);
              continue;
            default:
              i3(e3, 29), o3(e3, n3);
              continue;
          }
          break;
        case 29:
          if (e3.pending === "|") {
            a3(e3), _3(e3), e3.pending = "", o3(e3, n3);
            continue;
          }
          break;
        case 9:
          switch (t3) {
            case `
    `:
            case `
   	`:
            case `
  	`:
            case `
 	`:
            case `
	`:
              e3.text += `
`, e3.pending = "";
              continue;
            case `
`:
            case `
 `:
            case `
  `:
            case `
   `:
              e3.pending = t3;
              continue;
            default:
              e3.pending.length !== 0 ? (a3(e3), _3(e3), e3.pending = n3) : e3.text += n3;
              continue;
          }
        case 10:
          switch (n3) {
            case "`":
              e3.pending = t3;
              continue;
            case `
`:
              if (t3.length === e3.fence_start + e3.fence_end + 1) {
                a3(e3), _3(e3), e3.pending = "", e3.fence_start = 0, e3.fence_end = 0, e3.token = 101;
                continue;
              }
              e3.token = 101;
              break;
            case " ":
              if (e3.pending[0] === `
`) {
                e3.pending = t3, e3.fence_end += 1;
                continue;
              }
              break;
          }
          e3.text += e3.pending, e3.pending = n3, e3.fence_end = 1;
          continue;
        case 11:
          switch (n3) {
            case "`":
              t3.length === e3.fence_start + +(e3.pending[0] === " ") ? (a3(e3), _3(e3), e3.pending = "", e3.fence_start = 0) : e3.pending = t3;
              continue;
            case `
`:
              e3.text += e3.pending, e3.pending = "", e3.token = 21, e3.blockquote_idx = 0, a3(e3);
              continue;
            case " ":
              e3.text += e3.pending, e3.pending = n3;
              continue;
            default:
              e3.text += t3, e3.pending = "";
              continue;
          }
        case 103:
          switch (e3.pending.length) {
            case 0:
              if (n3 !== "[")
                break;
              e3.pending = t3;
              continue;
            case 1:
              if (n3 !== " " && n3 !== "x")
                break;
              e3.pending = t3;
              continue;
            case 2:
              if (n3 !== "]")
                break;
              e3.pending = t3;
              continue;
            case 3:
              if (n3 !== " ")
                break;
              e3.renderer.add_token(e3.renderer.data, 26), e3.pending[1] === "x" && e3.renderer.set_attr(e3.renderer.data, T4, ""), e3.renderer.end_token(e3.renderer.data), e3.pending = " ";
              continue;
          }
          e3.token = e3.tokens[e3.len], e3.pending = "", o3(e3, t3);
          continue;
        case 14:
        case 15: {
          let r3 = "*", d3 = 12;
          if (e3.token === 15 && (r3 = "_", d3 = 13), r3 === e3.pending) {
            if (a3(e3), r3 === n3) {
              _3(e3), e3.pending = "";
              continue;
            }
            i3(e3, d3), e3.pending = n3;
            continue;
          }
          break;
        }
        case 12:
        case 13: {
          let r3 = "*", d3 = 14;
          switch (e3.token === 13 && (r3 = "_", d3 = 15), e3.pending) {
            case r3:
              r3 === n3 ? e3.tokens[e3.len - 1] === d3 ? e3.pending = t3 : (a3(e3), i3(e3, d3), e3.pending = "") : (a3(e3), _3(e3), e3.pending = n3);
              continue;
            case r3 + r3:
              let R3 = e3.token;
              a3(e3), _3(e3), _3(e3), r3 !== n3 ? (i3(e3, R3), e3.pending = n3) : e3.pending = "";
              continue;
          }
          break;
        }
        case 16:
          if (t3 === "~~") {
            a3(e3), _3(e3), e3.pending = "";
            continue;
          }
          break;
        case 105:
          n3 === `
` ? (a3(e3), i3(e3, 30), e3.pending = "") : (e3.token = e3.tokens[e3.len], e3.pending[0] === "\\" ? e3.text += "[" : e3.text += "$$", e3.pending = "", o3(e3, n3));
          continue;
        case 30:
          if (t3 === "\\]" || t3 === "$$") {
            a3(e3), _3(e3), e3.pending = "";
            continue;
          }
          break;
        case 31:
          if (t3 === "\\)" || e3.pending[0] === "$") {
            a3(e3), _3(e3), n3 === ")" ? e3.pending = "" : e3.pending = n3;
            continue;
          }
          break;
        case 102:
          t3 === "http://" || t3 === "https://" ? (a3(e3), i3(e3, 18), e3.pending = t3, e3.text = t3) : "http:/"[e3.pending.length] === n3 || "https:/"[e3.pending.length] === n3 ? e3.pending = t3 : (e3.token = e3.tokens[e3.len], o3(e3, n3));
          continue;
        case 17:
        case 19:
          if (e3.pending === "]") {
            a3(e3), n3 === "(" ? e3.pending = t3 : (_3(e3), e3.pending = n3);
            continue;
          }
          if (e3.pending[0] === "]" && e3.pending[1] === "(") {
            if (n3 === ")") {
              let r3 = e3.token === 17 ? I3 : k3, d3 = e3.pending.slice(2);
              e3.renderer.set_attr(e3.renderer.data, r3, d3), _3(e3), e3.pending = "";
            } else
              e3.pending += n3;
            continue;
          }
          break;
        case 18:
          n3 === " " || n3 === `
` || n3 === "\\" ? (e3.renderer.set_attr(e3.renderer.data, I3, e3.pending), a3(e3), _3(e3), e3.pending = n3) : (e3.text += n3, e3.pending = t3);
          continue;
        case 104:
          if (t3.startsWith("<br")) {
            if (t3.length === 3 || n3 === " " || n3 === "/" && (t3.length === 4 || e3.pending[e3.pending.length - 1] === " ")) {
              e3.pending = t3;
              continue;
            }
            if (n3 === ">") {
              a3(e3), e3.token = e3.tokens[e3.len], e3.renderer.add_token(e3.renderer.data, 21), e3.renderer.end_token(e3.renderer.data), e3.pending = "";
              continue;
            }
          }
          e3.token = e3.tokens[e3.len], e3.text += "<", e3.pending = e3.pending.slice(1), o3(e3, n3);
          continue;
      }
      switch (e3.pending[0]) {
        case "\\":
          if (e3.token === 19 || e3.token === 30 || e3.token === 31)
            break;
          switch (n3) {
            case "(":
              a3(e3), i3(e3, 31), e3.pending = "";
              continue;
            case "[":
              e3.token = 105, e3.pending = t3;
              continue;
            case `
`:
              e3.pending = n3;
              continue;
            default:
              let s3 = n3.charCodeAt(0);
              e3.pending = "", e3.text += N3(s3) || s3 >= 65 && s3 <= 90 || s3 >= 97 && s3 <= 122 ? t3 : n3;
              continue;
          }
        case `
`:
          switch (e3.token) {
            case 19:
            case 30:
            case 31:
              break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
              a3(e3), l3(e3, e3.blockquote_idx), e3.blockquote_idx = 0, e3.pending = n3;
              continue;
            default:
              a3(e3), e3.pending = n3, e3.token = 21, e3.blockquote_idx = 0;
              continue;
          }
          break;
        case "<":
          if (e3.token !== 19 && e3.token !== 30 && e3.token !== 31) {
            a3(e3), e3.pending = t3, e3.token = 104;
            continue;
          }
          break;
        case "`":
          if (e3.token === 19)
            break;
          n3 === "`" ? (e3.fence_start += 1, e3.pending = t3) : (e3.fence_start += 1, a3(e3), i3(e3, 11), e3.text = n3 === " " || n3 === `
` ? "" : n3, e3.pending = "");
          continue;
        case "_":
        case "*": {
          if (e3.token === 19 || e3.token === 30 || e3.token === 31 || e3.token === 14)
            break;
          let s3 = 12, r3 = 14, d3 = e3.pending[0];
          if (d3 === "_" && (s3 = 13, r3 = 15), e3.pending.length === 1) {
            if (d3 === n3) {
              e3.pending = t3;
              continue;
            }
            if (n3 !== " " && n3 !== `
`) {
              a3(e3), i3(e3, s3), e3.pending = n3;
              continue;
            }
          } else {
            if (d3 === n3) {
              a3(e3), i3(e3, r3), i3(e3, s3), e3.pending = "";
              continue;
            }
            if (n3 !== " " && n3 !== `
`) {
              a3(e3), i3(e3, r3), e3.pending = n3;
              continue;
            }
          }
          break;
        }
        case "~":
          if (e3.token !== 19 && e3.token !== 16) {
            if (e3.pending === "~") {
              if (n3 === "~") {
                e3.pending = t3;
                continue;
              }
            } else if (n3 !== " " && n3 !== `
`) {
              a3(e3), i3(e3, 16), e3.pending = n3;
              continue;
            }
          }
          break;
        case "$":
          if (e3.token !== 19 && e3.token !== 16 && e3.pending === "$")
            if (n3 === "$") {
              e3.token = 105, e3.pending = t3;
              continue;
            } else {
              if (se3(n3.charCodeAt(0)))
                break;
              a3(e3), i3(e3, 31), e3.pending = n3;
              continue;
            }
          break;
        case "[":
          if (e3.token !== 19 && e3.token !== 17 && e3.token !== 30 && e3.token !== 31 && n3 !== "]") {
            a3(e3), i3(e3, 17), e3.pending = n3;
            continue;
          }
          break;
        case "!":
          if (e3.token !== 19 && n3 === "[") {
            a3(e3), i3(e3, 19), e3.pending = "";
            continue;
          }
          break;
        case " ":
          if (e3.pending.length === 1 && n3 === " ")
            continue;
          break;
      }
      if (e3.token !== 19 && e3.token !== 17 && e3.token !== 30 && e3.token !== 31 && n3 === "h" && (e3.pending === " " || e3.pending === "")) {
        e3.text += e3.pending, e3.pending = n3, e3.token = 102;
        continue;
      }
      e3.text += e3.pending, e3.pending = n3;
    }
    a3(e3);
  }
  function _e3(e3) {
    return { add_token: oe3, end_token: de3, add_text: Ee3, set_attr: le3, data: { nodes: [e3, , , , ,], index: 0 } };
  }
  function oe3(e3, c3) {
    var _a;
    let n3 = e3.nodes[e3.index], t3;
    switch (c3) {
      case 1:
        return;
      case 20:
        t3 = document.createElement("blockquote");
        break;
      case 2:
        t3 = document.createElement("p");
        break;
      case 21:
        t3 = document.createElement("br");
        break;
      case 22:
        t3 = document.createElement("hr");
        break;
      case 3:
        t3 = document.createElement("h1");
        break;
      case 4:
        t3 = document.createElement("h2");
        break;
      case 5:
        t3 = document.createElement("h3");
        break;
      case 6:
        t3 = document.createElement("h4");
        break;
      case 7:
        t3 = document.createElement("h5");
        break;
      case 8:
        t3 = document.createElement("h6");
        break;
      case 12:
      case 13:
        t3 = document.createElement("em");
        break;
      case 14:
      case 15:
        t3 = document.createElement("strong");
        break;
      case 16:
        t3 = document.createElement("s");
        break;
      case 11:
        t3 = document.createElement("code");
        break;
      case 18:
      case 17:
        t3 = document.createElement("a");
        break;
      case 19:
        t3 = document.createElement("img");
        break;
      case 23:
        t3 = document.createElement("ul");
        break;
      case 24:
        t3 = document.createElement("ol");
        break;
      case 25:
        t3 = document.createElement("li");
        break;
      case 26:
        let s3 = t3 = document.createElement("input");
        s3.type = "checkbox", s3.disabled = true;
        break;
      case 9:
      case 10:
        n3 = n3.appendChild(document.createElement("pre")), t3 = document.createElement("code");
        break;
      case 27:
        t3 = document.createElement("table");
        break;
      case 28:
        switch (n3.children.length) {
          case 0:
            n3 = n3.appendChild(document.createElement("thead"));
            break;
          case 1:
            n3 = n3.appendChild(document.createElement("tbody"));
            break;
          default:
            n3 = n3.children[1];
        }
        t3 = document.createElement("tr");
        break;
      case 29:
        t3 = document.createElement(((_a = n3.parentElement) == null ? void 0 : _a.tagName) === "THEAD" ? "th" : "td");
        break;
      case 30:
        t3 = document.createElement("equation-block");
        break;
      case 31:
        t3 = document.createElement("equation-inline");
        break;
    }
    e3.nodes[++e3.index] = n3.appendChild(t3);
  }
  function de3(e3) {
    e3.index -= 1;
  }
  function Ee3(e3, c3) {
    e3.nodes[e3.index].appendChild(document.createTextNode(c3));
  }
  function le3(e3, c3, n3) {
    e3.nodes[e3.index].setAttribute(ee3(c3), n3);
  }

  // ../../../../../_My_work/_Mine/markdown-test/uni_modules/silkide-markdown-streaming/components/silkide-markdown-streaming/utils/index.js
  function isTextOnlyShallow(el) {
    if (el.querySelector("*"))
      return false;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_COMMENT, null);
    return !walker.nextNode();
  }

  // <stdin>
  var import_purify_min = __toESM(require_purify_min());
  var import_markdown_it_incremental_dom = __toESM(require_markdown_it_incremental_dom());
  var import_incremental_dom = __toESM(require_incremental_dom());
  if (typeof window !== "undefined") {
    window.MarkdownIt = markdown_it_min_default;
    window.hljs = $e2;
    window.katex = katex;
    window.DOMPurify = import_purify_min.default;
    window.IncrementalDOM = import_incremental_dom.default;
    window.MarkdownItIncrementalDOM = import_markdown_it_incremental_dom.default;
  }
  var stdin_default = {
    data() {
      return {
        fullText: "",
        // markdown
        config: {},
        copyCodeData: [],
        // , renderjs self-manages this now
        markdownParser: null,
        // Markdown
        showLineValue: true,
        // 
        currentSource: "",
        // md
        katexCache: {},
        // KaTeX 
        targetMdElement: null,
        // md
        throttleTimeout: null,
        // ID
        lastRenderCallTime: 0,
        // renderContent
        throttleTime: 150,
        // 
        gate: {
          isConfigUpdated: false,
          isTargetIdUpdated: false,
          isSourceUpdated: false,
          isShowLineUpdated: false
        }
      };
    },
    mounted() {
      console.log("smd", _e3);
      console.log("DOMPurify", import_purify_min.default);
      console.log("this.config", this.config.isPurify);
    },
    methods: {
      tryInitMarkdownParser() {
        console.log("\u5C1D\u8BD5\u521D\u59CB\u5316Markdown\u89E3\u6790\u5668");
        if (this.gate.isConfigUpdated && this.gate.isTargetIdUpdated && this.gate.isSourceUpdated && this.gate.isShowLineUpdated) {
          console.log("tryInitMarkdownParser");
          this.initMarkdownParser();
        }
      },
      /**
       * 
       */
      appendText(newChunk, oldChunk, ownerVm, vm) {
        let maxTime = 0;
        let time = performance.now();
        if (typeof newChunk !== "string" || newChunk.length === 0)
          return;
        this.fullText = (this.fullText || "") + newChunk;
        if (this.config.isPurify) {
          import_purify_min.default.sanitize(this.fullText);
          if (import_purify_min.default.removed.length) {
            return;
          }
        }
        if (!this.config.isStreamingParse) {
          if (this.config.preProcessText && typeof this.config.preProcessText === "function") {
            try {
              this.fullText = this.config.preProcessText(this.fullText);
            } catch (error) {
              console.error("\u9884\u5904\u7406\u6587\u672C\u5931\u8D25", error);
            }
          }
          this.renderContent(newChunk);
        } else {
          this.renderContentSmd(newChunk);
        }
        if (performance.now() - time > maxTime) {
          maxTime = performance.now() - time;
        }
        console.log("appendText time", performance.now() - time, maxTime);
      },
      /**
       * 
       */
      updateConfig(newConfig, oldConfig, ownerVm, vm) {
        this.config = newConfig;
        this.gate.isConfigUpdated = true;
        console.log("this.config2", this.config);
        this.tryInitMarkdownParser();
      },
      /**
       * md
       */
      setTargetId(newId, oldId, ownerVm, vm) {
        console.log("setTargetId", newId);
        this.targetId = newId;
        this.targetMdElement = document.getElementById(this.targetId);
        this.gate.isTargetIdUpdated = true;
        console.log("this.targetMdElement", this.targetMdElement);
        this.tryInitMarkdownParser();
      },
      /**
       * 
       */
      updateSource(newSource, oldSource, ownerVm, vm) {
        console.log("updateSource", newSource);
        this.currentSource = newSource;
        this.gate.isSourceUpdated = true;
        this.tryInitMarkdownParser();
        const now = Date.now();
        if (this.throttleTimeout) {
          clearTimeout(this.throttleTimeout);
        }
        const timeSinceLastCall = now - (this.lastRenderCallTime || 0);
        if (timeSinceLastCall >= this.throttleTime) {
          this.lastRenderCallTime = now;
        } else {
          this.throttleTimeout = setTimeout(() => {
            this.lastRenderCallTime = Date.now();
          }, this.throttleTime - timeSinceLastCall);
        }
      },
      /**
       * 
       */
      updateShowLine(newShowLine, oldShowLine, ownerVm, vm) {
        console.log("updateShowLine", newShowLine);
        const newBoolValue = newShowLine === true || newShowLine === "true";
        this.gate.isShowLineUpdated = true;
        this.tryInitMarkdownParser();
        if (this.showLineValue !== newBoolValue) {
          this.showLineValue = newBoolValue;
          if (this.hostElement && this.currentSource) {
          }
        }
      },
      /**
       * Markdown
       */
      initMarkdownParser() {
        console.log("initMarkdownParser", this.config.isStreamingParse);
        if (this.markdownParser)
          return;
        if (this.config.isStreamingParse) {
          console.log("smd\u6E32\u67D3\u5668\u521D\u59CB\u5316\u4E86");
          const renderer = _e3(this.targetMdElement);
          console.log("renderer", renderer);
          this.markdownParser = ae3(renderer);
          console.log("this.markdownParser", this.markdownParser);
        } else {
          this.markdownParser = new window.MarkdownIt({
            html: true,
            highlight: (str, lang) => {
              let preCode = "";
              try {
                preCode = window.hljs.highlightAuto(str).value;
              } catch (err) {
                preCode = this.markdownParser.utils.escapeHtml(str);
              }
              const lines = preCode.split(/\n/).slice(0, -1);
              let html = lines.map((item, index) => {
                if (item == "") {
                  return "";
                }
                return '<li><span class="line-num" data-line="' + (index + 1) + '"></span>' + item + "</li>";
              }).join("");
              if (this.showLineValue) {
                html = '<ol style="padding: 0px 30px;">' + html + "</ol>";
              } else {
                html = '<ol style="padding: 0px 7px;list-style:none;">' + html + "</ol>";
              }
              this.copyCodeData.push(str);
              let htmlCode = `<div class="markdown-wrap">`;
              htmlCode += `<div style="color: #aaa;text-align: right;font-size: 12px;padding:8px;">`;
              htmlCode += `${lang}<a class="copy-btn" code-data-index="${this.copyCodeData.length - 1}" style="margin-left: 8px;">\u590D\u5236\u4EE3\u7801</a>`;
              htmlCode += `</div>`;
              if (str.trim().length > 0) {
                htmlCode += `<pre class="hljs" style="padding:10px 8px 0;margin-bottom:5px;overflow: auto;display: block;border-radius: 5px;"><code>${html}</code></pre>`;
              } else {
                htmlCode += `<pre class="hljs" style="display: none;"></pre>`;
              }
              htmlCode += "</div>";
              return htmlCode;
            }
          }).use(import_markdown_it_incremental_dom.default, import_incremental_dom.default);
        }
      },
      renderContentSmd(chunk) {
        o3(this.markdownParser, chunk);
        this.applyLaTeX();
      },
      renderContent() {
        const startTime = typeof performance !== "undefined" ? performance.now() : Date.now();
        if (!this.markdownParser) {
          this.initMarkdownParser();
          if (!this.markdownParser)
            return;
        }
        if (!this.fullText && this.targetMdElement) {
          this.targetMdElement.innerHTML = "";
          return;
        }
        this.copyCodeData = [];
        let value = this.fullText;
        const tableBrPlaceholders = [];
        let hasTableBr = true;
        while (hasTableBr) {
          const beforeReplace = value;
          value = value.replace(/(\|[^|\n]*?)(<br>|<br\/>|<br \/>)([^|\n]*)/g, (match, before, brTag, after) => {
            const placeholder = `__TABLE_BR_${tableBrPlaceholders.length}__`;
            tableBrPlaceholders.push(brTag);
            return before + placeholder + after;
          });
          hasTableBr = beforeReplace !== value;
        }
        value = value.replace(/<br>|<br\/>|<br \/>/g, "\n");
        value = value.replace(/&nbsp;/g, " ");
        const codeBlocks = [];
        const inlineCodeBlocks = [];
        value = value.replace(/```[\s\S]*?```/g, (match) => {
          const id = `CODE_BLOCK_${codeBlocks.length}`;
          codeBlocks.push(match);
          return id;
        });
        value = value.replace(/`[^`]*`/g, (match) => {
          const id = `INLINE_CODE_${inlineCodeBlocks.length}`;
          inlineCodeBlocks.push(match);
          return id;
        });
        value = value.replace(/\$\$([\s\S]*?)\$\$/g, (match, p1) => {
          const formula = p1.trim();
          const cacheKey = `block||${formula}`;
          if (this.katexCache[cacheKey]) {
            return this.katexCache[cacheKey];
          }
          try {
            const renderedHtml = window.katex.renderToString(formula, {
              displayMode: true,
              throwOnError: false
            });
            this.katexCache[cacheKey] = renderedHtml;
            return renderedHtml;
          } catch (err) {
            console.error("KaTeX rendering error (block):", err);
            return match;
          }
        });
        value = value.replace(/\$([^$]+?)\$/g, (match, p1) => {
          const trimmedContent = p1.trim();
          if (!trimmedContent || /^\d+(\.\d+)?$/.test(trimmedContent)) {
            return match;
          }
          const cacheKey = `inline||${trimmedContent}`;
          if (this.katexCache[cacheKey]) {
            return this.katexCache[cacheKey];
          }
          try {
            const renderedHtml = window.katex.renderToString(trimmedContent, {
              displayMode: false,
              throwOnError: false
            });
            this.katexCache[cacheKey] = renderedHtml;
            return renderedHtml;
          } catch (err) {
            console.error("KaTeX rendering error (inline):", err);
            return match;
          }
        });
        inlineCodeBlocks.forEach((block, index) => {
          value = value.replace(`INLINE_CODE_${index}`, block);
        });
        codeBlocks.forEach((block, index) => {
          value = value.replace(`CODE_BLOCK_${index}`, block);
        });
        tableBrPlaceholders.forEach((br2, index) => {
          value = value.replace(`__TABLE_BR_${index}__`, br2);
        });
        let htmlString = "";
        if (value.split("```").length % 2) {
          let mdtext = value;
          if (mdtext[mdtext.length - 1] != "\n") {
            mdtext += "\n";
          }
          import_incremental_dom.default.patch(
            this.targetMdElement,
            this.markdownParser.renderToIncrementalDOM(mdtext)
          );
        } else {
          import_incremental_dom.default.patch(
            this.targetMdElement,
            this.markdownParser.renderToIncrementalDOM(value)
          );
        }
        if (this.targetMdElement) {
          const tables = this.targetMdElement.querySelectorAll("table");
          tables.forEach((table) => {
            table.classList.add("table");
            if (!table.parentElement.classList.contains("table-box")) {
              const tableBox = document.createElement("div");
              tableBox.classList.add("table-box");
              table.parentNode.insertBefore(tableBox, table);
              tableBox.appendChild(table);
            }
          });
          const trs = this.targetMdElement.querySelectorAll("tr");
          trs.forEach((tr2) => tr2.classList.add("tr"));
          const ths = this.targetMdElement.querySelectorAll("th");
          ths.forEach((th) => th.classList.add("th"));
          const tds = this.targetMdElement.querySelectorAll("td");
          tds.forEach((td) => td.classList.add("td"));
          const hrs = this.targetMdElement.querySelectorAll("hr");
          hrs.forEach((hr2) => hr2.classList.add("hr"));
        }
        this.attachEventListeners();
        const endTime = typeof performance !== "undefined" ? performance.now() : Date.now();
        console.log(`markdown\u6E32\u67D3\u65F6\u95F4: ${(endTime - startTime).toFixed(2)} ms`);
        this.throttleTime = endTime - startTime + 80;
      },
      applyLaTeX() {
        this.targetMdElement.querySelectorAll("equation-inline").forEach((el) => {
          if (!isTextOnlyShallow(el)) {
            return;
          }
          katex.render(el.textContent, el, {
            displayMode: false,
            // Inline mode
            throwOnError: false
            // Optional: Don't throw errors on invalid LaTeX
          });
        });
        this.targetMdElement.querySelectorAll("equation-block").forEach((el) => {
          if (!isTextOnlyShallow(el)) {
            return;
          }
          katex.render(el.textContent, el, {
            displayMode: true,
            // Display (block) mode
            throwOnError: false
            // Optional: Don't throw errors on invalid LaTeX
          });
        });
      },
      /**
       * 
       */
      attachEventListeners() {
        if (!this.targetMdElement)
          return;
        const imgs = this.targetMdElement.querySelectorAll("img");
        imgs.forEach((img) => {
          if (!img.hasAttribute("data-click-listener-attached")) {
            img.addEventListener("click", (event) => {
              event.stopPropagation();
              const src = img.getAttribute("src");
              if (src) {
                this.$ownerInstance.callMethod("onRenderjsImageClick", { src });
              }
            });
            img.setAttribute("data-click-listener-attached", "true");
          }
          if (!img.hasAttribute("data-load-listener-attached")) {
            img.addEventListener("load", (event) => {
              const src = img.getAttribute("src");
              if (src) {
                this.$ownerInstance.callMethod("onRenderjsImageLoad", { src });
              }
            });
            img.setAttribute("data-load-listener-attached", "true");
          }
          if (img.complete && img.naturalHeight !== 0) {
            console.log("\u56FE\u7247\u52A0\u8F7D\u5B8C\u6BD5: ", img.getAttribute("src"));
            const src = img.getAttribute("src");
            if (src) {
              setTimeout(() => {
                this.$ownerInstance.callMethod("onRenderjsImageLoad", { src });
              }, 0);
            }
          }
        });
        const copyBtns = this.targetMdElement.querySelectorAll("a.copy-btn");
        copyBtns.forEach((btn) => {
          if (!btn.hasAttribute("data-listener-attached")) {
            btn.addEventListener("click", (event) => {
              event.stopPropagation();
              event.preventDefault();
              const codeDataIndexStr = btn.getAttribute("code-data-index");
              const codeDataIndex = parseInt(codeDataIndexStr);
              if (codeDataIndexStr !== null && !isNaN(codeDataIndex) && this.copyCodeData[codeDataIndex]) {
                this.$ownerInstance.callMethod("onRenderjsCopyCode", {
                  text: this.copyCodeData[codeDataIndex]
                });
              } else {
                console.warn("[ua-markdown renderjs] \u590D\u5236\u6309\u94AE\u88AB\u70B9\u51FB\uFF0C\u6570\u636E\u672A\u627E\u5230: ", codeDataIndexStr, this.copyCodeData);
              }
            });
            btn.setAttribute("data-listener-attached", "true");
          }
        });
        const links = this.targetMdElement.querySelectorAll("a:not(.copy-btn)");
        links.forEach((link) => {
          link.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            const href = link.getAttribute("href");
            if (href) {
              this.$ownerInstance.callMethod("onRenderjsLinkClick", { href });
            }
          });
        });
      }
    }
  };
  return __toCommonJS(stdin_exports);
})();
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
/*!
 * markdown-it-incremental-dom 2.1.0
 * https://github.com/yhatt/markdown-it-incremental-dom
 * 
 * Includes htmlparser2
 * https://github.com/fb55/htmlparser2/
 * https://github.com/fb55/htmlparser2/raw/master/LICENSE
 * 
 * @license MIT
 * https://github.com/yhatt/markdown-it-incremental-dom/raw/master/LICENSE
 */
/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
